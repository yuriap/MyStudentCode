                           Ч А С Т Ь  2.

                 ПРОГРАММИРОВАНИЕ В TURBO VISION.

                             ГЛАВА 3.

                        ИЕРАРХИЯ ОБЪЕКТОВ.

     Эта глава предполагает,  что Вы хорошо  знаете  Turbo  Pascal,
особенно объектно-ориентированные   расширения,   хотя   мы   будем
напоминать некоторую   информацию   о   типах    объектов.    Также
предполагается, что  Вы читали часть 1 этого руководства и получили
обзор философии возможностей и терминологии Turbo Vision.
     После общих  замечаний  об  ООП  и  иерархии  эта  глава  дает
короткий обзор  иерархии  объектов  Turbo  Vision,  обращая  особое
внимание на   взаимосвязи  объектов  через  механизм  наследования.
Изучая главное  свойство  каждого  стандартного  типа  объектов  Вы
получите представление  о  том  как их наследовать и как объединены
поля и методы объекта для создания функциональности этого объекта.
     Полное иерархическое  дерево показано на рис.3.1.  Вам поможет
тщательное изучение этого рисунка.  Например,  информация о том что
TDialog  порожден от TWindow,  который порожден от TGroup,  который
порожден от TView  значительно  сокращает  время  изучения.  Каждый
новый  порожденный тип имеет уже известные унаследованные свойства.
Вы просто изучаете дополнительные  поля  и  свойства,  которыми  он
дополняет своих родителей.

             Рис. 3.1 Иерархия объектов Turbo Vision.

TObject─┬─TCollection───TSortedCollection──TStringCollection
        ├─TResourceFile                       └─TResourceCollection
        ├─TStream─────┬─TEmsStream
        ├─TStringList └─TDosStream──────TBufStream
        ├─TStrListMaker
        └─TView───────┬─TCluster──────┬─TCheckBoxes
                      ├─TFrame        └─TRadioButtons
                      ├─TGroup────────┬─TDeskTop
                      ├─TBackGround   ├─TProgram────TApplication
                      ├─TButton       └─TWindow───┬─THistoryWindow
                      ├─TStaticText───┬─TLabel    └─TDialog
                      ├─THistory      └─TParamText
                      ├─TListViewer───┬─THistoryViewer
                      ├─TInputLine    └─TListBox
                      ├─TMenuView─────┬─TMenuBar
                      ├─TScrollBar    └─TMenuBox
                      ├─TScroller────────TTextDevice──TTerminal
                      └─TStatusLine


     Когда Вы  будете  разрабатывать  собственную программу в Turbo
Vision, Вы  обнаружите,  что  общее  сходство   стандартных   типов
объектов  и  их  многочисленные  взаимосвязи оказывают значительную
помощь. Шлифовка деталей будет выполняться позднее,  но  как  и  во
всех OOП проектах, первоначальное общее планирование новых объектов
- это ключ к успеху.
     Не существует совершенной иерархии для любой программы. Каждая
иерархия объектов  -  это   определенный   компромисс,   полученный
тщательным экспериментом   (и  определенная  интуиция  совместно  с
практикой). Ваш опыт поможет  Вам  при  разработке  иерархии  типов
объектов. Естественно  Вы  можете  создать свои собственные базовые
типы объектов для достижения специальных эффектов по  сравнению  со
стандартными объектами.  В  главе 13 детально описаны методы и поля
всех стандартных типов объектов, но до тех пор, пока Вы не получите
общее представление  о  всей  иерархии,  Вы будете путаться в массе
деталей. Эта глава дает общее представление об  иерархии  до  того,
как Вы   обратитесь  к  деталям.  Остаток  этой  части  дает  более
детальное объяснение компонент Turbo  Vision  и  их  использования.
Часть 3 приводит ссылочный материал в алфавитном порядке.


                        Типология объектов.

     Не все типы объектов  в  Turbo  Vision  одинаковы.  Вы  можете
разделить их  функции  на  3  различные  группы:  простые  объекты,
видимые объекты  и  невидимые  объекты.  Каждый  из  них  описан  в
отдельном разделе этой главы.
     Внутри каждой  группы  существуют  различные  виды   объектов.
Некоторые из  них  полезны - от них можно образовывать экземпляры и
использовать их,  а другие - абстрактные  объекты,  которые  служат
основой для   порождения   полезных   объектов.  До  того,  как  мы
рассмотрим объекты  в  их  иерархии,  полезно  понять   что   такое
абстрактные объекты.


                       Абстрактные объекты.

     Многие типы объектов существуют как "абстрактная"  основа,  из
которой могут  порождаться  более  специализированные полезные типы
объектов. Причина    создания    абстрактных     типов     частично
концептуальная, но  в  большой  степени  служит  практическим целям
сокращения усилий по кодированию.
     Для примера  возьмем типы TRadioButtons и TCheckBoxes.  Каждый
из них может быть прямо порожден от TView. Однако они разделяют ряд
общих свойств:   оба  представляют  набор  элементов  управления  с
аналогичной реакцией.  Набор зависимых кнопок во  многом  похож  на
набор независимых кнопок,  внутри которого только одна кнопка может
быть выбрана,  хотя   существует   несколько   других   технических
различий. Эта  общность  включена  в  абстрактный  класс  TCluster.
TRadioButtons и    TCheckBoxes    порождены    от    TCluster    со
специализированными методами, обеспечивающими их индивидуальность.
     Бессмысленно создавать экземпляр абстрактного  типа.  Например
экземпляр MyCluster  от  TCluster  не  будет иметь полезного метода
Draw. Он   наследует   TView.Darw   без   перекрытия    так,    что
MyCluster.Draw будет    просто    выводить   пустой   прямоугольник
умалчиваемого цвета.  Если  Вы  хотите  создать  кластер  элементов
управления со  свойствами,  отличными  от зависимых или независимых
кнопок, Вы  можете  породить  TMyCluster  от  TCluster  или   можно
породить Ваш специальный кластер от TRadioButtons или TCheckBoxеs в
зависимости от того,  какой из них ближе  к  Вашим  требованиям.  В
любом случае  Вы  будете  добавлять  новые  поля  и  добавлять  или
перекрывать методы с минимальными  затратами.  Если  Вы  планируете
включить целое  семейство  новых  кластеров,  может  быть  полезным
создать промежуточный абстрактный тип объекта.


                        Абстрактные методы.

     Сможете ли  Вы создать полезный экземпляр объекта,  зависит от
обстоятельств. Многие   стандартные   типы   Turbo   Vision   имеют
абстрактные методы,  которые  должны  быть определены в порожденных
типах. Стандартные  типы  могут  так  же  иметь   псевдоабстрактные
методы, предоставляющие  минимальные  действия  по  умолчанию,  что
может удовлетворять  Вашим  целям,  если   же   нет   -   требуется
порожденный тип.
     Общее правило заключается в том,  что по мере продвижения вниз
по иерархии   Turbo   Vision   стандартные  типы  становятся  более
специализированными и менее "абстрактными".  Их имена соответствуют
функциональности, заключенной  в их поля и методы.  Для большинства
программ будут очевидными  базовые  типы,  из  которых  Вы  сможете
создать "стандартный" интерфейс: панель экрана, полосу меню, строку
статуса, диалоговые окна и т.д.


              Порожденные типы и экземпляры объектов.

     Для любого  объектного  типа доступны 2 основных операции:  Вы
можете создать  экземпляр  этого  типа  или  Вы  можете  произвести
порожденный объектный  тип.  В последнем случае Вы имеете новый тип
объекта, к которому могут быть  применены  предыдущие  2  операции.
Давайте посмотрим эти операции.


                       Создание экземпляра.

     Создание экземпляра  объекта  обычно  связано  с   объявлением
переменной, статической или динамической:

               MyScrollBar: TScrollBar;
               SomeButton: PButton;

     MyScrollBar будет   инициализироваться   значениями  полей  по
умолчанию в  TScrollBar.Init.  Это  можно  посмотреть   в   разделе
TScrollBar.Init главы  13.  Поскольку TScrollBar порожден от TView,
TScrollBar.Init вызывает   TView.Init,   чтобы   установить   поля,
унаследованные от   TView.  Аналогично  TView.Init  наследуется  от
TObject, поэтому он вызывает констрактор TObject  для распределения
памяти. TObject не имеет предка.
     Объект MyScrollBar сейчас имеет значения полей  по  умолчанию,
которые Вы  можете изменить.  Он так же имеет все методы TScrollBar
плюс методы  (возможно  перекрытые)  от  TView  и  TObject.   Чтобы
использовать MyScrollBar,  Вам  нужно  знать что делают его методы,
особенно HandleEvent и Draw.  Если  требуемая  функциональность  не
определена в TScrollBar, Вам требуется породить новый тип.


                            Порождение.

     Вы можете легко породить объектный тип из существующего.

               PNewScrollBar = ^TNewScrollBar;
               TNewScrollBar = object(TScrollBar)
                 end;

     Вы еще  не  имеете  экземпляров  этого  объектного  типа.   До
объявления объектов  TNewScrollBar  Вам необходимо определить новые
методы или  перекрыть  некоторые  методы  TScrollBar  и,  возможно,
добавить некоторые  новые  поля;  иначе  не  существует  причин для
создания нового типа объекта.  Новые или измененные методы  и  поля
добавляют функциональность к TScrollBar. Ваш новый метод Init будет
определять значения по умолчанию для Ваших новых объектов.


                       Методы Turbo Vision.

     Методы Turbo  Vision  могут  характеризоваться   4   (возможно
перекрывающимися) способами, каждый из которых описан здесь.


                        Абстрактные методы.

     В базовом типе объекта абстрактный метод не  имеет определения
тела (или  тело  содержит  оператор Abstruct для перехвата неверных
вызовов). Абстрактные методы должны быть  определены  потомками  до
того, как могут быть использованы.  Абстрактные методы - это всегда
виртуальные методы. Пример такого метода TStream.Read.


                     Псевдоабстрактные методы.

     В базовом   типе   объекта   псевдоабстрактный   метод   имеет
минимальные действия. Он почти всегда будет перекрываться потомком,
но метод  содержит  действия  по умолчанию для всех объектов в цепи
наследования. Пример - TSortedCollection.Compare.


                        Виртуальные методы.

     Виртуальные методы  используют  директиву Virtual в объявлении
их прототипов.   Виртуальный   метод   может   быть   переопределен
(перекрыт) потомком,  но  переопределенный метод так же должен быть
виртуальным и его заголовок должен точно  соответствовать заголовку
оригинального метода.  Виртуальные методы не требуют перекрытия, но
обычно они рано или поздно перекрываются. Например TView.DataSize.


                        Статические методы.

     Статический метод не  может  быть  перекрыт.  Порожденный  тип
может определить метод с тем же именем, используя совершенно другие
аргументы и тип возврата, если необходимо, но статические методы не
поддерживают полиморфизм. Это наиболее критично, когда Вы вызываете
методы динамических объектов.  Например, если PGeneric - переменная
указателя типа PView, Вы можете назначить ему указатели любого типа
из его иерархии.  Однако когда Вы делаете ссылку  по  переменной  и
вызываете статический метод, вызванный метод всегда будет из TView,
поскольку этот тип указателя определен во время компиляции. Другими
словами,       PGeneric^.StaticMethod      всегда      эквивалентен
TView.StaticMethod,  даже если  Вы  назначаете  PGeneric  указатель
другого типа. Например TView.Init.


                        Поля Turbo Vision.

     Если Вы возьмете 3 объекта TView, TGroup и TWindow, то увидите
наследование их  полей  и  как растет функциональность при движении
вниз по иерархии (вспомним,  что дерево  объектов  растет  вниз  от
корня).

        Таблица 3.1. Наследование полей видимых элементов.

       ─────────────────────────────────────────────
       Поля TView    Поля TGroup   Поля TWindow
       ─────────────────────────────────────────────
       Owner          Owner           Owner
       Next           Next            Next
       Origin         Origin          Origin
       Size           Size            Size
       Cursor         Cursor          Cursor
       GrowMode       GrowMode        GrowMode
       DragMode       DragMode        DragMode
       HelpCtx        HelpCtx         HelpCtx
       State          State           State
       Options        Options         Options
       EventMask      EventMask       EventMask
                      Buffer          Buffer
                      Phase           Phase
                      Current         Current
                      Last            Last
                                      Flags
                                      Title
                                      Number
                                      ZoomRect
                                      Palette
                                      Frame
       ─────────────────────────────────────────────

     Заметим, что TGroup наследует все поля TView и добавляет поля,
которые необходимы для операций над группой, такие как указатели на
текущий и  последний  видимые элементы в группе.  TWindow наследует
все поля TGroup и добавляет поля, требуемые для операций над окном,
такие как заголовок и номер окна.
     Для того,  чтобы  полностью  понять  TWindow  Вам   необходимо
помнить, что окно - это группа (group) и видимый элемент (view).


                    Примитивные типы объектов.

     Turbo Vision предоставляет 3  простых  типа  объекта,  которые
используются другими объектами или используются как основа иерархии
более сложных объектов.  TPoint и TRect используются всеми видимыми
объектами в  иерархии  Turbo  Vision.  TОbjеct  -  основа иерархии.
Заметим,  что объекты этих типов не являются  прямо  отображаемыми.
TPoint - это просто объект позиции на экране (X,  Y).  TRect просто
содержит верхнюю левую и нижнюю  правую  границы  прямоугольника  и
несколько невизуализирующих сервисных методов.


                              TPoint.

     Этот объект представляет точку.  Его поля  X  и  Y  определяет
картезианские (X,  Y) координаты позиции экрана. Точка (0, 0) - это
верхняя левая точка экрана. X увеличивается горизонтально вправо, Y
увеличивается вертикально вниз.  TPoint не имеет методов, но другие
типы имеют методы,  которые  преобразуют  между  глобальными  (весь
экран) и   локальными  (относительно  смещения  видимого  элемента)
координатами.


                              TRect.

     Этот объект  представляет прямоугольник.  Его поля A и B - это
объекты типа TPoint,  определяющие верхнюю левую  и  нижнюю  правую
точки прямоугольника. TRect имеет методы: Assign, Copy, Move, Grou,
Intersect, Union,  Contains,  Equals и Empty. Объекты типа TRect не
являются видимыми  элементами и не могут рисовать себя.  Однако все
видимые элементы  являются  прямоугольными:  их  констракторы  Init
используют параметр  Bounds  типа  TRect  для  определения области,
которую они покрывают.


                             TObject.

     TObject -  это  абстрактный базовый тип без полей.  Это предок
всех объектов Turbo Vision,  за исключением TPoint и TRect. TObject
предоставляет 3   метода:  Init,  Free  и  Done.  Констрактор  Init
формирует основу для  всех  констракторов  Turbo  Vision,  выполняя
распределение памяти.  Free  освобождает это распределение.  Done -
это  абстрактный  дестрактор,  который  должен  быть   перекрыт   в
потомках.  Все  объекты,  которые  Вы  намереваетесь использовать с
потоками Turbo Vision должны быть производными от TObject.
     Потомки TObject  делятся  на  2  больших семейства:  видимые и
невидимые элементы.  Видимые элементы призводны от  TView,  который
дает им специальные свойства,  отсутствующие у невидимых элементов.
Видимые элементы  могут  рисовать  себя  и  обрабатывать   события,
посланные им.  Невидимые  объекты  предоставляют  набор  утилит для
обработки потоков и  коллекций  других  объектов,  включая  видимые
элементы, но они не могут быть визуализированы напрямую.


                         Видимые элементы.

     Отображаемые потомки TObject известны как видимые  элементы  и
они порождаются  от  TView - непосредственного потомка TObject.  Вы
должны отличать "видимый" от "отображаемый",  поскольку могут  быть
ситуации, когда   видимый  элемент  полностью  или  частично  скрыт
другими видимыми элементами.


                     Обзор видимых элементов.

     Видимый элемент   -  это  любой  объект,  который  может  быть
нарисован (отображен) в прямоугольной части  экрана.  Тип  видимого
объекта должен наследоваться от TView.  Сам TView - это абстрактный
объект, представляющий пустую область экрана. Имея TView в качестве
предка каждый  порожденный  видимый  элемент  имеет по крайней мере
прямоугольную часть экрана и минимальный виртуальный метод Draw.
     При программировании  в  Turbo  Vision  Вы будете использовать
более специализированные  потомки  от  TView,  но  функциональность
TView распространяется  на  весь  Turbo  Vision  и  Вам  необходимо
понимать его свойства.


                              Группы.

     Важность TView  явно проявляется из схемы иерархии, показанной
на рис.  3.1.  Все,  что Вы видите в программах  на  Turbo  Vision,
порождается от TView. Но некоторые из этих видимых элементов так же
важны по  другой  причине.  Они   позволяют   нескольким   объектам
действовать вместе.


                        Абстрактная группа.

     TGroup позволяет Вам обрабатывать динамически созданный список
связанных  интерактивных  подэлементов  через  назначенный  видимый
элемент, называемый владельцем группы. Каждый видимый элемент имеет
поле Owner типа PView,  которое указывает на владельца типа TGroup.
Указатель со значением nil означает,  что видимый элемент не  имеет
владельца.  Поле  Next  обеспечивает  связь  со  следующим  видимым
элементом в цепочке  видимых  элементов.  Поскольку  группа  -  это
видимый элемент,  могут  существовать видимые подэлементы,  которые
образуют группу своих видимых подэлементов и т.д.
     Состояние цепочки  постоянно  изменяется  в  процессе  ввода с
клавиатуры или отмечания мышкой.  Новые группы могут создаваться  и
видимые подэлементы  могут  добавляться (вставляться) или удаляться
из группы.  Во время их существования видимые элементы  могут  быть
скрыты действиями, производимыми над другими подэлементами так, что
группе требуется координировать их взаимодействие.


                          Панель экрана.

     TDeskTop -    это    нормальный   фоновый   видимый   элемент,
обеспечивающий привычную  панель   экрана   пользователям,   обычно
окруженную полосой  меню  и  строкой  статуса.  Обычно TApplication
владелец группы,   содержащей   объекты   TDeskTop,   TMenuBar    и
TStatusLine. Другие  видимые элементы,  такие как окна и диалоговые
окна, создаются,  отображаются и манипулируются на панели экрана  в
ответ на  действия  пользователя  (события  от мышки и клавиатуры).
Большая часть работы программы происходит внутри панели экрана.


                            Программы.

     TProgram предоставляет   набор  виртуальных  методов  для  его
потомка TApplication.


                       Прикладные программы.

     TApplication предоставляет   объект  заготовки  программы  для
Ваших программ на Turbo Vision.  Он  является  потомком  от  TGroup
(через TProgram).   Обычно   он   владеет   видимыми  подэлементами
TMenuBar, TDeskTop и TStatusLine.  TApplication  имеет  методы  для
создания и   вставки   этих   трех   подэлементов.  Ключевой  метод
TApplication -  это   TApplication.Run,   который   выполняет   код
программы.


                               Окна.

     Объекты TWindow,  с помощью ассоциированных объектов TFrame  -
это прямоугольники   с   рамкой,   которую  Вы  можете  перемещать,
изменять ее размеры и удалять,  используя методы, унаследованные от
TView. Поле  Frame  указывает  на объект TFrame этого окна.  Объект
ТWindow так же может изменять размер и закрываться,  используя свои
методы. TWindow  обрабатывает  клавиши  Tab  и Shift-Tab для выбора
следующего или предыдущего видимого подэлемента в  окне. Обработчик
событий TWindow  обрабатывает команды закрытия и изменения размера.
Пронумерованные окна могут быть выбраны горячими клавишами Alt-n.


                         Диалоговые окна.

     TDialog, порожденный  от  TWindow,  используется  для создания
диалоговых окон,  обрабатывающих  взаимодействие  с  пользователем.
Диалоговые окна  обычно  содержат  элементы  управления такие,  как
кнопки. Родительский метод  ExecView  используется  для  сохранения
предыдущего контекста,  вставки объекта TDialog в группу и перевода
диалогового  окна  в  модальный режим.  Объект TDialog обрабатывает
события,  генерируемые пользователем,  такие как нажатие  кнопок  и
клавиш.  Клавиша Esc интерпретируется как выход (cmCancel). Клавиша
Enter интерпретируется как событие cmDefault (обычно  означает, что
кнопка  по  умолчанию  выбрана).  Наконец  ExecView восстанавливает
предварительно сохраненный контекст.


                  Терминальные видимые элементы.

     Терминальные видимые  элементы  это  все   видимые   элементы,
которые не являются группами. Они не могут владеть другими видимыми
элементами.  Они,  следовательно,  являются конечными точками любых
цепочек видимых элементов.


                              Рамки.

     TFrame обеспечивает отображаемую рамку для объектов TWindow, а
так же  кнопки  для  перемещения  и  закрытия окна.  Объекты TFrame
никогда не используются отдельно,  а все время совместно с объектом
TWindow.


                              Кнопки.

     Объект TButton - это  помеченный  прямоугольник,  используемый
для генерации  события с заданной командой при ее "нажатии". Обычно
они размещаются внутри (принадлежат) диалоговых  окон, предоставляя
такие выборы  как  "OK" или "Cancel".  Диалоговое окно - это обычно
модальный видимый элемент,  который при появлении  перехватывает  и
обрабатывает все события, включая события от его кнопок. Обработчик
событий предоставляет несколько способов  нажатия  кнопки:  выбором
прямоугольника кнопки   мышкой,   нажатием  короткого  символа  или
выбором кнопки по умолчанию клавишей Enter.


                             Кластеры.

     TCluster -  это  абстрактный тип,  используемый для реализации
зависимых и независимых кнопок.  Кластер  -  это  группа  элементов
управления, которые    реагируют   одинаково.   Кластер   элементов
управления часто ассоциируется с  объектами  TLabel,  позволяя  Вам
выбирать элемент  управления с помощью выбора метки. Дополнительные
поля: Value,  дающие определенное  пользователем  значение  и  Sel,
индексирующее выбранный  элемент управления этого кластера.  Так же
представлены методы для рисования  текстовых  кнопок  и  отмечающих
символов. Для   выбора   элементов   управления  в  кластере  могут
использоваться клавиши курсора или мышки.
     Зависимые кнопки  - это специальные кластеры,  в которых может
быть выбран только  один  элемент  управления.  Каждый  последующий
выбор отменяет текущий элемент.  Независимые кнопки - это кластеры,
в которых  может   быть   отмечено   любое   количество   элементов
управления.


                               Меню.

     TMenuView и 2 его потомка TMenuBar  и  TMenuBox  предоставляют
базовые объекты  для создания выпадающих меню и подменю,  вложенных
на любой уровень.  Вы задаете  текстовые  строки  для  выбора  меню
(возможно подсвечивать   буквы   для  короткого  набора)  вместе  с
командами, связанными  с   каждым   выбором.   Методы   HandleEvent
реализуют механизм   выбора  меню  с  помощью  мышки  и  клавиатуры
(включая короткий набор и горячие клавиши).
     Выбор меню  отображается  с помощью объекта TMenuBar,  который
обычно принадлежит объекту TApplication. Выборы меню отображаются в
объектах типа TMenuBox.
     В большинстве программ Вы не вызываете напрямую  объекты меню.
Перекрывая TApplication.InitMenuBar     соответствующим     набором
вложенных вызовов New,  NewSubMenu, NewItem и NewLine, Turbo Vision
строит, отображает и взаимодействует с требуемыми меню.


                             История.

     Абстрактный тип THistory реализует механизм выбора  из списка.
2 дополнительных поля Link и HistoryId дают каждый объект THistory,
ассоциированный с TInputLine,  и  идентификатор  списка  предыдущих
значений в   строке   ввода.   THistory   работает  в  сочетании  с
THistoryWindow и THistoryViewer.


                           Строки ввода.

     TInputLine -  это специализированный видимый элемент,  который
предоставляет строковый редактор строки ввода.  Он обрабатывает все
обычные клавиши  управления  курсором,  удаление  и вставку.  Чтобы
отметить блок текста, может использоваться мышка.


                         Просмотр списков.

     Тип объекта  TListViewer  -  это  абстрактный базовый тип,  от
которого наследуется просмотр списков различных  родов,  таких  как
TListBox. Поля   и  методы  TListViewer  позволяют  Вам  отображать
связанные списки  строк  с  управлением  одной   или   двух   полос
скроллинга. Обработчик событий  позволяет  делать  выбор  элементов
списка  мышкой  или  от клавиатуры.  Метод Draw позволяет изменение
размера и скроллинг.  TListViewer имеет абстрактный метод  GetText,
который  Вы  должны  обеспечить  механизмом  создания и манипуляции
отображаемых элементов.
     TListBox, наследуемый от TListViewer, реализует наиболее часто
используемые окна  списков,  таких  как,  например,  имена  файлов.
Объекты TListBox отображают списки таких элементов в одну или более
колонок с    дополнительной    вертикальной   полосой   скроллинга.
Горизонтальные полосы скроллинга в TListViewer  не  поддерживаются.
Наследование методов  TListViewer  позволяет  Вам  выбрать  элемент
мышкой или через клавиатуру.  TListBox  имеет  дополнительное  поле
List, указывающее  на объект TCollection.  Он предоставляет объекты
для распечатки и выбора.  Содержимое коллекции формируется Вами так
же как и действия, которые выполняются при выборе элемента.


                        Объекты скроллинга.

     Объект TScroller это видимый объект  для  скроллинга,  который
действует как  ворота  в  другой больший "фоновый" видимый элемент.
Скроллинг возникает в ответ на ввод с  клавиатуры  или  действия  в
связанных объектах TScrollBar.  Скроллеры имеют два поля, HScrollId
и VScrollId,   идентифицирующих   управление    горизонтальной    и
вертикальной полосами скроллинга. Поле Delta в TScroller определяет
смещение скроллинга по X и Y вместе с полями  в  связанных  полосах
скроллинга.
     Объекты TScrollBar     обеспечивают      вертикальное      или
горизонтальное управление.   Ключевые   поля:   Value   -   позиция
индикатора полосы  скроллинга,  PgStep   -   смещение   скроллинга,
требуемое в ответ на нажатие мышки или клавиш PgUp, PgDn; ArrStep -
смещение скроллинга,  требуемое в ответ на нажатие мышки или клавиш
курсора.
     Скроллер и его полосы скроллинга  обычно  принадлежат  объекту
TWindow, что  приводит  к  сложному  набору обрабатываемых событий.
Например, изменение размера окна должно приводить к соответствующей
перерисовке скроллером.  Значения  полосы  скроллинга должны так же
изменяться и перерисовываться.


                       Текстовые устройства.

     TTextDevice -  это  скользящий  TTY  тип  просмотра  текста  -
драйвера устройства. Кроме полей методов, наследуемых от TScroller,
TTеxtDevice определяет виртуальные методы для чтения и записи строк
в и из устройства.  TTextDevice используется как  базовый  тип  для
порождения реальных драйверов. TTextDevice использует констрактор и
дестрактор TScroller.
     TTerminal реализует   терминал   с  буферизованным  чтением  и
записью строк. Размер буфера определяется при инициализиции.


                        Статический текст.

     Объекты TStaticText    -   это   простые   видимые   элементы,
используемые для отображения фиксированных  строк,  предоставляемых
полем Text.  Они игнорируют любые события, посланные им. Тип TLabel
добавляет видимому элементу свойства  хранения  текста,  известного
как  метка,  который  может  быть  выбран  с помощью мышки,  клавиш
курсора или короткого нажатия Alt-клавиша. Дополнительное поле Link
связывает метку  с  другим  видимым  элементом,  обычно управляемым
видимым элементом,  который обрабатывает все события  метки.  Выбор
метки выбирает  связанный  элемент  управления,  а выбор связанного
элемента управления подсвечивает метку.


                          Строки статуса.

     Объект TStatusLine  предназначен  для  отображения  статуса  и
подсказок обычно в  нижней  строке  экрана.  Строка  статуса  имеет
высоту 1 символ и длину до ширины экрана.  Этот объект обеспечивает
динамическое отображение,  реагируя на события программы.  Элементы
строки статуса   можно   выбрать   мышкой   или  горячей  клавишей.
Большинство программ начинают работу становясь владельцами объектов
TMenuBar, TDeskTop  и TStatusLine.  Дополнительные поля TStatusLine
обеспечивают указатель Items и указатель Defs.
     Поле Items  указывает  на  текущий  связанный  список  записей
TStatusItem. Он содержит  отображаемые  строки,  связь  с  горячими
клавишами и  ассоциированное слово Command.  Поле Defs указывает на
связанный список записей PStatusDef,  используемый для  определения
текущей контекстной        подсказки.       TStatusLine       может
инициализироваться, используя TApplication.InitStatusLine.


                        Невидимые элементы.

     Семейство невидимых   элементов,   порожденное   от   TObject,
содержит потоки, файлы ресурсов, коллекции и списки строк.


                              Потоки.

     Поток -  это обобщенный объект для обработки ввода и вывода. В
традиционных устройствах  и  файлах  В/В  для  обработки  выбора  и
преобразования различных  типов  данных  должны  быть предоставлены
отдельные наборы функций.  Используя потоки Turbo Vision, Вы можете
создавать полиморфные  методы  В/В такие как Read и Write,  которые
знают как обрабатывать содержимое их потоков.
     TStream -   это  базовый  абстрактный  объект,  обеспечивающий
полиморфный В/В на и из устройства  памяти.  TStream  предоставляет
поле Status, указывающее на режим доступа (только на чтение, только
на запись,  чтение/запись), а поле ErrorInfo возвращает ошибки В/В.
Предоставлено 7 виртуальных методов:  Flush, GetPos, GetSize, Read,
Seek, Truncate и Write.  Они должны быть перекрыты  для  порождения
специализированных типов  потоков.  Вы  увидите,  что  Turbo Vision
использует эту стратегию для порождения  TDosStream,  TEmsStream  и
TBufStream. Существуют так же методы CopyFrom, Error, Get, ReadStr,
Reset, WriteStr.
     Типы объектов    должны   быть   зарегистрированы,   используя
RegisterType до  того,  как  их  можно  использовать  с   потоками.
Стандартные типы  объектов  Turbo  Vision уже зарегистрированы (см.
процедуру RegisterType в главе 14).


                            Потоки DOS.

     TDosStream -   это   специализированный   поток,   реализующий
небуферизованный поток   файла   DOS.   Поле  Handle  соответствует
обычному обработчику файла DOS.  Констрактор Init создает поток DOS
с  заданным  именем файла и режимом доступа.  TDosStream определяет
все абстрактные  методы  TStream,  за  исключением  Flush,  который
требуется только для буферизованных потоков.


                      Буферизованные потоки.

     TBufStream реализует  буферизованную  версию TDosStream.  Поля
Buffer и BufSize указывают положение и размер буфера. Поля BufPtr и
BufEnd определяют   текущую  и  последнюю  позицию  внутри  буфера.
Абстрактный метод TStream.Flush определен для  выталкивания буфера.
Выталкивание означает  запись  и очистку всех внутренних буферов до
закрытия потока.


                            Потоки EMS.

     Наиболее специализированный поток TEmsStream реализует поток в
EMS памяти.  Новые поля содержат  обработчик  EMS,  число  страниц,
размер потока и текущую позицию внутри потока.


                             Ресурсы.

     Файл ресурсов - это специальный вид потока,  в котором объекты
(элементы) могут индексироваться с помощью строковых ключей. Вместо
порождения  файла ресурсов от TStream,  TResourceFile содержит поле
Stream,  связывающее поток  с  файлом  ресурсов.  Элементы  ресурса
доступны  через вызов Get(Key),  где Key - строковый индекс.  Метод
Put сохраняет элемент  с  заданным  ключем;  метод  KeyAt  получает
индекс  данного  элемента;  Flush записывает все изменения в поток;
Delete удаляет элемент с данным ключем  и  Count  возвращает  число
элементов в файле.


                            Коллекции.

     TCollection реализует  набор  элементов,  включая произвольные
объекты различных типов.  В отличие от массивов, множеств и списков
не -  ООП  языков,  коллекция  Turbo  Vision  допускает  переменный
размер. Collection   -   это    абстрактная    база    для    более
специализированных коллекций  таких как TSortedCollection.  Главное
поле - Items - указатель на  массив  элементов.  Кроме  индексации,
вставки и    удаления,    TCollection    предоставляет    несколько
итерационных программ.  Коллекция  может  быть  просканирована   от
первого или последнего элемента до нахождения условия,  заданного в
функции проверки,  определенной  пользователем.  С  помощью  метода
ForEach Вы  можете  выполнить действие,  определенное пользователем
для каждого элемента коллекции.


                    Отсортированные коллекции.

     TSortedCollection реализует   коллекцию,   отсортированную  по
ключу. Сортировка определена через  виртуальный  абстрактный  метод
Compare. Следовательно Ваш порожденный тип может задавать требуемую
упорядоченность для коллекции объектов любого  типа.  Метод  Insert
добавляет элементы, поддерживая это упорядочение и ключи могут быть
быстро найдены методом двоичного поиска Search.


                         Коллекция строк.

     TStringCollection -  это  простое расширение TSortedCollection
для обработки отсортированной коллекции строк Turbo  Pascal.  Метод
FreeItem удаляет  данную  строку из коллекции.  Для записи и чтения
коллекции строк из потока предоставлены виртуальные  методы PutItem
и GetItem.


                        Коллекции ресурсов.

     TResourceCollection реализует    коллекцию     отсортированных
индексов ресурсов,   используя  файлы  ресурсов.  Методы  FreeItem,
GetItem, KeyOf,  PutItem типа TStringCollection  перекрываются  для
обработки ресурсов.


                           Списки строк.

     TStringList реализует специальный вид  строкового  ресурса,  в
котором к строкам можно обращаться через числовой индекс, используя
метод Get.  Поле Count содержит число строк в объекте.  TStringList
упрощает многоязыковые   тектовые  программы.  Списки  строк  можно
прочитать из потока,  используя констрактор Load. Чтобы создать или
добавить в список строк, используйте TStrListMaker.
     TStringList предоставляет доступ только к существующему списку
строк с числовой индексацией. TStrListMaker предоставляет метод Put
для добавления строки в  список  строк,  а  метод  Store  сохраняет
список строк в потоке.
