                             ГЛАВА 4.

                         ВИДИМЫЕ ЭЛЕМЕНТЫ.

     Сейчас Вы должны иметь внешнее представление о работе программ
на Turbo  Vision.  Что  присходит  внутри?  Ответу  на  этот вопрос
посвящены 2 следующие главы.


                        Управление экраном.

     Одно из  ограничений  при  использовании Turbo Vision касается
прямого вывода на экран.  Вместо использования Write и Writeln  для
выдачи  информации  пользователю,  Вы  передаете информацию в Turbo
Vision, который гарантирует, что информация появится в нужное время
и в нужном месте.
     Основной блок построения программ в  Turbo  Vision  -  видимый
элемент. Видимый   элемент  -  это  объект  Turbo  Pascal,  который
управляет прямоугольной областью экрана.  Например,  полоса меню на
вершине экрана  -  это видимый элемент.  Любое действие программы в
этой области экрана (например отметка мышкой в полосе  меню)  будет
обрабатываться видимым элементом, который контролирует эту область.
     Меню - это видимые элементы так же как и окна, строка статуса,
кнопки, полосы  скроллинга,  диалоговые  окна и обычно даже простая
строка текста.  В  общем  случае  все,  что  Вы  видите  на  экране
программы Turbo  Vision  должно  быть  видимым элементом и наиболее
важное свойство видимого элемента то, что он знает как представлять
себя на  экране.  Так,  например,  когда  Вы хотите сделать систему
меню, Вы просто говорите Turbo Vision, что Вы хотите создать полосу
меню, содержащую   определенные  меню,  а  Turbo  Vision  управляет
остальным.
     Наиболее зримым  примером  видимого  элемента,  о  котором Вы,
вероятно,  не будете думать как о видимом элементе,  является  сама
программа.  Она  управляет всем экраном,  но Вы не замечаете этого,
поскольку  программа  устанавливает  другие  видимые  элементы  для
управления их взаимодействий с пользователем.  Как Вы увидите,  то,
что представляется пользователю как объект (такой как  окно)  часто
является группой связанных видимых элементов.


                     Простые видимые элементы.

     Как Вы видите из схемы  иерархии  на  рис.  4.6,  все  видимые
элементы Turbo  Vision  имеют TObject в качестве предка.  TObject -
это несколько более,  чем общий предок для всех объектов. Сам Turbo
Vision в действительности начинается от TView.
     TView появляется на экране просто как пустой прямоугольник. Не
имеет смысла  создавать  экземпляр TView,  если только Вы не хотите
создать пустой прямоугольник на  экране  для  прототипирования.  Но
хотя TView визуально прост,  он содержит все основные поля и методы
управления экраном Turbo Vision.
     Любой объект,  порожденный  от  TView,  должен  обладать двумя
возможностями:
     Во-первых, он  рисует  себя  в любой момент.  TView определяет
виртуальный метод Draw и каждый объект,  порожденный от TView,  так
же должен  иметь  метод  Draw.  Это важно,  поскольку часто видимый
элемент будет перекрываться другим видимым элементом и  когда  этот
другой элемент  удаляется или перемещается,  видимый элемент должен
иметь возможность показать ту часть, которая была скрыта.
     Во-вторых, он   должен   обрабатывать   все  события,  которые
приходят к нему.  Как замечено в главе 1, программы на Turbo Vision
управляются от  событий.  Это означает,  что Turbo Vision управляет
вводом от пользователя и передает  его  в  соответствующие  объекты
программы.  Видимые элементы должны знать что делать, когда события
воздействуют на них. Обработке событий посвящена глава 5.


                   Установка видимого элемента.

     До обсуждения, что делает видимый элемент, давайте рассмотрим,
как видимые элементы представляются на экране.
     Положение видимого   элемента   определяется   двумя  точками:
верхним левым углом (называемым началом)  и  нижним  правым  углом.
Каждая  из  этих  точек  представлена  в  объекте полем типа TPoint
(TPoint описана в  следующем  разделе).  Поле  Origin  типа  TPoint
указывает начало видимого элемента, а поле Size представляет нижний
правый угол.
     Заметим, что  Origin - это точка в системе координат владельца
видимого элемента:  если Вы открываете окно на панели  экрана,  его
поле Origin  указывает  координаты  X  и Y окна относительно начала
панели экрана. С другой стороны, поле Size - это точка относительно
начала данного  объекта.  Оно говорит Вам как далеко отстоит нижний
правый угол от начальной точки,  но если Вы не  знаете  где  начало
видимого элемента  расположено внутри другого видимого элемента, Вы
не сможете определить где реально находится этот угол.


                         Получение TPoint.

     Тип TPoint  крайне  прост.  Он  содержит только 2 поля X и Y -
коодинаты точки.  Он не  имеет  методов.  Turbo  Vision  использует
объект TPoint, чтобы позволить видимому элементу указать координаты
одним полем.


                         Получение TRect.

     TPoint редко  напрямую используется в Turbo Vision.  Поскольку
каждый видимый  элемент  имеет  и  начало  и  размер,  обычно   они
обрабатываются в объекте TRect совместно.  TRect имеет 2 поля А и В
каждое типа TPoint.  Когда заданы границы  видимого  элемента,  эти
границы передаются в констрактор TRect.
     TRect и TView предоставляют полезные  методы  для  манипуляции
размером видимого   элемента.  Например,  если  Вы  хотите  создать
видимый элемент,  который заполняется только внутри окна, Вы можете
получить размер окна,  сократить его и назначить новому внутреннему
видимому элементу.

               procedure ThisWindow.MakeInside;
               var
                 R: TRect;
                 Inside: PInsideView;
               begin
                 GetExtent(R);  { установить R в размер ThisWindow}
                 RR.Grow(-1, -1);  { сократить прямоугольник на 1 }
                 Inside :=  New(PInsideView,  Init(R));  {  создать
                                        внутренний видимый элемент}
                 Insert(Inside); { вставить новый видимый элемент в
                                   окно }
               end;

     GetExtent -  это  метод TView,  который устанавливает аргумент
TRect  в  координаты  прямоугольника,  покрывающего  весь   видимый
элемент. Grow   -   это  метод  TRect,  который  увеличивает  (а  с
отрицательными параметрами уменьшает) горизонтальный и вертикальный
размеры прямоугольника.


                     Координаты Turbo Vision.

     Метод Turbo Vision, назначающий коодинаты, может отличаться от
используемого Вами. Отличие заключается в том, что если большинство
координатных систем устанавливает  размер  в  символах  на  экране,
координатная система   Turbo   Vision  указывает  расстояние  между
символами.
     Например, если R - объект типа TRect,  R.Assign(0,  0,  0,  0)
назначает прямоугольник без  размера  -  только  точка.  Наименьший
прямоугольник, который может содержать что-либо, создается R.Assign
(0, 0, 1, 1).
     Рис. 4.1 показывает TRect, созданный R.Assign(2, 2, 5, 4).

           Рис. 4.1. Координатная система Turbo Vision.


               0   1   2   3   4   5   6   7
              0┌───┬───┬───┬───┬───┬───┬───┐
               │   │   │   │   │   │   │   │
              1├───┼───┼───┼───┼───┼───┼───┤
               │   │   │   │   │   │   │   │
              2├───┼───┼───┼───┼───┼───┼───┤
               │   │   │ R │ R │ R │   │   │
              3├───┼───┼───┼───┼───┼───┼───┤
               │   │   │ R │ R │ R │   │   │
              4├───┼───┼───┼───┼───┼───┼───┤
               │   │   │   │   │   │   │   │
              5└───┴───┴───┴───┴───┴───┴───┘

     Хотя эта   координатная   система  несколько  непривычна,  она
позволяет вычислять размер прямоугольника намного проще.


                   Появление видимых элементов.

     Появление видимого  элемента  определяется  его  методом Draw.
Каждый новый тип  видимого  элемента  требует  собственного  метода
Draw.
     Существует правила,  которые  применяются  ко   всем   видимым
элементам. Видимый элемент должен:
     - заполнять всю область, за которую он ответственен.
     - рисовать себя в любое время.

     Эти свойства очень важны и обсуждаются далее.


                        Территориальность.

     Существуют причины того,  что каждый видимый элемент  отвечает
за свою  территорию.  Видимому  элементу  назначается прямоугольная
область на экране.  Если он не заполнит всю эту область, содержимое
незаполненной области неопределено:  там может быть видно все,  что
угодно и Вы  не  сможете  управлять  этим.  Программа  TVDEMO05.PAS
демонстрирует, что случается, если видимый элемент оставляет что-то
незаполненным.


                     Рисование по требованию.

     Кроме того,    видимый    элемент   должен   всегда   обладать
возможностью представить себя на экране.  Причина этого заключается
в том,  что  другие  видимые  элементы  могут закрывать часть этого
элемента, а  затем  удаляются  или  сам   видимый   элемент   может
переместиться. В  любом  случае видимый элемент должен всегда уметь
отобразить свое текущее состояние.
     Заметим, что это может означать, что видимый элемент не должен
делать вообще ничего: он может быть полностью закрыт или может даже
не присутствовать на экране или окно, содержащее этот элемент может
быть сжато  в  точку  так,  что  видимый  элемент  невидим  вообще.
Большинство из этих ситуации обрабатывается автоматически, но важно
запомнить, что Ваш видимый элемент всегда должен знать как рисовать
себя.
     Это значительно  отличается  от  других  оконных   схем,   где
например запись  в  окно  постоянна:  то,  что  Вы  написали в него
остается даже если окно удаляется.  В Turbo Vision  Вы  не  делаете
предположений, что   открывающийся   видимый   элемент   корректен,
поскольку он мог быть изменен в то время, когда был закрыт.


                       Установка поведения.

     Поведение видимого   элемента   почти  полностью  определяется
методом  HandleEvent.  В  HandleEvent  передается  запись  события,
которая должна  быть  обработана  одним из двух способов.  Он может
либо выполнить некоторое действие  в  ответ  на  событие,  а  затем
пометить событие   как  обработанное  или  может  передать  событие
следующему видимому элементу (если он есть).
     Главное в  поведении  -  как  видимый  элемент  откликается на
определенное событие.  Например,  если   окно   получает   событие,
содержащее команду cmClose,  ожидается,  что окно будет закрыто. Вы
можете определить  другую  реакцию   на   эту   команду,   но   это
нежелательно. (Обработка событий обсуждается в главе 5).


                     Сложные видимые элементы.

     Вы уже знаете о наиболее важном элементе, порождаемом от TView
- ТGroup.   TGroup  и  его  потомки  называются  группами.  Видимые
элементы не  наследуемые  от   TGroup,   называются   терминальными
видимыми элементами.
     Группа - это просто пустое окно,  которое содержит и управляет
другими видимыми  элементами.  Технически  - это видимый элемент и,
следовательно, отвечает за все,  что  должен  уметь  любой  видимый
элемент: управлять  прямоугольной областью экрана,  визуализировать
себя в любое время и обрабатывать события в своей  области  экрана.
Отличие в  том,  как  он реализует эти функции:  большинство из них
обрабатывается видимыми подэлементами.


                   Группы и видимые подэлементы.

     Подэлемент - это видимый элемент,  который принадлежит другому
видимому элементу,  т.е.  видимый элемент (группа)  может  передать
часть своей области экрана для обработки другому видимому элементу,
называемому видимым  подэлементом,  который  будет  управлять  этой
областью.
     Наилучший пример - TApplication.  TApplication -  это  видимый
элемент, который  управляет  областью  экрана  - в действительности
всем экраном.  TApplication - это так же группа,  которая владеет 3
элементами: полосой   меню,   панелью  экрана  и  строкой  статуса.
Программа передает область экрана  каждому  из  этих  подэлементов.
Полоса меню  получает  верхнюю  строку,  строка  статуса  -  нижнюю
строку, а  панель  экрана  -  все  строки  между  ними.  Рис.   4.2
показывает типичный экран TApplication.

                   Рис. 4.2. Экран TApplication.

          ┌──────────────────────────────────────┐
          │  Строка меню                         │
          ├──────────────────────────────────────┤
          │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
          │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
          │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
          │░░░DeskTop░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
          │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
          │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
          ├──────────────────────────────────────┤
          │  Строка статуса                      │
          └──────────────────────────────────────┘

     Заметим, что сама программа не имеет представления экрана - Вы
не видите   программы.   Ее  появление  полностью  определяется  ее
видимыми элементами.


                         Получение группы.

     Как подэлементы   присоединяются   к   группе?   Этот  процесс
называется вставкой.  Видимые   подэлементы   создаются   и   затем
вставляются    в   группу.   В   предыдущем   примере   констрактор
TApplication.Init создает 3 объекта и вставляет их в программу:

               InitDeskTop;
               InitStatusLine;
               InitMenuBar;
               if DeskTop <> nil then Insert(DeskTop);
               if StatusLine <> nil  then Insert(StatusLine);
               if MenuBar <> nil then Insert(MenuBar);

     В данном  случае  TApplication делит свою область на 3 части и
передает каждую  из  них   подэлементам.   Это   упрощает   видимое
представление, поскольку видимые подэлементы не перекрываются.
     Однако одним из наибольших достижений оконной  среды  является
возможность иметь  множество перекрывающихся окон на панели экрана.
Группы (включая   панель    экрана)    знают    как    обрабатывать
перекрывающиеся подэлементы.
     Группа хранит  порядок  вставки  подэлементов.  Этот   порядок
соответствует порядку   Z.   Как   Вы   увидите,   Z-упорядочивание
определяет порядок,  в котором подэлементы рисуются  и  порядок,  в
котором события передаются в них.


                Другой взгляд на Z-упорядочивание.

     Термин Z-упорядочивание ссылается  к  факту,  что  подэлементы
имеют 3-мерные  взаимосвязи.  Как  Вы  уже  видели,  каждый видимый
элемент имеет позицию и размер,  определяемые полями Origin и Size.
Но видимые  элементы  и подэлементы могут перекрываться и для того,
чтобы Turbo Vision  знал  какой  видимый  элемент  находится  перед
другими видимыми элементами, мы добавляем третью координату Z.
     Так же Z-упорядочивание относится  к  порядку,  в  котором  Вы
встречаете видимые  элементы,  когда  Вы  ищете  ближайший  к  Вам.
Последний вставленный видимый элемент - это ближайший к Вам.
     Удобно рассматривать  видимые элементы как стеклянные панели в
трехмерном пространстве, как показано на рис.4.3.

           Рис. 4.3. Трехмерный образ видимых элементов.


            ┌──────────────────────┐
            │                      │
            │   ┌──────────────────┼───┐
            │   │                  │   │ 
            │   │                  │   ╞═▒═[■]═╗
            │   │                  │   │ ▒     ║
TWindow ───Ў└───┼──────────────────┘   │ ▒     ║
                │  This is some text   │ ▒     ║
  TScroller ───Ў└───╥──────────────────┘ ■     ║
                    ║                    ▒     ║
   TScrollbar ───Ў  ▒■▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒       ║
         TFrame ───Ў╚══════════════════════════┘


     Само окно  - это просто стеклянная панель,  закрывающая группу
видимых элементов.  Поскольку все,  что Вы видите  -  это  проекция
видимых элементов  на экран,  Вы не видите,  какие видимые элементы
находятся ближе, чем другие, если они не перекрываются.
     По умолчанию  окно имеет рамку,  которая вставляется до любого
другого подэлемента. Следовательно это фоновый видимый элемент. При
создании интерьера   скроллинга  2  полосы  скроллинга  перекрывают
рамку. Для Вас при взгляде сверху они смотрятся как часть рамки, но
при взгляде   со   стороны   Вы   можете   увидеть,   что   они   в
действительности лежат выше рамки.
     Наконец, вставляется  скроллер,  прикрывая  всю область внутри
рамки. Текст пишется в скроллере, а не в окне, но Вы можете увидеть
его, когда смотрите в окно.
     При большем масштабе  Вы  можете  увидеть  панель  экрана  как
большую стеклянную панель,  закрывающую более мелкие элементы,  как
показано на рис. 4.4.

             Рис. 4.4. Трехмерный образ панели экрана.


             ┌──────────────────────┐
             │                      │
             │   ┌──────────────────┼───────┐
             │   │                  │       │
             │   │  ┌─────┐         │       │
             │   │  │▒▒▒▒▒│         │       │
TDesktop ───Ў└───┼──┼─────┼─────────┘       │
                 │  │▒▒▒▒▒│                 │
 TWindow ───Ў    │  └─────┘                 │
                 │                          │
 TBackground ───Ў└──────────────────────────┘


     И опять,  группа (на этот раз панель экрана) - это  панель  из
стекла. Ее  первый  подэлемент  -  это объект TBackGround,  который
находится на самом низу. Так же видно окно на панели экрана.


                        Групповые портреты.

     Группа -  это  исключение  из  правила,  что  видимые элементы
должны знать как рисовать себя,  поскольку группа не  рисует  себя.
Скорее TGroup просит свои подэлементы, чтобы они нарисовали себя.
     Подэлементы вызываются для прорисовки в Z  порядке, означающем
что первый подэлемент, вставленный в группу, рисуется первым. Таким
образом, если подэлементы перекрываются,  то вставленный  последним
рисуется над другими.
     Подэлементы, принадлежащие группе,  должны совместно закрывать
всю область,  управляемую группой.  Например, диалоговое окно - это
группа и его подэлементы - рамка,  интерьер,  элементы управления и
статический текст  должны  полностью  накрывать область диалогового
окна. Иначе  в  диалоговом  окне   будут   появляться   "дырки"   с
непредсказуемыми (и неприятными) результатами.
     Когда видимые  подэлементы  группы  рисуют  себя,   их   вывод
автоматически отсекается по границам группы.  Поскольку подэлементы
отсекаются, когда Вы инициализируете видимый  элемент  и  передаете
его в  группу,  необходимо,  чтобы видимый элемент хотя бы частично
размещался внутри границ  группы.  (Вы  можете  отодвинуть  окно  с
панели экрана  только  если  один угол остается видимым.) Только та
часть подэлемента,  которая находится внутри границ ее группы будет
визуализироваться.
      Как панель  экрана  получает  видимый  фон?   Во   время   ее
инициализации панель  экрана создает и владеет видимым подэлементом
TBackGround, чье  назначение  заливать  весь  экран  цветом   фона.
Поскольку фон  -  первый  вставленный  подэлемент,  он  закрывается
другими видимыми подэлементами, рисуемыми над ним.


              Взаимосвязи между видимыми элементами.

     Видимые элементы   связаны   двумя   способами:  они  элементы
иерархии объектов  Turbo  Vision  и  они  элементы  дерева  видимых
элементов. Когда  Вы  начинаете  работать  в  Turbo  Vision,  важно
помнить это различие.
     Например, рассмотрим простое диалоговое окно на рис.  4.5. Оно
имеет рамку,  одну строку текста и одну кнопку,  которая  закрывает
диалоговое окно.  В  терминах  Turbo  Vision  - это видимый элемент
TDialog, который владеет TFrame, TStaticText и TButton.

                Рис. 4.5. Простое диалоговое окно.

             ╔═[■]═════ Sample dialog box  ═══════════╗
             ║                                        ║
             ║   This is a dialog box text message    ║
             ║                                        ║
             ║                      OK   ▄            ║
             ║                    ▀▀▀▀▀▀▀▀            ║
             ╚════════════════════════════════════════╝


                        Иерархия объектов.

     Один из  способов взаимосвязи видимых элементов - это родители
и дети в иерархии объектов.  Заметьте,  что TButton в иерархической
диаграмме на рис. 4.6 порожден от типа TView и имеет дополнительные
поля и методы,  которые делают его кнопкой. TDialog так же порожден
от TView  (через  TGroup и TWindow) и имеет много общего с TButton.
Это двоюродные братья в иерархии Turbo Vision.

             Рис. 4.6. Иерархия объектов Turbo Vision.


TObject─┬─TCollection───TSortedCollection──TStringCollection
        ├─TResourceFile                       └─TResourceCollection
        ├─TStream─────┬─TEmsStream
        ├─TStringList └─TDosStream──────TBufStream
        ├─TStrListMaker
        └─TView───────┬─TCluster──────┬─TCheckBoxes
          -----       ├─TFrame        └─TRadioButtons
                      ├─TGroup────────┬─TDeskTop
                      ├─TBackGround   ├─TProgram────TApplication
                      ├─TButton       └─TWindow───┬─THistoryWindow
                      │ -------                   └─TDialog
                      ├─TStaticText───┬─TLabel      -------
                      ├─THistory      └─TParamText
                      ├─TListViewer───┬─THistoryViewer
                      ├─TInputLine    └─TListBox
                      ├─TMenuView─────┬─TMenuBar
                      ├─TScrollBar    └─TMenuBox
                      ├─TScroller────────TTextDevice──TTerminal
                      └─TStatusLine



                          Принадлежность.

     Другой способ  взаимосвязи  видимых элементов - дерево видимых
элементов. В диаграмме дерева видимых элементов (рис. 4.7.) TDialog
владеет типом  TButton.  Здесь  взаимосвязь не между иерархическими
типами объектов (TDialog не является  предком  TButton!),  а  между
экземплярами объектов, между владельцем и подэлементами.

   Рис. 4.7. Дерево видимых элементов простого диалогового окна.

                        ┌──────────┐
                        │ TDialog  │
                        └─┬───┬───┬┘
                  ┌───────┘   │   └───────┐
              ┌───┴────┐┌─────┴───┐┌──────┴──────┐
              │ TFrame ││ TButton ││ TStaticText │
              └────────┘└─────────┘└─────────────┘

     Вам необходимо,   чтобы   TButton   взаимодействовал   с   его
владельцем в дереве элементов (TDialog) и  TButton  будет  рисовать
атрибуты, наследованные  от  своего предка (TView).  Не путайте эти
взаимосвязи.
     Выполнение программы   на   Turbo   Vision  подобно  дереву  с
созданием экземпляров  видимых  элементов   и   владением   другими
видимыми элементами.  Когда  программа  открывает и закрывает окна,
дерево видимых  элементов  растет  и  уменьшается  при  вставке   и
удалении экземпляров  объектов.  С другой стороны иерархия объектов
только растет,  когда  Вы  производите   новый   тип   объекта   от
стандартного объекта.


              Подэлементы и дерево видимых элементов.

     Как сказано раньше,  видимый элемент  TApplication  владеет  и
управляет тремя подэлементами, созданными им. Вы можете представить
эту взаимосвязь  как   формирование   дерева   видимых   элементов.
Application - это ствол,  а MenuBar, DeskTop и StatusLine формируют
ветви, как показано на рис. 4.8.

     Рис. 4.8. Основное дерево видимых элементов Turbo Vision.

                        ┌─────────────┐
                        │ Application │
                        └──┬──┬───┬───┘
                  ┌────────┘  │   └───────┐
              ┌───┴─────┐┌────┴────┐┌─────┴──────┐
              │ MenuBar ││ DeskTop ││ StatusLine │
              └─────────┘└─────────┘└────────────┘

     Запомните, что взаимосвязи,  показанные на рис.  4.8. - это не
иерархия объектов,   а  модель  структуры  данных.  Связи  отражают
принадлежность, а не наследование.
     В типичной  программе,  когда пользователь отмечает мышкой или
использует клавиатуру,  он  создает  новые  видимые  элементы.  Эти
видимые элементы будут появляться на панели экрана,  формируя новые
ветви дерева.
     Важно понимать взаимосвязи между владельцами и подэлементами и
как появление и поведение видимого элемента зависит  от  того,  кто
владеет видимым элементом.
     Рассмотрим пример.  Пусть пользователь отмечает элемент  меню,
который вызывает  окно просмотра файла.  Окно просмотра файла будет
видимым элементом.  Turbo Vision создает окно и присоединяет его  к
панели экрана.
     Окно будет владеть рядом подэлементов:  TFrame -  рамка  окна,
TScroller -   содержит  массив  текста  и  TScrollBar.  Когда  окно
вызывается, оно создает, владеет и управляет подэлементами.
     К Вашей  растущей программе подключены новые видимые элементы,
как показано на рис. 4.9.

           Рис. 4.9. Панель экрана с просмотром файлов.

          ┌────────────────────────────────────────────────┐
          │  Строка меню                                   │
          ├────────────────────────────────────────────────┤
          │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
          │░░╔═[■]═══ File Viewer Window ══1═[]═╗ ░░░░░░░░│
          │░░║                                    ░░░░░░░░│
          │░░║                                   ▒ ░░░░░░░░│
          │░░║  File text                        ▒ ░░░░░░░░│
          │░░║                                   ▒ ░░░░░░░░│
          │░░║                                   ■ ░░░░░░░░│
          │░░║                                   ▒ ░░░░░░░░│
          │░░║                                    ░░░░░░░░│
          │░░╚══════════▒■▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒══════┘ ░░░░░░░░│
          │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
          ├────────────────────────────────────────────────┤
          │  Строка статусa                                │
          └────────────────────────────────────────────────┘

     Дерево видимых  элементов  становится   более   сложным,   как
показано на рис. 4.10.

      Рис. 4.10. Дерево видимых элементов с просмотром файла.

                        ┌─────────────┐
                        │ Application │
                        └──┬──┬───┬───┘
                  ┌────────┘  │   └───────┐
              ┌───┴─────┐┌────┴────┐┌─────┴──────┐
              │ MenuBar ││ DeskTop ││ StatusLine │
              └─────────┘└────┬────┘└────────────┘
                         ┌────┴───┐
                         │ Window │
                         └┬─┬──┬─┬┘
                    ┌─────┘ │  │ └──────┐
               ┌────┴──┐    │  │    ┌───┴──────┐
               │ Frame │    │  │    │ Scroller │
               └───────┘    │  │    └──────────┘
                         ┌──┘  └──┐
               ┌─────────┴──┐  ┌──┴─────────┐
               │ Scroll Bar │  │ Scroll Bar │
               └────────────┘  └────────────┘

     Теперь предположим,  что пользователь отметил тот  же  элемент
меню и  создал  другое окно просмотра файлов.  Turbo Vision создает
второе окно и присоединяет его к панели  экрана,  как  показано  на
рис. 4.11.

           Рис. 4.11. Панель экрана с просмотром файла.

       ┌────────────────────────────────────────────────────┐
       │  Строка меню                                       │
       ├────────────────────────────────────────────────────┤
       │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
       │░░╔═══════ File Viewer Window ══1═════╗░░░░░░░░░░░░░│
       │░░║                                   ░░░░░░░░░░░░░│
       │░░║         ╔═[■]═══ File Viewer Window ══2═[]═╗░░░│
       │░░║  File te║                                   ░░░│
       │░░║         ║                                   ▒░░░│
       │░░║         ║  File text                        ▒░░░│
       │░░║         ║                                   ▒░░░│
       │░░║         ║                                   ■░░░│
       │░░╚═════════║                                   ▒░░░│
       │░░░░░░░░░░░░║                                   ░░░│
       │░░░░░░░░░░░░╚══════════▒■▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒══════┘░░░│
       │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
       ├────────────────────────────────────────────────────┤
       │  Строка статусa                                    │
       └────────────────────────────────────────────────────┘

     Дерево видимых  элементов  становится  еще более сложным,  как
показано на рис. 4.12.

      Рис. 4.12. Дерево видимых элементов с просмотром файла.

                        ┌─────────────┐
                        │ Application │
                        └──┬──┬───┬───┘
                  ┌────────┘  │   └───────┐
              ┌───┴─────┐┌────┴────┐┌─────┴──────┐
              │ MenuBar ││ DeskTop ││ StatusLine │
              └─────────┘└──┬───┬──┘└────────────┘
                ┌───────────┘   └─────────────────┐
           ┌────┴───┐                        ┌────┴───┐
           │ Window │                        │ Window │
           └┬─┬──┬─┬┘                        └┬─┬──┬─┬┘
      ┌─────┘ │  │ └─────┐              ┌─────┘ │  │ └─────┐
 ┌────┴──┐    │  │   ┌───┴──────┐  ┌────┴──┐    │  │   ┌───┴──────┐
 │ Frame │    │  │   │ Scroller │  │ Frame │    │  │   │ Scroller │
 └───────┘    │  │   └──────────┘  └───────┘    │  │   └──────────┘
           ┌──┘  └──┐                        ┌──┘  └──┐
 ┌─────────┴──┐  ┌──┴─────────┐    ┌─────────┴──┐  ┌──┴─────────┐
 │ Scroll Bar │  │ Scroll Bar │    │ Scroll Bar │  │ Scroll Bar │
 └────────────┘  └────────────┘    └────────────┘  └────────────┘

     Как Вы увидите в главе 5,  управление  программы  проходит  по
дереву видимых элементов.  В предыдущем примере предположим, что Вы
отметили полосу скроллинга в окне  просмотра  файла.  Как  сделать,
чтобы это действие обрабатывалось в нужном месте?
     Программа Application видит отметку мышкой,  обнаруживает, что
она находится в области, управляемой панелью экрана и передает ее в
объект "панель экрана".  Панель экрана видит,  что  отметка  внутри
области, управляемой  просмотром файла и передает ее в этот видимый
элемент. Просмотр файла видит, что отметка была в полосе скроллинга
и позволяет   видимому   элементу  "полоса  скроллинга"  обработать
отметку, генерируя соответствующий отклик.
     Действительный механизм  этой  обработки  не  важен  в  данный
момент. Сейчас важно  понять  как  связаны  видимые  элементы.  Вне
зависимости от сложности структуры,  все видимые элементы связаны с
объектом Вашей программы.  (Обработка событий объяснена в главе 5).
Если пользователь  отметил  закрывающую  кнопку во втором просмотре
файла, или  элемент  меню  Close  Window, второй   просмотр   файла
закрывается. Turbo  Vision отключает его в дереве видимых элементов
и уничтожает.  Окно будет  освобождать  все  подэлементы,  а  затем
уничтожает себя.
     Вероятно пользователь будет удалять видимые элементы,  пока не
достигнет начальной  позиции и укажет,  что он закочил работу нажав
Alt-X или  выбрав  Exit  из   меню.   TApplication   удаляет   свои
подэлементы, а затем удаляет себя.


              Выбор и активизация видимых элементов.

     Внутри любой группы видимых элементов может быть выбран один и
только один    подэлемент.    Например,    когда   Ваша   программа
устанавливает полосу меню,  панель экрана и строку статуса,  панель
экрана - выбранный видимый элемент и вся работа будет происходить в
нем.
     Когда Вы  открыли  на панели экрана несколько окон,  выбранное
окно это окно с которым Вы работаете в  данный  момент.  Оно  также
называется активным окном (обычно самое верхнее окно).
     Внутри активного окна выбранный подэлемент называется активным
видимым элементом.  Вы  можете  думать об активном видимом элементе
как об  элементе   на   который   Вы   смотрите   или   с   которым
взаимодействуете. (Активный   видимый  элемент  находится  в  конце
цепочки выбранных элементов,  которая начинается от  программы).  В
окне редактора  активный видимый элемент будет интерьером с текстом
внутри него.  В диалоговом окне активный элемент  это  подсвеченный
элемент управления.
     В диаграмме  программы  на  рисунке   4.12   Application   это
модальный видимый элемент, а DeskTop его выбранный видимый элемент.
Внутри панели экрана второе (последнее вставленное) окно  выбрано и
следовательно активно. Внутри этого окна выбран интерьер скроллинга
и поскольку это терминальный  видимый  элемент  (т.е.  не  является
группой), он  находится в конце цепочки - является активным видимым
элементом. Рис.  4.13 показывает то же дерево видимых  элементов  с
цепочкой активных элементов, выделенных двойной рамкой.


                   Рис. 4.13. Активная цепочка.

                        ┌─────────────┐
                        │ Application │
                        └──┬──┬───┬───┘
                  ┌────────┘  │   └───────┐
              ┌───┴─────┐╔════╧════╗┌─────┴──────┐
              │ MenuBar │║ DeskTop ║│ StatusLine │
              └─────────┘╚══╤═══╤══╝└────────────┘
                ┌───────────┘   └─────────────────┐
           ┌────┴───┐                        ╔════╧═══╗
           │ Window │                        ║ Window ║
           └┬─┬──┬─┬┘                        ╚╤═╤══╤═╤╝
      ┌─────┘ │  │ └─────┐              ┌─────┘ │  │ └─────┐
 ┌────┴──┐    │  │   ┌───┴──────┐  ┌────┴──┐    │  │   ╔═══╧══════╗
 │ Frame │    │  │   │ Scroller │  │ Frame │    │  │   ║ Scroller ║
 └───────┘    │  │   └──────────┘  └───────┘    │  │   ╚══════════╝
           ┌──┘  └──┐                        ┌──┘  └──┐
 ┌─────────┴──┐  ┌──┴─────────┐    ┌─────────┴──┐  ┌──┴─────────┐
 │ Scroll Bar │  │ Scroll Bar │    │ Scroll Bar │  │ Scroll Bar │
 └────────────┘  └────────────┘    └────────────┘  └────────────┘

     Кроме всего прочего,  информация об активном видимом  элементе
говорит Вам какой видимый элемент получит информацию от клавиатуры.
Для дополнительной информации смотри раздел по активным  событиям в
главе 5.


                  Нахождение активного элемента.

     Активный видимый  элемент  обычно  подсвечивается  на  экране.
Например, если Вы открыли на панели экрана несколько окон, активное
окно окружено  двойной  рамкой,  а  остальные   одинарной.   Внутри
диалогового окна  активный элемент управления (а элемент управления
это тоже видимый элемент) ярче других, указывая на то, что он будет
действовать когда   Вы   нажмете   Enter.   Т.е.  активный  элемент
управления также является элементом управления  по  умолчанию.  (На
монохромных  мониторах  Turbo  Vision добавляет символы стрелок для
указания активного элемента).


               Как сделать видимый элемент активным?

     Видимый элемент  можно  сделать активным двумя способами,  или
по умолчанию при его создании, или через действие пользователя.
     Когда создается  группа  видимых элементов,  владеющий видимый
элемент указывает какой из его подэлементов будет активным, вызывая
метод Select  этого подэлемента.  Так устанавливается активность по
умолчанию.
     Пользователю может  потребоваться  изменить  текущий  активный
видимый элемент.  Можно сделать это,  отметив мышкой другой видимый
элемент. Например, если на панели экрана открыто несколько окон, Вы
можете выбрать другое окно просто отметив его. В диалоговом окне Вы
можете переместить   активность,   нажав  Tab,  который  циклически
обходит все доступные видимые элементы или отметив мышкой требуемый
видимый элемент или нажав горячую клавишу.
     Заметим что существуют видимые элементы, которые не могут быть
выбраны - фон панели экрана,  рамки окон и полосы скроллинга. Когда
Вы создаете видимый элемент Вы можете указать будет ли этот элемент
выбираемым, после чего видимый элемент определяет,  остаться ли ему
выбираемым. Если Вы отметили рамку окна,  рамка не станет активной,
поскольку рамка  знает  что  она  не  может  быт  активным  видимым
элементом.


                        Цепочка активности.

     Если Вы  начнете  с  главной  программы  и  проследите  все ее
выбранные подэлементы,  переходя к каждому последующему  выбранному
подэлементу, Вы  дойдете  до  активного видимого элемента.  Цепочка
видимых элементов,  начиная от объекта TApplication и до  активного
видимого элемента,  называется активной цепочкой.  Активная цепочка
используется для обработки  активных  событий,  таких  как  нажатае
клавиш. (См. главу 5 для полного объяснения).


                    Модальные видимые элементы.

     Режим (модальность) это способ действия  или функционирования.
Программа может   иметь   несколько   режимов   действия,  особенно
различающимися для  различных  функций  управления   или   областей
управления. Например,  интегрированная  среда  Turbo  Pascal  имеет
режимы редактирования,  отладки,   компиляции   и   выполнения.   В
зависимости от   того   какой  из  этих  режимов  активен,  клавиши
клавиатуры могут приводить к различным действиям  (  или  не  иметь
действия вообще).
     Видимый элемент Turbo Vision может определять режим действия и
называется в  этом случае модальным видимым элементом. Классический
пример модального видимого элемента - диалоговое окно. Обычно когда
диалоговое окно активно,  за его пределами ничего не функционирует.
Вы не можете использовать меню  и  другие  элементы  управления  не
принадлежащие диалоговому   окну,  кроме  того  отметка  мышкой  за
пределами диалогового окна не имеет действия.  Управление находится
внутри диалогового   окна   до  тех  пор  пока  оно  не  закроется.
(Некоторые диалоговые окна не модальные, но это редкое исключение).
     Когда Вы  создаете  экземпляр  видимого элемента и делаете его
модальным, только этот видимый  элемент  и  его  подэлементы  могут
взаимодействовать с пользователем.  Вы можете представить модальный
видимый элемент как определение (сферы действия) в Вашей программе.
Когда Вы   создаете  блок  в  программе  Turbo  Pascal  (такой  как
процедуру или функцию),  идентификаторы,  объявленные внутри  этого
блока, действительны   только   внутри   этого  блока.  Аналогично,
модальный видимый элемент определяет что  функционирование доступно
внутри него  -  события  обрабатываются  только  модальным  видимым
элементом и  его  подэлементами.   Любая   часть   дерева   видимых
элементов,  не  являющаяся модальным элементом или не принадлежащая
модальному элементу, не активна.
     Существует одно  исключение  из  этого  правила  -  это строка
статуса. (Строка  статуса  всегда   "горячая",   вне   зависимости,
является ли  видимый  элемент  модальным).  Turbo  Vision сохраняет
строку статуса все время активной.  Таким образом,  Вы можете иметь
активные элементы  строки  статуса  даже  когда  в  Вашей программе
выполняется модальное диалоговое окно,  которое не владеет  строкой
статуса. Однако  события  и команды,  генерируемые строкой статуса,
обрабатываются как если бы  они  генерировались  внутри  модального
видимого элемента.
     Всегда существует модальный  видимый  элемент  при  выполнении
программы на  Turbo  Vision.  Когда Вы запускаете программу и часто
для работы программы сама прикладная программа  является  модальным
видимым  элементом  -  объект TApplication,  находящийся на вершине
дерева видимых элементов.


             Модификация поведения видимых элементов.

     До этого  момента Вы видели как ведут себя стандартные видимые
элементы по умолчанию.  Но иногда Вам  потребуется,  чтобы  видимые
элементы выглядели  или  действовали  несколько  по-другому и Turbo
Vision предоставляет  такую  возможность.  Этот  раздел   объясняет
способы модификации стандартных видимых элементов.
     Каждый видимый элемент Turbo  Vision  имеет  4  поля,  которые
можно использовать для изменения поведения этого элемента. 3 из них
описаны здесь:  слово  Options,  байт  GrowMode  и  байт  DragMode.
Четвертое поле - слово EventMask описано в главе 5.
     Существует так же слово State, содержащее информацию о текущем
состоянии видимого  элемента.  В  отличие  от  других  полей  State
используется только для  чтения.  Его  значение  должно  изменяться
только методом  SetState.  Для дополнительных деталей смотри раздел
"Флаг State и SetState".


                           Флаг Options.

     Options - это переменная типа слово в каждом видимом элементе.
Различные потомки  TView  имеют  различную  установку  Options   по
умолчанию.
     Биты Options определены на рисунке 4.14.

                  Рис. 4.14. Биты флагов Options.


       ┌──────── TView.Options ────────┐
       msb                           lsb
                    ┌─┬─────────────────── ofCentered
       ╔═╤═╤═╤═╤═╤═╤╧╤╧╤═╤═╤═╤═╤═╤═╤═╤═╗
       ╚╤╧═╧═╧═╧═╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╝
        └────┬────┘ │ │ │ │ │ │ │ │ │ └─── ofSelectable
             │      │ │ │ │ │ │ │ │ └───── ofTopSelect
       Неопределены │ │ │ │ │ │ │ └─────── ofFirstClick
                    │ │ │ │ │ │ └───────── ofFramed
                    │ │ │ │ │ └─────────── ofPreProcess
                    │ │ │ │ └───────────── ofPostProcess
                    │ │ │ └─────────────── ofBuffered
                    │ │ └───────────────── ofTileable
                    │ └─────────────────── ofCenterX
                    └───────────────────── ofCenterY


     ofSelectable
     Если установлен,  пользователь  может  выбрать видимый элемент
мышкой. Если видимый элемент - группа,  пользователь может  выбрать
его мышкой  или  клавишей  Tab.  Если  Вы  поместили на экран чисто
информационный элемент, Вам может потребоваться, чтобы пользователь
не мог выбрать его.  Так например,  статические текстовые объекты и
рамки окон обычно не выбираемые.

     ofTopSelect
     Видимый элемент будет передвигаться наверх других подэлементов
владельца, если он выбран.  Эта опция в основном  используется  для
окон на  панели  экрана.  Вы  не должны использовать ее для видимых
элементов в группе.

     ofFirstClick
     Отметка мышкой,  которая выбирает видимый элемент,  передается
этому видимому  элементу.  Если  кнопка  отмечена,  Вы  определенно
хотите обработать    выбранную   кнопку,   поэтому   кнопка   имеет
ofFirstClick установленным.  Но если пользователь отмечает окно, Вы
можете хотеть  или  не  хотеть,  чтобы  окно  откликалось  на выбор
мышкой.

     ofFramed
     Если установлен,  видимый  элемент  имеет  видимую рамку.  Это
полезно, если Вы создаете несколько панелей внутри окна.

     ofPreProcess
     Если установлен,   позволяет  видимому  элементу  обрабатывать
активные события до того,  как активный видимый элемент увидит  их.
См. раздел "Фаза" в главе 5.

     ofPostProcess
     Если установлен,  позволяет  видимому  элементу   обрабатывать
активные события после того,  как они были увидены активным видимым
элементом при условии,  что активный видимый  элоемент  не  очистил
событие. См. раздел "Фаза" в главе 5.

     ofBuffered
     Когда этот бит установлен, группа может ускорять свой вывод на
экран. Когда    группа    впервые   запрашивает   прорисовку,   она
автоматически сохраняет  свой  образ  в  буфере,  если   этот   бит
установлен и   если   доступно  достаточное  количество  памяти.  В
следующий раз,  когда группа запрашивает прорисовку,  она  копирует
образ из буфера на экран вместо прорисовки всех своих подэлементов.
Если вызовы New или GetMem  приводят  к  нехватке  памяти,  монитор
памяти Turbo  Vision  начнет  освобождать  буфера групп до тех пор,
пока запрос не сможет быть выполнен.
     Если группа  имеет  буфер,  вызов Lock будет останавливать все
записи группы на экран до тех  пор,  пока  не  будет  вызван  метод
UnLock. Когда  UnLock вызывается,  буфер группы выводится на экран.
Блокирование уменьшает  мерцание  во  время  сложных  корректировок
экрана. Например,  панель  экрана блокирует себя когда выводит свои
подэлементы каскадом или черепицей.

     ofTileable
     Панель экрана  может  располагать  окна каскадом или черепицей
когда они открываются.  Если Вы не хотите, чтобы окна располагались
черепицей, Вы  можете  очистить  этот бит.  Окно останется в той же
позиции в  то  время,  когда  остальные  окна  будут  автоматически
располагаться черепицей.  Расположение  видимых элементов черепицей
или каскадом выполняется в TApplication.HandleEvent очень просто:

     cmTile:
       begin
         DeskTop^.GetExtent(R);
         DeskTop^.Tile(R);
       end;
     cmCascade:
       begin
         DeskTop^.GetExtent(R);
         DeskTop^.Cascade(R);
       end;

     Если более  2  видимых элементов успешно расположены каскадом,
панель экрана не будет делать ничего.

     ofCenterX
     Когда видимый   элемент   вставляется   в  группу,  его  центр
находится в координате Х.

     ofCenterY
     Когда видимый   элемент   вставляется   в  группу,  его  центр
находится в координате Y. Это может быть важно при разработке окон,
которые  должны  хорошо  работать  в  25  и  43-строчном  текстовых
режимах.

     ofCentered
     Центр видимого  элемента находится в координатах X и Y,  когда
он вставляется в группу.


                          Флаг GrowMode.

     Поле видимого  элемента  GrowMode  определяет  как  изменяется
видимый элемент, когда его владелец группы изменяет размер.
     Биты GrowMode определены следующимм образом:

                 Рис. 4.15. Биты флагов GrowMode.


               ┌─── GrowMode ──┐
               msb           lsb
                        ┌─┬─┬─┬─── gfGrowAll
               ╔═╤═╤═╤═╤╧╤╧╤╧╤╧╗
               ╚╤╧═╧╤╧╤╧╤╧╤╧╤╧╤╝
                └─┬─┘ │ │ │ │ └─── gfGrowLoX
                  │   │ │ │ └───── gfGrowLoY
          Неопределены│ │ └─────── gfGrowHiX
                      │ └───────── gfGrowHiY
                      └─────────── gfGrowRel


     gfGrowLoX
     Если установлен,   левая   сторона   видимого  элемента  будет
поддерживать постоянное расстояние от левой стороны его владельца.

     gfGrowLoY
     Если установлен,  вершина видимого элемента будет поддерживать
постоянное расстояние от вершины его владельца.

     gfGrowHiX
     Если установлен,   правая   сторона  видимого  элемента  будет
поддерживать постоянное расстояние от правой стороны его владельца.

     gfGrowHiY
     Если установлен,   нижняя   граница  видимого  элемента  будет
поддерживать постоянное расстояние от нижней границы его владельца.

     gfGrowAll
     Если установлен,   видимый   элемент  всегда  остается  одного
размера  и  будет  передвигаться  вместе  с  нижним  правым   углом
владельца.

     gfGrowRel
     Если установлен,  видимый  элемент  будет  поддерживать   свой
размер относительно  размера владельца.  Вы должны использовать эту
опцию только с TWindow (или с  наследниками  от  TWindow),  которые
присоединяются к   панели   экрана.   Окна  будут  поддерживать  их
относительный размер когда пользователь переключает программу между
25- и  43/50  строчным  режимом.  Этот  флаг  не  предназначен  для
использования с видимыми элементами внутри окна.


                          Флаг DragMode.

     Поле DragMode  размером  в  байт  определяет  как  ведет  себя
видимый элемент при перемещении.
     Биты DragMode определены:

                 Рис. 4.16. Биты флагов DragMode.

               ┌─── DragMode ──┐
               msb           lsb
                ┌─┬─┬─┬─────────── dmLimitAll
               ╔╧╤╧╤╧╤╧╤═╤═╤═╤═╗
               ╚╤╧╤╧╤╧╤╧═╧═╧╤╧╤╝
                │ │ │ │     │ └─── dmDragMove
                │ │ │ │     └───── dmDragGrow
                │ │ │ └─────────── dmLimitLoX
                │ │ └───────────── dmLimitLoY
                │ └─────────────── dmLimitHiX
                └───────────────── dmLimitHiY

     dmDragMove
     Когда этот бит установлен и когда Вы отмечаете  вершину  рамки
окна, Вы можете перемещать окно.

     dmDragGrow
     Когда этот  бит  установлен,  видимый   элемент   может   быть
увеличен.

     dmLimitLoX
     Если установлен,  левая сторона  видимого  элемента  не  может
выходить за своего владельца.

     dmLimitLoY
     Если установлен,  вершина видимого элемента не может  выходить
за своего владельца.

     dmLimitHiX
     Если установлен,  правая сторона видимого  элемента  не  может
выходить за своего владельца.

     dmLimitHiY
     Если установлен,  нижняя граница видимого  элемента  не  может
выходить за своего владельца.

     dmLimitAll
     Если установлен,  ни одна часть  видимого  элемента  не  может
выходить за своего владельца.


                      Флаг State и SetState.

     Видимый элемент так же содержит  флаг  State,  который  хранит
различные аспекты  видимого  элемента,  такие  как  его  видимость,
запрещение и возможность перемещения.
     Биты флага State определены на рис. 4.17.

                    Рис.4.17. Биты флага State.

       ┌────── TView.State Flags ──────┐
       msb                           lsb
       ╔═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╗
       ╚═╧═╧═╧═╧╤╧═╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╝
                │   │ │ │ │ │ │ │ │ │ └─── sfVisible   = $0001
                │   │ │ │ │ │ │ │ │ └───── sfCursorVis = $0002
                │   │ │ │ │ │ │ │ └─────── sfCursorIns = $0004
                │   │ │ │ │ │ │ └───────── sfShadow    = $0008
                │   │ │ │ │ │ └─────────── sfActive    = $0010
                │   │ │ │ │ └───────────── sfSelected  = $0020
                │   │ │ │ └─────────────── sfFocused   = $0040
                │   │ │ └───────────────── sfDragging  = $0080
                │   │ └─────────────────── sfDisabled  = $0100
                │   └───────────────────── sfModal     = $0200
                └───────────────────────── sfExposed   = $0800

     Значение каждого  из  флагов  состояния описаны в главе 14 под
заголовком "Константы  флагов  состояния   sfXXXX".   Этот   раздел
описывает механизм манипуляции полем State.
     Turbo Vision  изменяет  флаг  состояния  видимого  элемента  с
помощью метода   SetState.   Если  видимый  элемент  активизирован,
активизируется или выбран,  Turbo  Vision  вызывает  SetState.  Это
отличается от   способа,   которым   обрабатываются  другие  флаги,
поскольку они  устанавливаются  при  инициализации   и   затем   не
изменяются (например,  если окно может изменять размер,  оно всегда
может изменять размер).  Состояние видимого элемента, однако, часто
изменяется при  его  нахождении  на  экране.  Поэтому  Turbo Vision
предоставляет механизм в SetState,  который позволяет Вам не только
изменить состояние  видимого  элемента,  но  так  же реагировать на
изменения состояния.
     SetState получает   состояние   (AState)   и   флаг  (Еnable),
указывающее установлено состояние или очищено.  Если Enable - True,
то  биты  в  AState  устанавливаются в State.  Если Enable - False,
соответствующие биты State  очищаются.  Это  во  многом  похоже  на
работу с любым битовым полем.  Отличия появляются, когда Вы хотите,
чтобы видимый элемент  сделал  что-либо,  когда  Вы  изменяете  его
состояние.


                 Действие на изменение состояние.

     Видимый элемент  часто  выполняет  определенные  действия  при
вызове State,  в  зависимости  от результирующего состояния флагов.
Например кнопка  просматривает  State  и  изменяет  свой  цвет   на
бирюзовый, когда становится активной.  Типичный пример SetState для
объекта, порожденного от TView.

     procedure TButton.SetState(AState: Word; Enable: Boolean);
     begin
       TView.SetState(AState, Enable);
       if AState and (sfSelected + sfActive) <> 0 then DrawView;
       if AState and sfFocused <> 0 then MakeDefault(Enable);
     end;

     Заметим, что Вы должны вызвать TView.SetState из нового метода
SetState. TView.SetState выполняет  установку  или  очистку  флагов
состояния. Затем Вы можете определить любые действия, основанные на
состоянии видимого элемента.  TButton проверяет,  находится ли он в
активном окне для того,  чтобы решить,  должен ли он рисовать себя.
Он так же проверяет,  является ли  он  активным  и  в  этом  случае
вызывает свой метод MakeDefault, который устанавливает или отменяет
активность в зависимости от параметра Enable.
     Если Вам необходимо выполнить изменения в видимом элементе или
программе когда   состояние   определенного    видимого    элемента
изменяется, Вы можете сделать это, перекрыв SetState этого видимого
элемента. Предположим,  что  Ваша  программа   включает   текстовый
редактор и   Вы   хотите   разрешить   или  запретить  все  команды
редактирования в полосе меню в зависимости от того, открыт редактор
или нет. SetState текстового редактора определен:

     procedure TEditor.SetState(AState: Word; Enable: Boolean);
     const
       EditorCommands = [cmSearch, cmReplace, cmSearchAgain,
         cmGotoLine, cmFindProc, cmFindError, cmSave, cmSaveAs];
     begin
       TView.SetState(AState, Enable);
       if AState and sfActive <> 0 then
         if Enable then EnableCommands(EditorCommands)
         else DisableCommands(EditorCommands);
     end;

     Примечание: Этот код используется видимым  элементом редактора
IDE Turbo Pascal, и его поведение должно быть Вам знакомо.

     Программист и   Turbo   Vision  часто  взаимодействуют,  когда
состояние изменяется.  Предположим,  что Вы хотите,  чтобы блоковый
курсор появился  в  Вашем  текстовом  редакторе когда включен режим
вставки.
     Во-первых, режим  вставки редактора связан с клавишей, скажем,
с клавишей Ins.  Когда текстовый редактор  активен  и  клавиша  Ins
нажата, текстовый  редактор  получает  событие  клавиши Ins.  Метод
HandleEvent текстового  редактора  откликается   на   событие   Ins
переключением внутреннего  состояния видимого элемента, говорящегоо
том, что режим вставки изменился и вызывая метод BlockCursor. Turbo
Vision делает  остальное.  BlockCursor  вызывает  SetState видимого
элемента для установки состояния sfCursorIns в True.


                      Цвет видимого элемента.

     У всех  разное  мнение по поводу того,  какой цвет "лучше" для
экрана компьютера.  Поэтому Turbo  Vision  позволяет  Вам  изменять
цвета видимых   элементов   на   экране.  Для  этого  Turbo  Vision
предоставляет Вам палитры цветов.


                          Палитры цветов.

     Когда видимый   элемент   в   Turbo  Vision  рисует  себя,  он
запрашивает прорисовку не определенным цветом,  а цветом,  заданным
позицией в  его  палитре  (палитры  для  всех  стандартных  видимых
элементов описаны в главе 13).  Например,  палитра TScroller  имеет
вид:

     CScroller = #6#7;

     Палитра цветов  в  действительности  хранится  в  строке,  что
позволяет определять ее в качестве  гибких  массивов  с  переменной
длиной. Так,  CScroller  - это двухсимвольная строка,  содержащая 2
элемента палитры. Палитра TScroller определена:

     { Палитра          }
     { 1 = Нормальный   }
     { 2 = Подсвеченный }

     Но удобнее рассмотреть ее в виде:

          Рис. 4.18. Палитра по умолчанию для TScroller.

                 1   2
               ┌───┬───┐
     CScroller │ 6 │ 7 │
               └───┴───┘
                 │   │
                 │   └───────── Подсвеченный текст
                 └───────────── Нормальный текст

     Это означает,  что известно как отображать по крайней  мере  2
типа текста  объекта скроллер:  нормальный и подсвеченный.  Цвет по
умолчанию определяется  элементами  палитры.   Когда   отображается
нормальный текст, метод Draw должен вызвать GetColor(1) означающий,
что он хочет выбрать  цвет,  указанный  первым  элементом  палитры.
Чтобы показать  подсвеченный  текст,  будет вызываться GetColor(2).
(GetColor - это метод TView).
     Если Вы хотите отображать цветами по умолчанию,  это все,  что
Вам необходимо  знать.  Палитра  устанавливается  так,  что   любая
комбинация объектов должна создавать хорошие цвета.


                      Внутри палитры цветов.

     Элементы палитры - это индексы в палитру владельца,  а не сами
цвета. Если скроллер вставлен в окно, Вы получите нормальный текст,
вызывая скроллер с нормальным цветом текста  в  палитре  скроллера,
который содержит номер 6. Чтобы преобразовать это в цвет, Вы должны
найти 6 элемент в палитре владельца.  Рис. 4.19. показывает палитру
TWindow:

     Рис. 4.19. Отображение палитры скроллера в палитру окна.

   ┌───────────────────────────── Рамка пассивна
   │   ┌───────────────────────── Рамка активна
   │   │   ┌───────────────────── Кнопка рамки
   │   │   │   ┌───────────────── Страница скроллера
   │   │   │   │   ┌───────────── Элемент управления скроллера
   │   │   │   │   │   ┌───────── Нормальный текст скроллера
   │   │   │   │   │   │   ┌───── Выбранный текст скроллера
   │   │   │   │   │   │   │   ┌─ Зарезервировано
   │   │   │   │   │   │   │   │
   1   2   3   4   5   6   7   8
 ┌───┬───┬───┬───┬───┬───┬───┬───┐
 │ 8 │ 9 │ 10│ 11│ 12│ 13│ 14│ 15│ CBlueWindow
 └───┴───┴───┴───┴───┴─┬─┴───┴───┘
   ┌───────────────────┘
 ┌─┴─┬───┐
 │ 6 │ 7 │   CScroller
 └───┴───┘
   │   │
   │   └─────────────────────── Подсвеченный текст
   └─────────────────────────── Нормальный текст

     6 элемент в палитре TWindow равен 13,  это  индекс  в  палитре
владельца окна  (панели  экрана),  который преобразуется в индекс в
палитру его владельца - программы.  TDeskTop имеет палитру nil, что
означает, что он не изменяет ничего. Вы можете думать об этом как о
"прямой" палитре с первым элементом с номером 1, вторым - с номером
2 и т.д.
     Программа, которая имеет палитру,  содержит значения для  всех
элементов, которые Вы можете вставить в Turbo Vision. Ее 13 элемент
- это $1.  Программа - это последяя точка (она не имеет владельца),
поэтому отображение  останавливается здесь.  Сейчас Вы получили $1,
что соответствует цвету фона 1 и цвету символа  $Е  (или  14),  что
создает желтый символ на синем фоне.  И опять, не думайте об этом в
терминах желтый-на-синем,  а скорее скажите,  что Вы хотите,  чтобы
Ваш текст отображался нормальным цветом для текста окна.
     Не думайте о палитре как о цветах,  это тип характеристик  для
отображения.


                          Метод GetColor.

     Отображение цвета  палитры  выполняется  виртуальной  функцией
GetColor из TView. GetColor поднимается по дереву видимых элементов
от рисуемогоо элемента к его владельцу, затем к владельцу владельца
и т.д.  пока не дойдет до объекта программа.  Для каждого объекта в
этой цепочке GetColor вызывает GetPalette этого  объекта. Результат
- цвет атрибута.
     Палитра видимого  элемента   содержит   смещения   в   палитре
владельца за исключением прикладной программы, чья палитра содержит
атрибуты цветов.


                  Перекрытие цветов по умолчанию.

     Очевидный способ  изменить цвета - это изменить палитру.  Если
Вам не  нравится  цвет  нормального  текста  скроллера,  Вы  можете
захотеть изменить элемент 1 (нормальный текст) в палитре скроллера,
например с 6  на  5.  Нормальный  текст  скроллера  отображается  в
элемент окна для элемента управления полосы скроллера (по умолчанию
синий-на-бирюзовом). Запомните:  5 -  это  не  цвет!  Все,  что  Вы
сделали -  это  сказали скроллеру,  что его нормальный текст должен
выглядеть так же, как полосы скроллинга вокруг него!
     Что делать,   если  Вы  не  хотите  желтый-на-синем?  Измените
элемент палитры  для  нормального  текста  окна   в   TApplication.
Поскольку это   последняя   не  nil  палитра,  элементы  в  палитре
программы определяют  цвета,  которые  будут  появляться  во   всех
видимых элементах  окна,  т.е.  цвета  не  являются абсолютными,  а
определяются палитрами владельца.
     Это имеет смысл: вероятно Вы хотите, чтобы Ваши окна выглядели
одинаково. Вероятно Вы не  захотите  указывать  каждому  отдельному
окну какого  цвета  оно должно быть.  Если Вы захотите изменить его
позже (или разрешить пользователю настраивать цвета),  Вам придется
изменить элементы для каждого окна.
     Так же скроллер или другой интерьер не должен  беспокоиться  о
его цветах,  если он вставляется в какое-то окно, отличное от того,
в какое Вы хотели вставить его  первоначально.  Например,  если  Вы
поместили скроллер  в диалоговое окно вместо окна,  он не будет (по
умолчанию) того же цвета,  а вместо этого будет  цвета  нормального
текста в диалоговом окне.
     Чтобы изменить палитру  видимого  элемента,  перекройте  метод
GetPalette. Чтобы  создать  новый  тип  объекта скроллера,  который
рисует себя цветом рамки  окна  вместо  цвета  нормального  текста,
объявление и реализация объекта будут включать:

     type
       TMyScroller = object(TScroller)
         function GetPalette: PPalette; virtual;
       end;

     function TMyScroller.GetPalette: PPalette;
     const
       CMyScroller = #1#7;
       PMyScroller: string[Length(CMyScroller)] = CMyScroller;
     begin
       GetPalette := @PMyScroller;
     end;

     Заметим, что константа  палитры  -  это  строковая  константа,
поскольку Turbo  Vision  использует  тип  String  для представления
палитры. Это  позволяет  более  просто   манипулировать   палитрой,
поскольку все строковые функции могут использоваться с палитрами.

     Примечание: Типы TPalette и String полностью взаимозаменяемы.


                     Добавление новых цветов.

     Вы можете добавить дополнительные цвета к типу  объекта  окна,
который позволит  использовать  различные  цвета при создании новых
видимых элементов.  Например допустим,  Вы решили  добавить  третий
цвет для  скроллера для другого типа подсветки как используется для
точек прерывания  в  редакторе  IDE.   Это   может   быть   сделано
наследованием нового   типа  объекта  из  существующего  TWindow  и
добавлением к палитре по умолчанию:

     type
       TMyWindow = object(Window)
         function GetPalette: PPalette; virtual;
       end;

     function TMyWindow.GetPalette: PPalette;
     const
       CMyWindow := CBlueWindow + #84;
       P: string[Length(CMyWindow)] = CMyWindow;
     begin
       GetPalette := @P;
     end;

     Примечание: Палитры   -   это   строки,   так  что  Вы  можете
использовать строковые операции, такие как "+".

     Сейчас TMyWindow имеет новый элемент палитры, который содержит
новый тип подсветки.  CWindow - это строковая константа, содержащая
палитру TWindow по умолчанию.  Вы должны изменить метод  GetPalette
для MyScroller чтобы использовать это:

     function TMyScroller.GetPalette: PPalette;
     const
       CMyScroller = #6#7#9;
       P: string[Length(CMyScroller)] = CMyScroller;
     begin
       GetPalette := @P;
     end;

     Элемент 3  палитры  скроллера  -  это  новый цвет подсветки (в
данном случае  белый  на  красном).  Если  Вы   используете   новую
GetPalette используя CMyScroller, который обращается к 9 элементу в
палитре владельца, убедитесь, что владелец действительно использует
палитру CMyWindow. Если Вы попытаетесь обратиться к 9 элементу в 8-
элементной палитре, результат будет непредсказуем.
