
@Ч А С Т Ь  2. ПРОГРАММИРОВАНИЕ В TURBO VISION. ГЛАВА 3. ИЕРАРХИЯ ОБЪЕКТОВ.

#Иерархия объектов

     Эта глава предполагает,  что Вы хорошо  знаете  Turbo  Pascal,
особенно объектно-ориентированные   расширения,   хотя   мы   будем
напоминать некоторую   информацию   о   типах    объектов.    Также
предполагается, что  Вы читали часть 1 этого руководства и получили
обзор философии возможностей и терминологии Turbo Vision.
     После общих  замечаний  об  ООП  и  иерархии  эта  глава  дает
короткий обзор  иерархии  объектов  Turbo  Vision,  обращая  особое
внимание на   взаимосвязи  объектов  через  механизм  наследования.
Изучая главное  свойство  каждого  стандартного  типа  объектов  Вы
получите представление  о  том  как их наследовать и как объединены
поля и методы объекта для создания функциональности этого объекта.
     Полное иерархическое  дерево показано на рис.3.1.  Вам поможет
тщательное изучение этого рисунка.  Например,  информация о том что
TDialog  порожден от TWindow,  который порожден от TGroup,  который
порожден от TView  значительно  сокращает  время  изучения.  Каждый
новый  порожденный тип имеет уже известные унаследованные свойства.
Вы просто изучаете дополнительные  поля  и  свойства,  которыми  он
дополняет своих родителей.

             Рис. 3.1 Иерархия объектов Turbo Vision.

TObject─┬─TCollection───TSortedCollection──TStringCollection
        ├─TResourceFile                       └─TResourceCollection
        ├─TStream─────┬─TEmsStream
        ├─TStringList └─TDosStream──────TBufStream
        ├─TStrListMaker
        └─TView───────┬─TCluster──────┬─TCheckBoxes
                      ├─TFrame        └─TRadioButtons
                      ├─TGroup────────┬─TDeskTop
                      ├─TBackGround   ├─TProgram────TApplication
                      ├─TButton       └─TWindow───┬─THistoryWindow
                      ├─TStaticText───┬─TLabel    └─TDialog
                      ├─THistory      └─TParamText
                      ├─TListViewer───┬─THistoryViewer
                      ├─TInputLine    └─TListBox
                      ├─TMenuView─────┬─TMenuBar
                      ├─TScrollBar    └─TMenuBox
                      ├─TScroller────────TTextDevice──TTerminal
                      └─TStatusLine


     Когда Вы  будете  разрабатывать  собственную программу в Turbo
Vision, Вы  обнаружите,  что  общее  сходство   стандартных   типов
объектов  и  их  многочисленные  взаимосвязи оказывают значительную
помощь. Шлифовка деталей будет выполняться позднее,  но  как  и  во
всех OOП проектах, первоначальное общее планирование новых объектов
- это ключ к успеху.
     Не существует совершенной иерархии для любой программы. Каждая
иерархия объектов  -  это   определенный   компромисс,   полученный
тщательным экспериментом   (и  определенная  интуиция  совместно  с
практикой). Ваш опыт поможет  Вам  при  разработке  иерархии  типов
объектов. Естественно  Вы  можете  создать свои собственные базовые
типы объектов для достижения специальных эффектов по  сравнению  со
стандартными объектами.  В  главе 13 детально описаны методы и поля
всех стандартных типов объектов, но до тех пор, пока Вы не получите
общее представление  о  всей  иерархии,  Вы будете путаться в массе
деталей. Эта глава дает общее представление об  иерархии  до  того,
как Вы   обратитесь  к  деталям.  Остаток  этой  части  дает  более
детальное объяснение компонент Turbo  Vision  и  их  использования.
Часть 3 приводит ссылочный материал в алфавитном порядке.


#Типология объектов.

     Не все типы объектов  в  Turbo  Vision  одинаковы.  Вы  можете
разделить их  функции  на  3  различные  группы:  простые  объекты,
видимые объекты  и  невидимые  объекты.  Каждый  из  них  описан  в
отдельном разделе этой главы.
     Внутри каждой  группы  существуют  различные  виды   объектов.
Некоторые из  них  полезны - от них можно образовывать экземпляры и
использовать их,  а другие - абстрактные  объекты,  которые  служат
основой для   порождения   полезных   объектов.  До  того,  как  мы
рассмотрим объекты  в  их  иерархии,  полезно  понять   что   такое
абстрактные объекты.


#Абстрактные объекты.

     Многие типы объектов существуют как "абстрактная"  основа,  из
которой могут  порождаться  более  специализированные полезные типы
объектов. Причина    создания    абстрактных     типов     частично
концептуальная, но  в  большой  степени  служит  практическим целям
сокращения усилий по кодированию.
     Для примера  возьмем типы TRadioButtons и TCheckBoxes.  Каждый
из них может быть прямо порожден от TView. Однако они разделяют ряд
общих свойств:   оба  представляют  набор  элементов  управления  с
аналогичной реакцией.  Набор зависимых кнопок во  многом  похож  на
набор независимых кнопок,  внутри которого только одна кнопка может
быть выбрана,  хотя   существует   несколько   других   технических
различий. Эта  общность  включена  в  абстрактный  класс  TCluster.
TRadioButtons и    TCheckBoxes    порождены    от    TCluster    со
специализированными методами, обеспечивающими их индивидуальность.
     Бессмысленно создавать экземпляр абстрактного  типа.  Например
экземпляр MyCluster  от  TCluster  не  будет иметь полезного метода
Draw. Он   наследует   TView.Darw   без   перекрытия    так,    что
MyCluster.Draw будет    просто    выводить   пустой   прямоугольник
умалчиваемого цвета.  Если  Вы  хотите  создать  кластер  элементов
управления со  свойствами,  отличными  от зависимых или независимых
кнопок, Вы  можете  породить  TMyCluster  от  TCluster  или   можно
породить Ваш специальный кластер от TRadioButtons или TCheckBoxеs в
зависимости от того,  какой из них ближе  к  Вашим  требованиям.  В
любом случае  Вы  будете  добавлять  новые  поля  и  добавлять  или
перекрывать методы с минимальными  затратами.  Если  Вы  планируете
включить целое  семейство  новых  кластеров,  может  быть  полезным
создать промежуточный абстрактный тип объекта.


#Абстрактные методы.(II)

     Сможете ли  Вы создать полезный экземпляр объекта,  зависит от
обстоятельств. Многие   стандартные   типы   Turbo   Vision   имеют
абстрактные методы,  которые  должны  быть определены в порожденных
типах. Стандартные  типы  могут  так  же  иметь   псевдоабстрактные
методы, предоставляющие  минимальные  действия  по  умолчанию,  что
может удовлетворять  Вашим  целям,  если   же   нет   -   требуется
порожденный тип.
     Общее правило заключается в том,  что по мере продвижения вниз
по иерархии   Turbo   Vision   стандартные  типы  становятся  более
специализированными и менее "абстрактными".  Их имена соответствуют
функциональности, заключенной  в их поля и методы.  Для большинства
программ будут очевидными  базовые  типы,  из  которых  Вы  сможете
создать "стандартный" интерфейс: панель экрана, полосу меню, строку
статуса, диалоговые окна и т.д.


#Порожденные типы и экземпляры объектов.

     Для любого  объектного  типа доступны 2 основных операции:  Вы
можете создать  экземпляр  этого  типа  или  Вы  можете  произвести
порожденный объектный  тип.  В последнем случае Вы имеете новый тип
объекта, к которому могут быть  применены  предыдущие  2  операции.
Давайте посмотрим эти операции.


#Создание экземпляра.

     Создание экземпляра  объекта  обычно  связано  с   объявлением
переменной, статической или динамической:

               MyScrollBar: TScrollBar;
               SomeButton: PButton;

     MyScrollBar будет   инициализироваться   значениями  полей  по
умолчанию в  TScrollBar.Init.  Это  можно  посмотреть   в   разделе
TScrollBar.Init главы  13.  Поскольку TScrollBar порожден от TView,
TScrollBar.Init вызывает   TView.Init,   чтобы   установить   поля,
унаследованные от   TView.  Аналогично  TView.Init  наследуется  от
TObject, поэтому он вызывает констрактор TObject  для распределения
памяти. TObject не имеет предка.
     Объект MyScrollBar сейчас имеет значения полей  по  умолчанию,
которые Вы  можете изменить.  Он так же имеет все методы TScrollBar
плюс методы  (возможно  перекрытые)  от  TView  и  TObject.   Чтобы
использовать MyScrollBar,  Вам  нужно  знать что делают его методы,
особенно HandleEvent и Draw.  Если  требуемая  функциональность  не
определена в TScrollBar, Вам требуется породить новый тип.


#Порождение.

     Вы можете легко породить объектный тип из существующего.

               PNewScrollBar = ^TNewScrollBar;
               TNewScrollBar = object(TScrollBar)
                 end;

     Вы еще  не  имеете  экземпляров  этого  объектного  типа.   До
объявления объектов  TNewScrollBar  Вам необходимо определить новые
методы или  перекрыть  некоторые  методы  TScrollBar  и,  возможно,
добавить некоторые  новые  поля;  иначе  не  существует  причин для
создания нового типа объекта.  Новые или измененные методы  и  поля
добавляют функциональность к TScrollBar. Ваш новый метод Init будет
определять значения по умолчанию для Ваших новых объектов.


#Методы Turbo Vision.

     Методы Turbo  Vision  могут  характеризоваться   4   (возможно
перекрывающимися) способами, каждый из которых описан здесь.


#Абстрактные методы.(III)

     В базовом типе объекта абстрактный метод не  имеет определения
тела (или  тело  содержит  оператор Abstruct для перехвата неверных
вызовов). Абстрактные методы должны быть  определены  потомками  до
того, как могут быть использованы.  Абстрактные методы - это всегда
виртуальные методы. Пример такого метода TStream.Read.


#Псевдоабстрактные методы.

     В базовом   типе   объекта   псевдоабстрактный   метод   имеет
минимальные действия. Он почти всегда будет перекрываться потомком,
но метод  содержит  действия  по умолчанию для всех объектов в цепи
наследования. Пример - TSortedCollection.Compare.


#Виртуальные методы.

     Виртуальные методы  используют  директиву Virtual в объявлении
их прототипов.   Виртуальный   метод   может   быть   переопределен
(перекрыт) потомком,  но  переопределенный метод так же должен быть
виртуальным и его заголовок должен точно  соответствовать заголовку
оригинального метода.  Виртуальные методы не требуют перекрытия, но
обычно они рано или поздно перекрываются. Например TView.DataSize.


#Статические методы.

     Статический метод не  может  быть  перекрыт.  Порожденный  тип
может определить метод с тем же именем, используя совершенно другие
аргументы и тип возврата, если необходимо, но статические методы не
поддерживают полиморфизм. Это наиболее критично, когда Вы вызываете
методы динамических объектов.  Например, если PGeneric - переменная
указателя типа PView, Вы можете назначить ему указатели любого типа
из его иерархии.  Однако когда Вы делаете ссылку  по  переменной  и
вызываете статический метод, вызванный метод всегда будет из TView,
поскольку этот тип указателя определен во время компиляции. Другими
словами,       PGeneric^.StaticMethod      всегда      эквивалентен
TView.StaticMethod,  даже если  Вы  назначаете  PGeneric  указатель
другого типа. Например TView.Init.


#Поля Turbo Vision.

     Если Вы возьмете 3 объекта TView, TGroup и TWindow, то увидите
наследование их  полей  и  как растет функциональность при движении
вниз по иерархии (вспомним,  что дерево  объектов  растет  вниз  от
корня).

        Таблица 3.1. Наследование полей видимых элементов.

       ─────────────────────────────────────────────
       Поля TView    Поля TGroup   Поля TWindow
       ─────────────────────────────────────────────
       Owner          Owner           Owner
       Next           Next            Next
       Origin         Origin          Origin
       Size           Size            Size
       Cursor         Cursor          Cursor
       GrowMode       GrowMode        GrowMode
       DragMode       DragMode        DragMode
       HelpCtx        HelpCtx         HelpCtx
       State          State           State
       Options        Options         Options
       EventMask      EventMask       EventMask
                      Buffer          Buffer
                      Phase           Phase
                      Current         Current
                      Last            Last
                                      Flags
                                      Title
                                      Number
                                      ZoomRect
                                      Palette
                                      Frame
       ─────────────────────────────────────────────

     Заметим, что TGroup наследует все поля TView и добавляет поля,
которые необходимы для операций над группой, такие как указатели на
текущий и  последний  видимые элементы в группе.  TWindow наследует
все поля TGroup и добавляет поля, требуемые для операций над окном,
такие как заголовок и номер окна.
     Для того,  чтобы  полностью  понять  TWindow  Вам   необходимо
помнить, что окно - это группа (group) и видимый элемент (view).


#Примитивные типы объектов.

     Turbo Vision предоставляет 3  простых  типа  объекта,  которые
используются другими объектами или используются как основа иерархии
более сложных объектов.  TPoint и TRect используются всеми видимыми
объектами в  иерархии  Turbo  Vision.  TОbjеct  -  основа иерархии.
Заметим,  что объекты этих типов не являются  прямо  отображаемыми.
TPoint - это просто объект позиции на экране (X,  Y).  TRect просто
содержит верхнюю левую и нижнюю  правую  границы  прямоугольника  и
несколько невизуализирующих сервисных методов.


#TPoint.

     Этот объект представляет точку.  Его поля  X  и  Y  определяет
картезианские (X,  Y) координаты позиции экрана. Точка (0, 0) - это
верхняя левая точка экрана. X увеличивается горизонтально вправо, Y
увеличивается вертикально вниз.  TPoint не имеет методов, но другие
типы имеют методы,  которые  преобразуют  между  глобальными  (весь
экран) и   локальными  (относительно  смещения  видимого  элемента)
координатами.


#TRect.

     Этот объект  представляет прямоугольник.  Его поля A и B - это
объекты типа TPoint,  определяющие верхнюю левую  и  нижнюю  правую
точки прямоугольника. TRect имеет методы: Assign, Copy, Move, Grou,
Intersect, Union,  Contains,  Equals и Empty. Объекты типа TRect не
являются видимыми  элементами и не могут рисовать себя.  Однако все
видимые элементы  являются  прямоугольными:  их  констракторы  Init
используют параметр  Bounds  типа  TRect  для  определения области,
которую они покрывают.


#TObject.

     TObject -  это  абстрактный базовый тип без полей.  Это предок
всех объектов Turbo Vision,  за исключением TPoint и TRect. TObject
предоставляет 3   метода:  Init,  Free  и  Done.  Констрактор  Init
формирует основу для  всех  констракторов  Turbo  Vision,  выполняя
распределение памяти.  Free  освобождает это распределение.  Done -
это  абстрактный  дестрактор,  который  должен  быть   перекрыт   в
потомках.  Все  объекты,  которые  Вы  намереваетесь использовать с
потоками Turbo Vision должны быть производными от TObject.
     Потомки TObject  делятся  на  2  больших семейства:  видимые и
невидимые элементы.  Видимые элементы призводны от  TView,  который
дает им специальные свойства,  отсутствующие у невидимых элементов.
Видимые элементы  могут  рисовать  себя  и  обрабатывать   события,
посланные им.  Невидимые  объекты  предоставляют  набор  утилит для
обработки потоков и  коллекций  других  объектов,  включая  видимые
элементы, но они не могут быть визуализированы напрямую.


#Видимые элементы.

     Отображаемые потомки TObject известны как видимые  элементы  и
они порождаются  от  TView - непосредственного потомка TObject.  Вы
должны отличать "видимый" от "отображаемый",  поскольку могут  быть
ситуации, когда   видимый  элемент  полностью  или  частично  скрыт
другими видимыми элементами.


#Обзор видимых элементов.

     Видимый элемент   -  это  любой  объект,  который  может  быть
нарисован (отображен) в прямоугольной части  экрана.  Тип  видимого
объекта должен наследоваться от TView.  Сам TView - это абстрактный
объект, представляющий пустую область экрана. Имея TView в качестве
предка каждый  порожденный  видимый  элемент  имеет по крайней мере
прямоугольную часть экрана и минимальный виртуальный метод Draw.
     При программировании  в  Turbo  Vision  Вы будете использовать
более специализированные  потомки  от  TView,  но  функциональность
TView распространяется  на  весь  Turbo  Vision  и  Вам  необходимо
понимать его свойства.


#Группы.

     Важность TView  явно проявляется из схемы иерархии, показанной
на рис.  3.1.  Все,  что Вы видите в программах  на  Turbo  Vision,
порождается от TView. Но некоторые из этих видимых элементов так же
важны по  другой  причине.  Они   позволяют   нескольким   объектам
действовать вместе.


#Абстрактная группа.

     TGroup позволяет Вам обрабатывать динамически созданный список
связанных  интерактивных  подэлементов  через  назначенный  видимый
элемент, называемый владельцем группы. Каждый видимый элемент имеет
поле Owner типа PView,  которое указывает на владельца типа TGroup.
Указатель со значением nil означает,  что видимый элемент не  имеет
владельца.  Поле  Next  обеспечивает  связь  со  следующим  видимым
элементом в цепочке  видимых  элементов.  Поскольку  группа  -  это
видимый элемент,  могут  существовать видимые подэлементы,  которые
образуют группу своих видимых подэлементов и т.д.
     Состояние цепочки  постоянно  изменяется  в  процессе  ввода с
клавиатуры или отмечания мышкой.  Новые группы могут создаваться  и
видимые подэлементы  могут  добавляться (вставляться) или удаляться
из группы.  Во время их существования видимые элементы  могут  быть
скрыты действиями, производимыми над другими подэлементами так, что
группе требуется координировать их взаимодействие.


#Панель экрана.

     TDeskTop -    это    нормальный   фоновый   видимый   элемент,
обеспечивающий привычную  панель   экрана   пользователям,   обычно
окруженную полосой  меню  и  строкой  статуса.  Обычно TApplication
владелец группы,   содержащей   объекты   TDeskTop,   TMenuBar    и
TStatusLine. Другие  видимые элементы,  такие как окна и диалоговые
окна, создаются,  отображаются и манипулируются на панели экрана  в
ответ на  действия  пользователя  (события  от мышки и клавиатуры).
Большая часть работы программы происходит внутри панели экрана.


#Программы.

     TProgram предоставляет   набор  виртуальных  методов  для  его
потомка TApplication.


#Прикладные программы.

     TApplication предоставляет   объект  заготовки  программы  для
Ваших программ на Turbo Vision.  Он  является  потомком  от  TGroup
(через TProgram).   Обычно   он   владеет   видимыми  подэлементами
TMenuBar, TDeskTop и TStatusLine.  TApplication  имеет  методы  для
создания и   вставки   этих   трех   подэлементов.  Ключевой  метод
TApplication -  это   TApplication.Run,   который   выполняет   код
программы.


#Окна.

     Объекты TWindow,  с помощью ассоциированных объектов TFrame  -
это прямоугольники   с   рамкой,   которую  Вы  можете  перемещать,
изменять ее размеры и удалять,  используя методы, унаследованные от
TView. Поле  Frame  указывает  на объект TFrame этого окна.  Объект
ТWindow так же может изменять размер и закрываться,  используя свои
методы. TWindow  обрабатывает  клавиши  Tab  и Shift-Tab для выбора
следующего или предыдущего видимого подэлемента в  окне. Обработчик
событий TWindow  обрабатывает команды закрытия и изменения размера.
Пронумерованные окна могут быть выбраны горячими клавишами Alt-n.


#Диалоговые окна.

     TDialog, порожденный  от  TWindow,  используется  для создания
диалоговых окон,  обрабатывающих  взаимодействие  с  пользователем.
Диалоговые окна  обычно  содержат  элементы  управления такие,  как
кнопки. Родительский метод  ExecView  используется  для  сохранения
предыдущего контекста,  вставки объекта TDialog в группу и перевода
диалогового  окна  в  модальный режим.  Объект TDialog обрабатывает
события,  генерируемые пользователем,  такие как нажатие  кнопок  и
клавиш.  Клавиша Esc интерпретируется как выход (cmCancel). Клавиша
Enter интерпретируется как событие cmDefault (обычно  означает, что
кнопка  по  умолчанию  выбрана).  Наконец  ExecView восстанавливает
предварительно сохраненный контекст.


#Терминальные видимые элементы.

     Терминальные видимые  элементы  это  все   видимые   элементы,
которые не являются группами. Они не могут владеть другими видимыми
элементами.  Они,  следовательно,  являются конечными точками любых
цепочек видимых элементов.


#Рамки.

     TFrame обеспечивает отображаемую рамку для объектов TWindow, а
так же  кнопки  для  перемещения  и  закрытия окна.  Объекты TFrame
никогда не используются отдельно,  а все время совместно с объектом
TWindow.


#Кнопки.

     Объект TButton - это  помеченный  прямоугольник,  используемый
для генерации  события с заданной командой при ее "нажатии". Обычно
они размещаются внутри (принадлежат) диалоговых  окон, предоставляя
такие выборы  как  "OK" или "Cancel".  Диалоговое окно - это обычно
модальный видимый элемент,  который при появлении  перехватывает  и
обрабатывает все события, включая события от его кнопок. Обработчик
событий предоставляет несколько способов  нажатия  кнопки:  выбором
прямоугольника кнопки   мышкой,   нажатием  короткого  символа  или
выбором кнопки по умолчанию клавишей Enter.


#Кластеры.

     TCluster -  это  абстрактный тип,  используемый для реализации
зависимых и независимых кнопок.  Кластер  -  это  группа  элементов
управления, которые    реагируют   одинаково.   Кластер   элементов
управления часто ассоциируется с  объектами  TLabel,  позволяя  Вам
выбирать элемент  управления с помощью выбора метки. Дополнительные
поля: Value,  дающие определенное  пользователем  значение  и  Sel,
индексирующее выбранный  элемент управления этого кластера.  Так же
представлены методы для рисования  текстовых  кнопок  и  отмечающих
символов. Для   выбора   элементов   управления  в  кластере  могут
использоваться клавиши курсора или мышки.
     Зависимые кнопки  - это специальные кластеры,  в которых может
быть выбран только  один  элемент  управления.  Каждый  последующий
выбор отменяет текущий элемент.  Независимые кнопки - это кластеры,
в которых  может   быть   отмечено   любое   количество   элементов
управления.


#Меню.

     TMenuView и 2 его потомка TMenuBar  и  TMenuBox  предоставляют
базовые объекты  для создания выпадающих меню и подменю,  вложенных
на любой уровень.  Вы задаете  текстовые  строки  для  выбора  меню
(возможно подсвечивать   буквы   для  короткого  набора)  вместе  с
командами, связанными  с   каждым   выбором.   Методы   HandleEvent
реализуют механизм   выбора  меню  с  помощью  мышки  и  клавиатуры
(включая короткий набор и горячие клавиши).
     Выбор меню  отображается  с помощью объекта TMenuBar,  который
обычно принадлежит объекту TApplication. Выборы меню отображаются в
объектах типа TMenuBox.
     В большинстве программ Вы не вызываете напрямую  объекты меню.
Перекрывая TApplication.InitMenuBar     соответствующим     набором
вложенных вызовов New,  NewSubMenu, NewItem и NewLine, Turbo Vision
строит, отображает и взаимодействует с требуемыми меню.


#История.

     Абстрактный тип THistory реализует механизм выбора  из списка.
2 дополнительных поля Link и HistoryId дают каждый объект THistory,
ассоциированный с TInputLine,  и  идентификатор  списка  предыдущих
значений в   строке   ввода.   THistory   работает  в  сочетании  с
THistoryWindow и THistoryViewer.


#Строки ввода.

     TInputLine -  это специализированный видимый элемент,  который
предоставляет строковый редактор строки ввода.  Он обрабатывает все
обычные клавиши  управления  курсором,  удаление  и вставку.  Чтобы
отметить блок текста, может использоваться мышка.


#Просмотр списков.

     Тип объекта  TListViewer  -  это  абстрактный базовый тип,  от
которого наследуется просмотр списков различных  родов,  таких  как
TListBox. Поля   и  методы  TListViewer  позволяют  Вам  отображать
связанные списки  строк  с  управлением  одной   или   двух   полос
скроллинга. Обработчик событий  позволяет  делать  выбор  элементов
списка  мышкой  или  от клавиатуры.  Метод Draw позволяет изменение
размера и скроллинг.  TListViewer имеет абстрактный метод  GetText,
который  Вы  должны  обеспечить  механизмом  создания и манипуляции
отображаемых элементов.
     TListBox, наследуемый от TListViewer, реализует наиболее часто
используемые окна  списков,  таких  как,  например,  имена  файлов.
Объекты TListBox отображают списки таких элементов в одну или более
колонок с    дополнительной    вертикальной   полосой   скроллинга.
Горизонтальные полосы скроллинга в TListViewer  не  поддерживаются.
Наследование методов  TListViewer  позволяет  Вам  выбрать  элемент
мышкой или через клавиатуру.  TListBox  имеет  дополнительное  поле
List, указывающее  на объект TCollection.  Он предоставляет объекты
для распечатки и выбора.  Содержимое коллекции формируется Вами так
же как и действия, которые выполняются при выборе элемента.


#Объекты скроллинга.

     Объект TScroller это видимый объект  для  скроллинга,  который
действует как  ворота  в  другой больший "фоновый" видимый элемент.
Скроллинг возникает в ответ на ввод с  клавиатуры  или  действия  в
связанных объектах TScrollBar.  Скроллеры имеют два поля, HScrollId
и VScrollId,   идентифицирующих   управление    горизонтальной    и
вертикальной полосами скроллинга. Поле Delta в TScroller определяет
смещение скроллинга по X и Y вместе с полями  в  связанных  полосах
скроллинга.
     Объекты TScrollBar     обеспечивают      вертикальное      или
горизонтальное управление.   Ключевые   поля:   Value   -   позиция
индикатора полосы  скроллинга,  PgStep   -   смещение   скроллинга,
требуемое в ответ на нажатие мышки или клавиш PgUp, PgDn; ArrStep -
смещение скроллинга,  требуемое в ответ на нажатие мышки или клавиш
курсора.
     Скроллер и его полосы скроллинга  обычно  принадлежат  объекту
TWindow, что  приводит  к  сложному  набору обрабатываемых событий.
Например, изменение размера окна должно приводить к соответствующей
перерисовке скроллером.  Значения  полосы  скроллинга должны так же
изменяться и перерисовываться.


#Текстовые устройства.

     TTextDevice -  это  скользящий  TTY  тип  просмотра  текста  -
драйвера устройства. Кроме полей методов, наследуемых от TScroller,
TTеxtDevice определяет виртуальные методы для чтения и записи строк
в и из устройства.  TTextDevice используется как  базовый  тип  для
порождения реальных драйверов. TTextDevice использует констрактор и
дестрактор TScroller.
     TTerminal реализует   терминал   с  буферизованным  чтением  и
записью строк. Размер буфера определяется при инициализиции.


#Статический текст.

     Объекты TStaticText    -   это   простые   видимые   элементы,
используемые для отображения фиксированных  строк,  предоставляемых
полем Text.  Они игнорируют любые события, посланные им. Тип TLabel
добавляет видимому элементу свойства  хранения  текста,  известного
как  метка,  который  может  быть  выбран  с помощью мышки,  клавиш
курсора или короткого нажатия Alt-клавиша. Дополнительное поле Link
связывает метку  с  другим  видимым  элементом,  обычно управляемым
видимым элементом,  который обрабатывает все события  метки.  Выбор
метки выбирает  связанный  элемент  управления,  а выбор связанного
элемента управления подсвечивает метку.


#Строки статуса.

     Объект TStatusLine  предназначен  для  отображения  статуса  и
подсказок обычно в  нижней  строке  экрана.  Строка  статуса  имеет
высоту 1 символ и длину до ширины экрана.  Этот объект обеспечивает
динамическое отображение,  реагируя на события программы.  Элементы
строки статуса   можно   выбрать   мышкой   или  горячей  клавишей.
Большинство программ начинают работу становясь владельцами объектов
TMenuBar, TDeskTop  и TStatusLine.  Дополнительные поля TStatusLine
обеспечивают указатель Items и указатель Defs.
     Поле Items  указывает  на  текущий  связанный  список  записей
TStatusItem. Он содержит  отображаемые  строки,  связь  с  горячими
клавишами и  ассоциированное слово Command.  Поле Defs указывает на
связанный список записей PStatusDef,  используемый для  определения
текущей контекстной        подсказки.       TStatusLine       может
инициализироваться, используя TApplication.InitStatusLine.


#Невидимые элементы.

     Семейство невидимых   элементов,   порожденное   от   TObject,
содержит потоки, файлы ресурсов, коллекции и списки строк.


#Потоки.

     Поток -  это обобщенный объект для обработки ввода и вывода. В
традиционных устройствах  и  файлах  В/В  для  обработки  выбора  и
преобразования различных  типов  данных  должны  быть предоставлены
отдельные наборы функций.  Используя потоки Turbo Vision, Вы можете
создавать полиморфные  методы  В/В такие как Read и Write,  которые
знают как обрабатывать содержимое их потоков.
     TStream -   это  базовый  абстрактный  объект,  обеспечивающий
полиморфный В/В на и из устройства  памяти.  TStream  предоставляет
поле Status, указывающее на режим доступа (только на чтение, только
на запись,  чтение/запись), а поле ErrorInfo возвращает ошибки В/В.
Предоставлено 7 виртуальных методов:  Flush, GetPos, GetSize, Read,
Seek, Truncate и Write.  Они должны быть перекрыты  для  порождения
специализированных типов  потоков.  Вы  увидите,  что  Turbo Vision
использует эту стратегию для порождения  TDosStream,  TEmsStream  и
TBufStream. Существуют так же методы CopyFrom, Error, Get, ReadStr,
Reset, WriteStr.
     Типы объектов    должны   быть   зарегистрированы,   используя
RegisterType до  того,  как  их  можно  использовать  с   потоками.
Стандартные типы  объектов  Turbo  Vision уже зарегистрированы (см.
процедуру RegisterType в главе 14).


#Потоки DOS.

     TDosStream -   это   специализированный   поток,   реализующий
небуферизованный поток   файла   DOS.   Поле  Handle  соответствует
обычному обработчику файла DOS.  Констрактор Init создает поток DOS
с  заданным  именем файла и режимом доступа.  TDosStream определяет
все абстрактные  методы  TStream,  за  исключением  Flush,  который
требуется только для буферизованных потоков.


#Буферизованные потоки.

     TBufStream реализует  буферизованную  версию TDosStream.  Поля
Buffer и BufSize указывают положение и размер буфера. Поля BufPtr и
BufEnd определяют   текущую  и  последнюю  позицию  внутри  буфера.
Абстрактный метод TStream.Flush определен для  выталкивания буфера.
Выталкивание означает  запись  и очистку всех внутренних буферов до
закрытия потока.


#Потоки EMS.

     Наиболее специализированный поток TEmsStream реализует поток в
EMS памяти.  Новые поля содержат  обработчик  EMS,  число  страниц,
размер потока и текущую позицию внутри потока.


#Ресурсы.

     Файл ресурсов - это специальный вид потока,  в котором объекты
(элементы) могут индексироваться с помощью строковых ключей. Вместо
порождения  файла ресурсов от TStream,  TResourceFile содержит поле
Stream,  связывающее поток  с  файлом  ресурсов.  Элементы  ресурса
доступны  через вызов Get(Key),  где Key - строковый индекс.  Метод
Put сохраняет элемент  с  заданным  ключем;  метод  KeyAt  получает
индекс  данного  элемента;  Flush записывает все изменения в поток;
Delete удаляет элемент с данным ключем  и  Count  возвращает  число
элементов в файле.


#Коллекции.

     TCollection реализует  набор  элементов,  включая произвольные
объекты различных типов.  В отличие от массивов, множеств и списков
не -  ООП  языков,  коллекция  Turbo  Vision  допускает  переменный
размер. Collection   -   это    абстрактная    база    для    более
специализированных коллекций  таких как TSortedCollection.  Главное
поле - Items - указатель на  массив  элементов.  Кроме  индексации,
вставки и    удаления,    TCollection    предоставляет    несколько
итерационных программ.  Коллекция  может  быть  просканирована   от
первого или последнего элемента до нахождения условия,  заданного в
функции проверки,  определенной  пользователем.  С  помощью  метода
ForEach Вы  можете  выполнить действие,  определенное пользователем
для каждого элемента коллекции.


#Отсортированные коллекции.

     TSortedCollection реализует   коллекцию,   отсортированную  по
ключу. Сортировка определена через  виртуальный  абстрактный  метод
Compare. Следовательно Ваш порожденный тип может задавать требуемую
упорядоченность для коллекции объектов любого  типа.  Метод  Insert
добавляет элементы, поддерживая это упорядочение и ключи могут быть
быстро найдены методом двоичного поиска Search.


#Коллекция строк.

     TStringCollection -  это  простое расширение TSortedCollection
для обработки отсортированной коллекции строк Turbo  Pascal.  Метод
FreeItem удаляет  данную  строку из коллекции.  Для записи и чтения
коллекции строк из потока предоставлены виртуальные  методы PutItem
и GetItem.


#Коллекции ресурсов.

     TResourceCollection реализует    коллекцию     отсортированных
индексов ресурсов,   используя  файлы  ресурсов.  Методы  FreeItem,
GetItem, KeyOf,  PutItem типа TStringCollection  перекрываются  для
обработки ресурсов.


#Списки строк.

     TStringList реализует специальный вид  строкового  ресурса,  в
котором к строкам можно обращаться через числовой индекс, используя
метод Get.  Поле Count содержит число строк в объекте.  TStringList
упрощает многоязыковые   тектовые  программы.  Списки  строк  можно
прочитать из потока,  используя констрактор Load. Чтобы создать или
добавить в список строк, используйте TStrListMaker.
     TStringList предоставляет доступ только к существующему списку
строк с числовой индексацией. TStrListMaker предоставляет метод Put
для добавления строки в  список  строк,  а  метод  Store  сохраняет
список строк в потоке.

@ГЛАВА 4. ВИДИМЫЕ ЭЛЕМЕНТЫ.

#Видимые элементы

     Сейчас Вы должны иметь внешнее представление о работе программ
на Turbo  Vision.  Что  присходит  внутри?  Ответу  на  этот вопрос
посвящены 2 следующие главы.


#Управление экраном.

     Одно из  ограничений  при  использовании Turbo Vision касается
прямого вывода на экран.  Вместо использования Write и Writeln  для
выдачи  информации  пользователю,  Вы  передаете информацию в Turbo
Vision, который гарантирует, что информация появится в нужное время
и в нужном месте.
     Основной блок построения программ в  Turbo  Vision  -  видимый
элемент. Видимый   элемент  -  это  объект  Turbo  Pascal,  который
управляет прямоугольной областью экрана.  Например,  полоса меню на
вершине экрана  -  это видимый элемент.  Любое действие программы в
этой области экрана (например отметка мышкой в полосе  меню)  будет
обрабатываться видимым элементом, который контролирует эту область.
     Меню - это видимые элементы так же как и окна, строка статуса,
кнопки, полосы  скроллинга,  диалоговые  окна и обычно даже простая
строка текста.  В  общем  случае  все,  что  Вы  видите  на  экране
программы Turbo  Vision  должно  быть  видимым элементом и наиболее
важное свойство видимого элемента то, что он знает как представлять
себя на  экране.  Так,  например,  когда  Вы хотите сделать систему
меню, Вы просто говорите Turbo Vision, что Вы хотите создать полосу
меню, содержащую   определенные  меню,  а  Turbo  Vision  управляет
остальным.
     Наиболее зримым  примером  видимого  элемента,  о  котором Вы,
вероятно,  не будете думать как о видимом элементе,  является  сама
программа.  Она  управляет всем экраном,  но Вы не замечаете этого,
поскольку  программа  устанавливает  другие  видимые  элементы  для
управления их взаимодействий с пользователем.  Как Вы увидите,  то,
что представляется пользователю как объект (такой как  окно)  часто
является группой связанных видимых элементов.


#Простые видимые элементы.

     Как Вы видите из схемы  иерархии  на  рис.  4.6,  все  видимые
элементы Turbo  Vision  имеют TObject в качестве предка.  TObject -
это несколько более,  чем общий предок для всех объектов. Сам Turbo
Vision в действительности начинается от TView.
     TView появляется на экране просто как пустой прямоугольник. Не
имеет смысла  создавать  экземпляр TView,  если только Вы не хотите
создать пустой прямоугольник на  экране  для  прототипирования.  Но
хотя TView визуально прост,  он содержит все основные поля и методы
управления экраном Turbo Vision.
     Любой объект,  порожденный  от  TView,  должен  обладать двумя
возможностями:
     Во-первых, он  рисует  себя  в любой момент.  TView определяет
виртуальный метод Draw и каждый объект,  порожденный от TView,  так
же должен  иметь  метод  Draw.  Это важно,  поскольку часто видимый
элемент будет перекрываться другим видимым элементом и  когда  этот
другой элемент  удаляется или перемещается,  видимый элемент должен
иметь возможность показать ту часть, которая была скрыта.
     Во-вторых, он   должен   обрабатывать   все  события,  которые
приходят к нему.  Как замечено в главе 1, программы на Turbo Vision
управляются от  событий.  Это означает,  что Turbo Vision управляет
вводом от пользователя и передает  его  в  соответствующие  объекты
программы.  Видимые элементы должны знать что делать, когда события
воздействуют на них. Обработке событий посвящена глава 5.


#Установка видимого элемента.

     До обсуждения, что делает видимый элемент, давайте рассмотрим,
как видимые элементы представляются на экране.
     Положение видимого   элемента   определяется   двумя  точками:
верхним левым углом (называемым началом)  и  нижним  правым  углом.
Каждая  из  этих  точек  представлена  в  объекте полем типа TPoint
(TPoint описана в  следующем  разделе).  Поле  Origin  типа  TPoint
указывает начало видимого элемента, а поле Size представляет нижний
правый угол.
     Заметим, что  Origin - это точка в системе координат владельца
видимого элемента:  если Вы открываете окно на панели  экрана,  его
поле Origin  указывает  координаты  X  и Y окна относительно начала
панели экрана. С другой стороны, поле Size - это точка относительно
начала данного  объекта.  Оно говорит Вам как далеко отстоит нижний
правый угол от начальной точки,  но если Вы не  знаете  где  начало
видимого элемента  расположено внутри другого видимого элемента, Вы
не сможете определить где реально находится этот угол.


#Получение TPoint.

     Тип TPoint  крайне  прост.  Он  содержит только 2 поля X и Y -
коодинаты точки.  Он не  имеет  методов.  Turbo  Vision  использует
объект TPoint, чтобы позволить видимому элементу указать координаты
одним полем.


#Получение TRect.

     TPoint редко  напрямую используется в Turbo Vision.  Поскольку
каждый видимый  элемент  имеет  и  начало  и  размер,  обычно   они
обрабатываются в объекте TRect совместно.  TRect имеет 2 поля А и В
каждое типа TPoint.  Когда заданы границы  видимого  элемента,  эти
границы передаются в констрактор TRect.
     TRect и TView предоставляют полезные  методы  для  манипуляции
размером видимого   элемента.  Например,  если  Вы  хотите  создать
видимый элемент,  который заполняется только внутри окна, Вы можете
получить размер окна,  сократить его и назначить новому внутреннему
видимому элементу.

               procedure ThisWindow.MakeInside;
               var
                 R: TRect;
                 Inside: PInsideView;
               begin
                 GetExtent(R);  (* установить R в размер ThisWindow*)
                 RR.Grow(-1, -1);  (* сократить прямоугольник на 1 *)
                 Inside :=  New(PInsideView,  Init(R));  (*  создать
                                        внутренний видимый элемент*)
                 Insert(Inside); (* вставить новый видимый элемент в
                                   окно *)
               end;

     GetExtent -  это  метод TView,  который устанавливает аргумент
TRect  в  координаты  прямоугольника,  покрывающего  весь   видимый
элемент. Grow   -   это  метод  TRect,  который  увеличивает  (а  с
отрицательными параметрами уменьшает) горизонтальный и вертикальный
размеры прямоугольника.


#Координаты Turbo Vision.

     Метод Turbo Vision, назначающий коодинаты, может отличаться от
используемого Вами. Отличие заключается в том, что если большинство
координатных систем устанавливает  размер  в  символах  на  экране,
координатная система   Turbo   Vision  указывает  расстояние  между
символами.
     Например, если R - объект типа TRect,  R.Assign(0,  0,  0,  0)
назначает прямоугольник без  размера  -  только  точка.  Наименьший
прямоугольник, который может содержать что-либо, создается R.Assign
(0, 0, 1, 1).
     Рис. 4.1 показывает TRect, созданный R.Assign(2, 2, 5, 4).

           Рис. 4.1. Координатная система Turbo Vision.


               0   1   2   3   4   5   6   7
              0┌───┬───┬───┬───┬───┬───┬───┐
               │   │   │   │   │   │   │   │
              1├───┼───┼───┼───┼───┼───┼───┤
               │   │   │   │   │   │   │   │
              2├───┼───┼───┼───┼───┼───┼───┤
               │   │   │ R │ R │ R │   │   │
              3├───┼───┼───┼───┼───┼───┼───┤
               │   │   │ R │ R │ R │   │   │
              4├───┼───┼───┼───┼───┼───┼───┤
               │   │   │   │   │   │   │   │
              5└───┴───┴───┴───┴───┴───┴───┘

     Хотя эта   координатная   система  несколько  непривычна,  она
позволяет вычислять размер прямоугольника намного проще.


#Появление видимых элементов.

     Появление видимого  элемента  определяется  его  методом Draw.
Каждый новый тип  видимого  элемента  требует  собственного  метода
Draw.
     Существует правила,  которые  применяются  ко   всем   видимым
элементам. Видимый элемент должен:
     - заполнять всю область, за которую он ответственен.
     - рисовать себя в любое время.

     Эти свойства очень важны и обсуждаются далее.


#Территориальность.

     Существуют причины того,  что каждый видимый элемент  отвечает
за свою  территорию.  Видимому  элементу  назначается прямоугольная
область на экране.  Если он не заполнит всю эту область, содержимое
незаполненной области неопределено:  там может быть видно все,  что
угодно и Вы  не  сможете  управлять  этим.  Программа  TVDEMO05.PAS
демонстрирует, что случается, если видимый элемент оставляет что-то
незаполненным.


#Рисование по требованию.

     Кроме того,    видимый    элемент   должен   всегда   обладать
возможностью представить себя на экране.  Причина этого заключается
в том,  что  другие  видимые  элементы  могут закрывать часть этого
элемента, а  затем  удаляются  или  сам   видимый   элемент   может
переместиться. В  любом  случае видимый элемент должен всегда уметь
отобразить свое текущее состояние.
     Заметим, что это может означать, что видимый элемент не должен
делать вообще ничего: он может быть полностью закрыт или может даже
не присутствовать на экране или окно, содержащее этот элемент может
быть сжато  в  точку  так,  что  видимый  элемент  невидим  вообще.
Большинство из этих ситуации обрабатывается автоматически, но важно
запомнить, что Ваш видимый элемент всегда должен знать как рисовать
себя.
     Это значительно  отличается  от  других  оконных   схем,   где
например запись  в  окно  постоянна:  то,  что  Вы  написали в него
остается даже если окно удаляется.  В Turbo Vision  Вы  не  делаете
предположений, что   открывающийся   видимый   элемент   корректен,
поскольку он мог быть изменен в то время, когда был закрыт.


#Установка поведения.

     Поведение видимого   элемента   почти  полностью  определяется
методом  HandleEvent.  В  HandleEvent  передается  запись  события,
которая должна  быть  обработана  одним из двух способов.  Он может
либо выполнить некоторое действие  в  ответ  на  событие,  а  затем
пометить событие   как  обработанное  или  может  передать  событие
следующему видимому элементу (если он есть).
     Главное в  поведении  -  как  видимый  элемент  откликается на
определенное событие.  Например,  если   окно   получает   событие,
содержащее команду cmClose,  ожидается,  что окно будет закрыто. Вы
можете определить  другую  реакцию   на   эту   команду,   но   это
нежелательно. (Обработка событий обсуждается в главе 5).


#Сложные видимые элементы.

     Вы уже знаете о наиболее важном элементе, порождаемом от TView
- ТGroup.   TGroup  и  его  потомки  называются  группами.  Видимые
элементы не  наследуемые  от   TGroup,   называются   терминальными
видимыми элементами.
     Группа - это просто пустое окно,  которое содержит и управляет
другими видимыми  элементами.  Технически  - это видимый элемент и,
следовательно, отвечает за все,  что  должен  уметь  любой  видимый
элемент: управлять  прямоугольной областью экрана,  визуализировать
себя в любое время и обрабатывать события в своей  области  экрана.
Отличие в  том,  как  он реализует эти функции:  большинство из них
обрабатывается видимыми подэлементами.


#Группы и видимые подэлементы.

     Подэлемент - это видимый элемент,  который принадлежит другому
видимому элементу,  т.е.  видимый элемент (группа)  может  передать
часть своей области экрана для обработки другому видимому элементу,
называемому видимым  подэлементом,  который  будет  управлять  этой
областью.
     Наилучший пример - TApplication.  TApplication -  это  видимый
элемент, который  управляет  областью  экрана  - в действительности
всем экраном.  TApplication - это так же группа,  которая владеет 3
элементами: полосой   меню,   панелью  экрана  и  строкой  статуса.
Программа передает область экрана  каждому  из  этих  подэлементов.
Полоса меню  получает  верхнюю  строку,  строка  статуса  -  нижнюю
строку, а  панель  экрана  -  все  строки  между  ними.  Рис.   4.2
показывает типичный экран TApplication.

                   Рис. 4.2. Экран TApplication.

          ┌──────────────────────────────────────┐
          │  Строка меню                         │
          ├──────────────────────────────────────┤
          │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
          │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
          │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
          │░░░DeskTop░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
          │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
          │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
          ├──────────────────────────────────────┤
          │  Строка статуса                      │
          └──────────────────────────────────────┘

     Заметим, что сама программа не имеет представления экрана - Вы
не видите   программы.   Ее  появление  полностью  определяется  ее
видимыми элементами.


#Получение группы.

     Как подэлементы   присоединяются   к   группе?   Этот  процесс
называется вставкой.  Видимые   подэлементы   создаются   и   затем
вставляются    в   группу.   В   предыдущем   примере   констрактор
TApplication.Init создает 3 объекта и вставляет их в программу:

               InitDeskTop;
               InitStatusLine;
               InitMenuBar;
               if DeskTop <> nil then Insert(DeskTop);
               if StatusLine <> nil  then Insert(StatusLine);
               if MenuBar <> nil then Insert(MenuBar);

     В данном  случае  TApplication делит свою область на 3 части и
передает каждую  из  них   подэлементам.   Это   упрощает   видимое
представление, поскольку видимые подэлементы не перекрываются.
     Однако одним из наибольших достижений оконной  среды  является
возможность иметь  множество перекрывающихся окон на панели экрана.
Группы (включая   панель    экрана)    знают    как    обрабатывать
перекрывающиеся подэлементы.
     Группа хранит  порядок  вставки  подэлементов.  Этот   порядок
соответствует порядку   Z.   Как   Вы   увидите,   Z-упорядочивание
определяет порядок,  в котором подэлементы рисуются  и  порядок,  в
котором события передаются в них.


#Другой взгляд на Z-упорядочивание.

     Термин Z-упорядочивание ссылается  к  факту,  что  подэлементы
имеют 3-мерные  взаимосвязи.  Как  Вы  уже  видели,  каждый видимый
элемент имеет позицию и размер,  определяемые полями Origin и Size.
Но видимые  элементы  и подэлементы могут перекрываться и для того,
чтобы Turbo Vision  знал  какой  видимый  элемент  находится  перед
другими видимыми элементами, мы добавляем третью координату Z.
     Так же Z-упорядочивание относится  к  порядку,  в  котором  Вы
встречаете видимые  элементы,  когда  Вы  ищете  ближайший  к  Вам.
Последний вставленный видимый элемент - это ближайший к Вам.
     Удобно рассматривать  видимые элементы как стеклянные панели в
трехмерном пространстве, как показано на рис.4.3.

           Рис. 4.3. Трехмерный образ видимых элементов.


            ┌──────────────────────┐
            │                      │
            │   ┌──────────────────┼───┐
            │   │                  │   │ 
            │   │                  │   ╞═▒═[■]═╗
            │   │                  │   │ ▒     ║
TWindow ───Ў└───┼──────────────────┘   │ ▒     ║
                │  This is some text   │ ▒     ║
  TScroller ───Ў└───╥──────────────────┘ ■     ║
                    ║                    ▒     ║
   TScrollbar ───Ў  ▒■▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒       ║
         TFrame ───Ў╚══════════════════════════┘


     Само окно  - это просто стеклянная панель,  закрывающая группу
видимых элементов.  Поскольку все,  что Вы видите  -  это  проекция
видимых элементов  на экран,  Вы не видите,  какие видимые элементы
находятся ближе, чем другие, если они не перекрываются.
     По умолчанию  окно имеет рамку,  которая вставляется до любого
другого подэлемента. Следовательно это фоновый видимый элемент. При
создании интерьера   скроллинга  2  полосы  скроллинга  перекрывают
рамку. Для Вас при взгляде сверху они смотрятся как часть рамки, но
при взгляде   со   стороны   Вы   можете   увидеть,   что   они   в
действительности лежат выше рамки.
     Наконец, вставляется  скроллер,  прикрывая  всю область внутри
рамки. Текст пишется в скроллере, а не в окне, но Вы можете увидеть
его, когда смотрите в окно.
     При большем масштабе  Вы  можете  увидеть  панель  экрана  как
большую стеклянную панель,  закрывающую более мелкие элементы,  как
показано на рис. 4.4.

             Рис. 4.4. Трехмерный образ панели экрана.


             ┌──────────────────────┐
             │                      │
             │   ┌──────────────────┼───────┐
             │   │                  │       │
             │   │  ┌─────┐         │       │
             │   │  │▒▒▒▒▒│         │       │
TDesktop ───Ў└───┼──┼─────┼─────────┘       │
                 │  │▒▒▒▒▒│                 │
 TWindow ───Ў    │  └─────┘                 │
                 │                          │
 TBackground ───Ў└──────────────────────────┘


     И опять,  группа (на этот раз панель экрана) - это  панель  из
стекла. Ее  первый  подэлемент  -  это объект TBackGround,  который
находится на самом низу. Так же видно окно на панели экрана.

#Групповые портреты.

     Группа -  это  исключение  из  правила,  что  видимые элементы
должны знать как рисовать себя,  поскольку группа не  рисует  себя.
Скорее TGroup просит свои подэлементы, чтобы они нарисовали себя.
     Подэлементы вызываются для прорисовки в Z  порядке, означающем
что первый подэлемент, вставленный в группу, рисуется первым. Таким
образом, если подэлементы перекрываются,  то вставленный  последним
рисуется над другими.
     Подэлементы, принадлежащие группе,  должны совместно закрывать
всю область,  управляемую группой.  Например, диалоговое окно - это
группа и его подэлементы - рамка,  интерьер,  элементы управления и
статический текст  должны  полностью  накрывать область диалогового
окна. Иначе  в  диалоговом  окне   будут   появляться   "дырки"   с
непредсказуемыми (и неприятными) результатами.
     Когда видимые  подэлементы  группы  рисуют  себя,   их   вывод
автоматически отсекается по границам группы.  Поскольку подэлементы
отсекаются, когда Вы инициализируете видимый  элемент  и  передаете
его в  группу,  необходимо,  чтобы видимый элемент хотя бы частично
размещался внутри границ  группы.  (Вы  можете  отодвинуть  окно  с
панели экрана  только  если  один угол остается видимым.) Только та
часть подэлемента,  которая находится внутри границ ее группы будет
визуализироваться.
      Как панель  экрана  получает  видимый  фон?   Во   время   ее
инициализации панель  экрана создает и владеет видимым подэлементом
TBackGround, чье  назначение  заливать  весь  экран  цветом   фона.
Поскольку фон  -  первый  вставленный  подэлемент,  он  закрывается
другими видимыми подэлементами, рисуемыми над ним.


#Взаимосвязи между видимыми элементами.

     Видимые элементы   связаны   двумя   способами:  они  элементы
иерархии объектов  Turbo  Vision  и  они  элементы  дерева  видимых
элементов. Когда  Вы  начинаете  работать  в  Turbo  Vision,  важно
помнить это различие.
     Например, рассмотрим простое диалоговое окно на рис.  4.5. Оно
имеет рамку,  одну строку текста и одну кнопку,  которая  закрывает
диалоговое окно.  В  терминах  Turbo  Vision  - это видимый элемент
TDialog, который владеет TFrame, TStaticText и TButton.

                Рис. 4.5. Простое диалоговое окно.

             ╔═[■]═════ Sample dialog box  ═══════════╗
             ║                                        ║
             ║   This is a dialog box text message    ║
             ║                                        ║
             ║                      OK   ▄            ║
             ║                    ▀▀▀▀▀▀▀▀            ║
             ╚════════════════════════════════════════╝


                        Иерархия объектов.

     Один из  способов взаимосвязи видимых элементов - это родители
и дети в иерархии объектов.  Заметьте,  что TButton в иерархической
диаграмме на рис. 4.6 порожден от типа TView и имеет дополнительные
поля и методы,  которые делают его кнопкой. TDialog так же порожден
от TView  (через  TGroup и TWindow) и имеет много общего с TButton.
Это двоюродные братья в иерархии Turbo Vision.

             Рис. 4.6. Иерархия объектов Turbo Vision.


TObject─┬─TCollection───TSortedCollection──TStringCollection
        ├─TResourceFile                       └─TResourceCollection
        ├─TStream─────┬─TEmsStream
        ├─TStringList └─TDosStream──────TBufStream
        ├─TStrListMaker
        └─TView───────┬─TCluster──────┬─TCheckBoxes
          -----       ├─TFrame        └─TRadioButtons
                      ├─TGroup────────┬─TDeskTop
                      ├─TBackGround   ├─TProgram────TApplication
                      ├─TButton       └─TWindow───┬─THistoryWindow
                      │ -------                   └─TDialog
                      ├─TStaticText───┬─TLabel      -------
                      ├─THistory      └─TParamText
                      ├─TListViewer───┬─THistoryViewer
                      ├─TInputLine    └─TListBox
                      ├─TMenuView─────┬─TMenuBar
                      ├─TScrollBar    └─TMenuBox
                      ├─TScroller────────TTextDevice──TTerminal
                      └─TStatusLine



#Принадлежность.

     Другой способ  взаимосвязи  видимых элементов - дерево видимых
элементов. В диаграмме дерева видимых элементов (рис. 4.7.) TDialog
владеет типом  TButton.  Здесь  взаимосвязь не между иерархическими
типами объектов (TDialog не является  предком  TButton!),  а  между
экземплярами объектов, между владельцем и подэлементами.

   Рис. 4.7. Дерево видимых элементов простого диалогового окна.

                        ┌──────────┐
                        │ TDialog  │
                        └─┬───┬───┬┘
                  ┌───────┘   │   └───────┐
              ┌───┴────┐┌─────┴───┐┌──────┴──────┐
              │ TFrame ││ TButton ││ TStaticText │
              └────────┘└─────────┘└─────────────┘

     Вам необходимо,   чтобы   TButton   взаимодействовал   с   его
владельцем в дереве элементов (TDialog) и  TButton  будет  рисовать
атрибуты, наследованные  от  своего предка (TView).  Не путайте эти
взаимосвязи.
     Выполнение программы   на   Turbo   Vision  подобно  дереву  с
созданием экземпляров  видимых  элементов   и   владением   другими
видимыми элементами.  Когда  программа  открывает и закрывает окна,
дерево видимых  элементов  растет  и  уменьшается  при  вставке   и
удалении экземпляров  объектов.  С другой стороны иерархия объектов
только растет,  когда  Вы  производите   новый   тип   объекта   от
стандартного объекта.


#Подэлементы и дерево видимых элементов.

     Как сказано раньше,  видимый элемент  TApplication  владеет  и
управляет тремя подэлементами, созданными им. Вы можете представить
эту взаимосвязь  как   формирование   дерева   видимых   элементов.
Application - это ствол,  а MenuBar, DeskTop и StatusLine формируют
ветви, как показано на рис. 4.8.

     Рис. 4.8. Основное дерево видимых элементов Turbo Vision.

                        ┌─────────────┐
                        │ Application │
                        └──┬──┬───┬───┘
                  ┌────────┘  │   └───────┐
              ┌───┴─────┐┌────┴────┐┌─────┴──────┐
              │ MenuBar ││ DeskTop ││ StatusLine │
              └─────────┘└─────────┘└────────────┘

     Запомните, что взаимосвязи,  показанные на рис.  4.8. - это не
иерархия объектов,   а  модель  структуры  данных.  Связи  отражают
принадлежность, а не наследование.
     В типичной  программе,  когда пользователь отмечает мышкой или
использует клавиатуру,  он  создает  новые  видимые  элементы.  Эти
видимые элементы будут появляться на панели экрана,  формируя новые
ветви дерева.
     Важно понимать взаимосвязи между владельцами и подэлементами и
как появление и поведение видимого элемента зависит  от  того,  кто
владеет видимым элементом.
     Рассмотрим пример.  Пусть пользователь отмечает элемент  меню,
который вызывает  окно просмотра файла.  Окно просмотра файла будет
видимым элементом.  Turbo Vision создает окно и присоединяет его  к
панели экрана.
     Окно будет владеть рядом подэлементов:  TFrame -  рамка  окна,
TScroller -   содержит  массив  текста  и  TScrollBar.  Когда  окно
вызывается, оно создает, владеет и управляет подэлементами.
     К Вашей  растущей программе подключены новые видимые элементы,
как показано на рис. 4.9.

           Рис. 4.9. Панель экрана с просмотром файлов.

          ┌────────────────────────────────────────────────┐
          │  Строка меню                                   │
          ├────────────────────────────────────────────────┤
          │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
          │░░╔═[■]═══ File Viewer Window ══1═[]═╗ ░░░░░░░░│
          │░░║                                    ░░░░░░░░│
          │░░║                                   ▒ ░░░░░░░░│
          │░░║  File text                        ▒ ░░░░░░░░│
          │░░║                                   ▒ ░░░░░░░░│
          │░░║                                   ■ ░░░░░░░░│
          │░░║                                   ▒ ░░░░░░░░│
          │░░║                                    ░░░░░░░░│
          │░░╚══════════▒■▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒══════┘ ░░░░░░░░│
          │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
          ├────────────────────────────────────────────────┤
          │  Строка статусa                                │
          └────────────────────────────────────────────────┘

     Дерево видимых  элементов  становится   более   сложным,   как
показано на рис. 4.10.

      Рис. 4.10. Дерево видимых элементов с просмотром файла.

                        ┌─────────────┐
                        │ Application │
                        └──┬──┬───┬───┘
                  ┌────────┘  │   └───────┐
              ┌───┴─────┐┌────┴────┐┌─────┴──────┐
              │ MenuBar ││ DeskTop ││ StatusLine │
              └─────────┘└────┬────┘└────────────┘
                         ┌────┴───┐
                         │ Window │
                         └┬─┬──┬─┬┘
                    ┌─────┘ │  │ └──────┐
               ┌────┴──┐    │  │    ┌───┴──────┐
               │ Frame │    │  │    │ Scroller │
               └───────┘    │  │    └──────────┘
                         ┌──┘  └──┐
               ┌─────────┴──┐  ┌──┴─────────┐
               │ Scroll Bar │  │ Scroll Bar │
               └────────────┘  └────────────┘

     Теперь предположим,  что пользователь отметил тот  же  элемент
меню и  создал  другое окно просмотра файлов.  Turbo Vision создает
второе окно и присоединяет его к панели  экрана,  как  показано  на
рис. 4.11.

           Рис. 4.11. Панель экрана с просмотром файла.

       ┌────────────────────────────────────────────────────┐
       │  Строка меню                                       │
       ├────────────────────────────────────────────────────┤
       │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
       │░░╔═══════ File Viewer Window ══1═════╗░░░░░░░░░░░░░│
       │░░║                                   ░░░░░░░░░░░░░│
       │░░║         ╔═[■]═══ File Viewer Window ══2═[]═╗░░░│
       │░░║  File te║                                   ░░░│
       │░░║         ║                                   ▒░░░│
       │░░║         ║  File text                        ▒░░░│
       │░░║         ║                                   ▒░░░│
       │░░║         ║                                   ■░░░│
       │░░╚═════════║                                   ▒░░░│
       │░░░░░░░░░░░░║                                   ░░░│
       │░░░░░░░░░░░░╚══════════▒■▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒══════┘░░░│
       │░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
       ├────────────────────────────────────────────────────┤
       │  Строка статусa                                    │
       └────────────────────────────────────────────────────┘

     Дерево видимых  элементов  становится  еще более сложным,  как
показано на рис. 4.12.

      Рис. 4.12. Дерево видимых элементов с просмотром файла.

                        ┌─────────────┐
                        │ Application │
                        └──┬──┬───┬───┘
                  ┌────────┘  │   └───────┐
              ┌───┴─────┐┌────┴────┐┌─────┴──────┐
              │ MenuBar ││ DeskTop ││ StatusLine │
              └─────────┘└──┬───┬──┘└────────────┘
                ┌───────────┘   └─────────────────┐
           ┌────┴───┐                        ┌────┴───┐
           │ Window │                        │ Window │
           └┬─┬──┬─┬┘                        └┬─┬──┬─┬┘
      ┌─────┘ │  │ └─────┐              ┌─────┘ │  │ └─────┐
 ┌────┴──┐    │  │   ┌───┴──────┐  ┌────┴──┐    │  │   ┌───┴──────┐
 │ Frame │    │  │   │ Scroller │  │ Frame │    │  │   │ Scroller │
 └───────┘    │  │   └──────────┘  └───────┘    │  │   └──────────┘
           ┌──┘  └──┐                        ┌──┘  └──┐
 ┌─────────┴──┐  ┌──┴─────────┐    ┌─────────┴──┐  ┌──┴─────────┐
 │ Scroll Bar │  │ Scroll Bar │    │ Scroll Bar │  │ Scroll Bar │
 └────────────┘  └────────────┘    └────────────┘  └────────────┘

     Как Вы увидите в главе 5,  управление  программы  проходит  по
дереву видимых элементов.  В предыдущем примере предположим, что Вы
отметили полосу скроллинга в окне  просмотра  файла.  Как  сделать,
чтобы это действие обрабатывалось в нужном месте?
     Программа Application видит отметку мышкой,  обнаруживает, что
она находится в области, управляемой панелью экрана и передает ее в
объект "панель экрана".  Панель экрана видит,  что  отметка  внутри
области, управляемой  просмотром файла и передает ее в этот видимый
элемент. Просмотр файла видит, что отметка была в полосе скроллинга
и позволяет   видимому   элементу  "полоса  скроллинга"  обработать
отметку, генерируя соответствующий отклик.
     Действительный механизм  этой  обработки  не  важен  в  данный
момент. Сейчас важно  понять  как  связаны  видимые  элементы.  Вне
зависимости от сложности структуры,  все видимые элементы связаны с
объектом Вашей программы.  (Обработка событий объяснена в главе 5).
Если пользователь  отметил  закрывающую  кнопку во втором просмотре
файла, или  элемент  меню  Close  Window, второй   просмотр   файла
закрывается. Turbo  Vision отключает его в дереве видимых элементов
и уничтожает.  Окно будет  освобождать  все  подэлементы,  а  затем
уничтожает себя.
     Вероятно пользователь будет удалять видимые элементы,  пока не
достигнет начальной  позиции и укажет,  что он закочил работу нажав
Alt-X или  выбрав  Exit  из   меню.   TApplication   удаляет   свои
подэлементы, а затем удаляет себя.


#Выбор и активизация видимых элементов.

     Внутри любой группы видимых элементов может быть выбран один и
только один    подэлемент.    Например,    когда   Ваша   программа
устанавливает полосу меню,  панель экрана и строку статуса,  панель
экрана - выбранный видимый элемент и вся работа будет происходить в
нем.
     Когда Вы  открыли  на панели экрана несколько окон,  выбранное
окно это окно с которым Вы работаете в  данный  момент.  Оно  также
называется активным окном (обычно самое верхнее окно).
     Внутри активного окна выбранный подэлемент называется активным
видимым элементом.  Вы  можете  думать об активном видимом элементе
как об  элементе   на   который   Вы   смотрите   или   с   которым
взаимодействуете. (Активный   видимый  элемент  находится  в  конце
цепочки выбранных элементов,  которая начинается от  программы).  В
окне редактора  активный видимый элемент будет интерьером с текстом
внутри него.  В диалоговом окне активный элемент  это  подсвеченный
элемент управления.
     В диаграмме  программы  на  рисунке   4.12   Application   это
модальный видимый элемент, а DeskTop его выбранный видимый элемент.
Внутри панели экрана второе (последнее вставленное) окно  выбрано и
следовательно активно. Внутри этого окна выбран интерьер скроллинга
и поскольку это терминальный  видимый  элемент  (т.е.  не  является
группой), он  находится в конце цепочки - является активным видимым
элементом. Рис.  4.13 показывает то же дерево видимых  элементов  с
цепочкой активных элементов, выделенных двойной рамкой.


                   Рис. 4.13. Активная цепочка.

                        ┌─────────────┐
                        │ Application │
                        └──┬──┬───┬───┘
                  ┌────────┘  │   └───────┐
              ┌───┴─────┐╔════╧════╗┌─────┴──────┐
              │ MenuBar │║ DeskTop ║│ StatusLine │
              └─────────┘╚══╤═══╤══╝└────────────┘
                ┌───────────┘   └─────────────────┐
           ┌────┴───┐                        ╔════╧═══╗
           │ Window │                        ║ Window ║
           └┬─┬──┬─┬┘                        ╚╤═╤══╤═╤╝
      ┌─────┘ │  │ └─────┐              ┌─────┘ │  │ └─────┐
 ┌────┴──┐    │  │   ┌───┴──────┐  ┌────┴──┐    │  │   ╔═══╧══════╗
 │ Frame │    │  │   │ Scroller │  │ Frame │    │  │   ║ Scroller ║
 └───────┘    │  │   └──────────┘  └───────┘    │  │   ╚══════════╝
           ┌──┘  └──┐                        ┌──┘  └──┐
 ┌─────────┴──┐  ┌──┴─────────┐    ┌─────────┴──┐  ┌──┴─────────┐
 │ Scroll Bar │  │ Scroll Bar │    │ Scroll Bar │  │ Scroll Bar │
 └────────────┘  └────────────┘    └────────────┘  └────────────┘

     Кроме всего прочего,  информация об активном видимом  элементе
говорит Вам какой видимый элемент получит информацию от клавиатуры.
Для дополнительной информации смотри раздел по активным  событиям в
главе 5.


#Нахождение активного элемента.

     Активный видимый  элемент  обычно  подсвечивается  на  экране.
Например, если Вы открыли на панели экрана несколько окон, активное
окно окружено  двойной  рамкой,  а  остальные   одинарной.   Внутри
диалогового окна  активный элемент управления (а элемент управления
это тоже видимый элемент) ярче других, указывая на то, что он будет
действовать когда   Вы   нажмете   Enter.   Т.е.  активный  элемент
управления также является элементом управления  по  умолчанию.  (На
монохромных  мониторах  Turbo  Vision добавляет символы стрелок для
указания активного элемента).


#Как сделать видимый элемент активным?

     Видимый элемент  можно  сделать активным двумя способами,  или
по умолчанию при его создании, или через действие пользователя.
     Когда создается  группа  видимых элементов,  владеющий видимый
элемент указывает какой из его подэлементов будет активным, вызывая
метод Select  этого подэлемента.  Так устанавливается активность по
умолчанию.
     Пользователю может  потребоваться  изменить  текущий  активный
видимый элемент.  Можно сделать это,  отметив мышкой другой видимый
элемент. Например, если на панели экрана открыто несколько окон, Вы
можете выбрать другое окно просто отметив его. В диалоговом окне Вы
можете переместить   активность,   нажав  Tab,  который  циклически
обходит все доступные видимые элементы или отметив мышкой требуемый
видимый элемент или нажав горячую клавишу.
     Заметим что существуют видимые элементы, которые не могут быть
выбраны - фон панели экрана,  рамки окон и полосы скроллинга. Когда
Вы создаете видимый элемент Вы можете указать будет ли этот элемент
выбираемым, после чего видимый элемент определяет,  остаться ли ему
выбираемым. Если Вы отметили рамку окна,  рамка не станет активной,
поскольку рамка  знает  что  она  не  может  быт  активным  видимым
элементом.


#Цепочка активности.

     Если Вы  начнете  с  главной  программы  и  проследите  все ее
выбранные подэлементы,  переходя к каждому последующему  выбранному
подэлементу, Вы  дойдете  до  активного видимого элемента.  Цепочка
видимых элементов,  начиная от объекта TApplication и до  активного
видимого элемента,  называется активной цепочкой.  Активная цепочка
используется для обработки  активных  событий,  таких  как  нажатае
клавиш. (См. главу 5 для полного объяснения).


#Модальные видимые элементы.

     Режим (модальность) это способ действия  или функционирования.
Программа может   иметь   несколько   режимов   действия,  особенно
различающимися для  различных  функций  управления   или   областей
управления. Например,  интегрированная  среда  Turbo  Pascal  имеет
режимы редактирования,  отладки,   компиляции   и   выполнения.   В
зависимости от   того   какой  из  этих  режимов  активен,  клавиши
клавиатуры могут приводить к различным действиям  (  или  не  иметь
действия вообще).
     Видимый элемент Turbo Vision может определять режим действия и
называется в  этом случае модальным видимым элементом. Классический
пример модального видимого элемента - диалоговое окно. Обычно когда
диалоговое окно активно,  за его пределами ничего не функционирует.
Вы не можете использовать меню  и  другие  элементы  управления  не
принадлежащие диалоговому   окну,  кроме  того  отметка  мышкой  за
пределами диалогового окна не имеет действия.  Управление находится
внутри диалогового   окна   до  тех  пор  пока  оно  не  закроется.
(Некоторые диалоговые окна не модальные, но это редкое исключение).
     Когда Вы  создаете  экземпляр  видимого элемента и делаете его
модальным, только этот видимый  элемент  и  его  подэлементы  могут
взаимодействовать с пользователем.  Вы можете представить модальный
видимый элемент как определение (сферы действия) в Вашей программе.
Когда Вы   создаете  блок  в  программе  Turbo  Pascal  (такой  как
процедуру или функцию),  идентификаторы,  объявленные внутри  этого
блока, действительны   только   внутри   этого  блока.  Аналогично,
модальный видимый элемент определяет что  функционирование доступно
внутри него  -  события  обрабатываются  только  модальным  видимым
элементом и  его  подэлементами.   Любая   часть   дерева   видимых
элементов,  не  являющаяся модальным элементом или не принадлежащая
модальному элементу, не активна.
     Существует одно  исключение  из  этого  правила  -  это строка
статуса. (Строка  статуса  всегда   "горячая",   вне   зависимости,
является ли  видимый  элемент  модальным).  Turbo  Vision сохраняет
строку статуса все время активной.  Таким образом,  Вы можете иметь
активные элементы  строки  статуса  даже  когда  в  Вашей программе
выполняется модальное диалоговое окно,  которое не владеет  строкой
статуса. Однако  события  и команды,  генерируемые строкой статуса,
обрабатываются как если бы  они  генерировались  внутри  модального
видимого элемента.
     Всегда существует модальный  видимый  элемент  при  выполнении
программы на  Turbo  Vision.  Когда Вы запускаете программу и часто
для работы программы сама прикладная программа  является  модальным
видимым  элементом  -  объект TApplication,  находящийся на вершине
дерева видимых элементов.


#Модификация поведения видимых элементов.

     До этого  момента Вы видели как ведут себя стандартные видимые
элементы по умолчанию.  Но иногда Вам  потребуется,  чтобы  видимые
элементы выглядели  или  действовали  несколько  по-другому и Turbo
Vision предоставляет  такую  возможность.  Этот  раздел   объясняет
способы модификации стандартных видимых элементов.
     Каждый видимый элемент Turbo  Vision  имеет  4  поля,  которые
можно использовать для изменения поведения этого элемента. 3 из них
описаны здесь:  слово  Options,  байт  GrowMode  и  байт  DragMode.
Четвертое поле - слово EventMask описано в главе 5.
     Существует так же слово State, содержащее информацию о текущем
состоянии видимого  элемента.  В  отличие  от  других  полей  State
используется только для  чтения.  Его  значение  должно  изменяться
только методом  SetState.  Для дополнительных деталей смотри раздел
"Флаг State и SetState".


#Флаг Options.

     Options - это переменная типа слово в каждом видимом элементе.
Различные потомки  TView  имеют  различную  установку  Options   по
умолчанию.
     Биты Options определены на рисунке 4.14.

                  Рис. 4.14. Биты флагов Options.


       ┌──────── TView.Options ────────┐
       msb                           lsb
                    ┌─┬─────────────────── ofCentered
       ╔═╤═╤═╤═╤═╤═╤╧╤╧╤═╤═╤═╤═╤═╤═╤═╤═╗
       ╚╤╧═╧═╧═╧═╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╝
        └────┬────┘ │ │ │ │ │ │ │ │ │ └─── ofSelectable
             │      │ │ │ │ │ │ │ │ └───── ofTopSelect
       Неопределены │ │ │ │ │ │ │ └─────── ofFirstClick
                    │ │ │ │ │ │ └───────── ofFramed
                    │ │ │ │ │ └─────────── ofPreProcess
                    │ │ │ │ └───────────── ofPostProcess
                    │ │ │ └─────────────── ofBuffered
                    │ │ └───────────────── ofTileable
                    │ └─────────────────── ofCenterX
                    └───────────────────── ofCenterY


     ofSelectable
     Если установлен,  пользователь  может  выбрать видимый элемент
мышкой. Если видимый элемент - группа,  пользователь может  выбрать
его мышкой  или  клавишей  Tab.  Если  Вы  поместили на экран чисто
информационный элемент, Вам может потребоваться, чтобы пользователь
не мог выбрать его.  Так например,  статические текстовые объекты и
рамки окон обычно не выбираемые.

     ofTopSelect
     Видимый элемент будет передвигаться наверх других подэлементов
владельца, если он выбран.  Эта опция в основном  используется  для
окон на  панели  экрана.  Вы  не должны использовать ее для видимых
элементов в группе.

     ofFirstClick
     Отметка мышкой,  которая выбирает видимый элемент,  передается
этому видимому  элементу.  Если  кнопка  отмечена,  Вы  определенно
хотите обработать    выбранную   кнопку,   поэтому   кнопка   имеет
ofFirstClick установленным.  Но если пользователь отмечает окно, Вы
можете хотеть  или  не  хотеть,  чтобы  окно  откликалось  на выбор
мышкой.

     ofFramed
     Если установлен,  видимый  элемент  имеет  видимую рамку.  Это
полезно, если Вы создаете несколько панелей внутри окна.

     ofPreProcess
     Если установлен,   позволяет  видимому  элементу  обрабатывать
активные события до того,  как активный видимый элемент увидит  их.
См. раздел "Фаза" в главе 5.

     ofPostProcess
     Если установлен,  позволяет  видимому  элементу   обрабатывать
активные события после того,  как они были увидены активным видимым
элементом при условии,  что активный видимый  элоемент  не  очистил
событие. См. раздел "Фаза" в главе 5.

     ofBuffered
     Когда этот бит установлен, группа может ускорять свой вывод на
экран. Когда    группа    впервые   запрашивает   прорисовку,   она
автоматически сохраняет  свой  образ  в  буфере,  если   этот   бит
установлен и   если   доступно  достаточное  количество  памяти.  В
следующий раз,  когда группа запрашивает прорисовку,  она  копирует
образ из буфера на экран вместо прорисовки всех своих подэлементов.
Если вызовы New или GetMem  приводят  к  нехватке  памяти,  монитор
памяти Turbo  Vision  начнет  освобождать  буфера групп до тех пор,
пока запрос не сможет быть выполнен.
     Если группа  имеет  буфер,  вызов Lock будет останавливать все
записи группы на экран до тех  пор,  пока  не  будет  вызван  метод
UnLock. Когда  UnLock вызывается,  буфер группы выводится на экран.
Блокирование уменьшает  мерцание  во  время  сложных  корректировок
экрана. Например,  панель  экрана блокирует себя когда выводит свои
подэлементы каскадом или черепицей.

     ofTileable
     Панель экрана  может  располагать  окна каскадом или черепицей
когда они открываются.  Если Вы не хотите, чтобы окна располагались
черепицей, Вы  можете  очистить  этот бит.  Окно останется в той же
позиции в  то  время,  когда  остальные  окна  будут  автоматически
располагаться черепицей.  Расположение  видимых элементов черепицей
или каскадом выполняется в TApplication.HandleEvent очень просто:

     cmTile:
       begin
         DeskTop^.GetExtent(R);
         DeskTop^.Tile(R);
       end;
     cmCascade:
       begin
         DeskTop^.GetExtent(R);
         DeskTop^.Cascade(R);
       end;

     Если более  2  видимых элементов успешно расположены каскадом,
панель экрана не будет делать ничего.

     ofCenterX
     Когда видимый   элемент   вставляется   в  группу,  его  центр
находится в координате Х.

     ofCenterY
     Когда видимый   элемент   вставляется   в  группу,  его  центр
находится в координате Y. Это может быть важно при разработке окон,
которые  должны  хорошо  работать  в  25  и  43-строчном  текстовых
режимах.

     ofCentered
     Центр видимого  элемента находится в координатах X и Y,  когда
он вставляется в группу.


#Флаг GrowMode.

     Поле видимого  элемента  GrowMode  определяет  как  изменяется
видимый элемент, когда его владелец группы изменяет размер.
     Биты GrowMode определены следующимм образом:

                 Рис. 4.15. Биты флагов GrowMode.


               ┌─── GrowMode ──┐
               msb           lsb
                        ┌─┬─┬─┬─── gfGrowAll
               ╔═╤═╤═╤═╤╧╤╧╤╧╤╧╗
               ╚╤╧═╧╤╧╤╧╤╧╤╧╤╧╤╝
                └─┬─┘ │ │ │ │ └─── gfGrowLoX
                  │   │ │ │ └───── gfGrowLoY
          Неопределены│ │ └─────── gfGrowHiX
                      │ └───────── gfGrowHiY
                      └─────────── gfGrowRel


     gfGrowLoX
     Если установлен,   левая   сторона   видимого  элемента  будет
поддерживать постоянное расстояние от левой стороны его владельца.

     gfGrowLoY
     Если установлен,  вершина видимого элемента будет поддерживать
постоянное расстояние от вершины его владельца.

     gfGrowHiX
     Если установлен,   правая   сторона  видимого  элемента  будет
поддерживать постоянное расстояние от правой стороны его владельца.

     gfGrowHiY
     Если установлен,   нижняя   граница  видимого  элемента  будет
поддерживать постоянное расстояние от нижней границы его владельца.

     gfGrowAll
     Если установлен,   видимый   элемент  всегда  остается  одного
размера  и  будет  передвигаться  вместе  с  нижним  правым   углом
владельца.

     gfGrowRel
     Если установлен,  видимый  элемент  будет  поддерживать   свой
размер относительно  размера владельца.  Вы должны использовать эту
опцию только с TWindow (или с  наследниками  от  TWindow),  которые
присоединяются к   панели   экрана.   Окна  будут  поддерживать  их
относительный размер когда пользователь переключает программу между
25- и  43/50  строчным  режимом.  Этот  флаг  не  предназначен  для
использования с видимыми элементами внутри окна.


#Флаг DragMode.

     Поле DragMode  размером  в  байт  определяет  как  ведет  себя
видимый элемент при перемещении.
     Биты DragMode определены:

                 Рис. 4.16. Биты флагов DragMode.

               ┌─── DragMode ──┐
               msb           lsb
                ┌─┬─┬─┬─────────── dmLimitAll
               ╔╧╤╧╤╧╤╧╤═╤═╤═╤═╗
               ╚╤╧╤╧╤╧╤╧═╧═╧╤╧╤╝
                │ │ │ │     │ └─── dmDragMove
                │ │ │ │     └───── dmDragGrow
                │ │ │ └─────────── dmLimitLoX
                │ │ └───────────── dmLimitLoY
                │ └─────────────── dmLimitHiX
                └───────────────── dmLimitHiY

     dmDragMove
     Когда этот бит установлен и когда Вы отмечаете  вершину  рамки
окна, Вы можете перемещать окно.

     dmDragGrow
     Когда этот  бит  установлен,  видимый   элемент   может   быть
увеличен.

     dmLimitLoX
     Если установлен,  левая сторона  видимого  элемента  не  может
выходить за своего владельца.

     dmLimitLoY
     Если установлен,  вершина видимого элемента не может  выходить
за своего владельца.

     dmLimitHiX
     Если установлен,  правая сторона видимого  элемента  не  может
выходить за своего владельца.

     dmLimitHiY
     Если установлен,  нижняя граница видимого  элемента  не  может
выходить за своего владельца.

     dmLimitAll
     Если установлен,  ни одна часть  видимого  элемента  не  может
выходить за своего владельца.


#Флаг State и SetState.

     Видимый элемент так же содержит  флаг  State,  который  хранит
различные аспекты  видимого  элемента,  такие  как  его  видимость,
запрещение и возможность перемещения.
     Биты флага State определены на рис. 4.17.

                    Рис.4.17. Биты флага State.

       ┌────── TView.State Flags ──────┐
       msb                           lsb
       ╔═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╤═╗
       ╚═╧═╧═╧═╧╤╧═╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╝
                │   │ │ │ │ │ │ │ │ │ └─── sfVisible   = $0001
                │   │ │ │ │ │ │ │ │ └───── sfCursorVis = $0002
                │   │ │ │ │ │ │ │ └─────── sfCursorIns = $0004
                │   │ │ │ │ │ │ └───────── sfShadow    = $0008
                │   │ │ │ │ │ └─────────── sfActive    = $0010
                │   │ │ │ │ └───────────── sfSelected  = $0020
                │   │ │ │ └─────────────── sfFocused   = $0040
                │   │ │ └───────────────── sfDragging  = $0080
                │   │ └─────────────────── sfDisabled  = $0100
                │   └───────────────────── sfModal     = $0200
                └───────────────────────── sfExposed   = $0800

     Значение каждого  из  флагов  состояния описаны в главе 14 под
заголовком "Константы  флагов  состояния   sfXXXX".   Этот   раздел
описывает механизм манипуляции полем State.
     Turbo Vision  изменяет  флаг  состояния  видимого  элемента  с
помощью метода   SetState.   Если  видимый  элемент  активизирован,
активизируется или выбран,  Turbo  Vision  вызывает  SetState.  Это
отличается от   способа,   которым   обрабатываются  другие  флаги,
поскольку они  устанавливаются  при  инициализации   и   затем   не
изменяются (например,  если окно может изменять размер,  оно всегда
может изменять размер).  Состояние видимого элемента, однако, часто
изменяется при  его  нахождении  на  экране.  Поэтому  Turbo Vision
предоставляет механизм в SetState,  который позволяет Вам не только
изменить состояние  видимого  элемента,  но  так  же реагировать на
изменения состояния.
     SetState получает   состояние   (AState)   и   флаг  (Еnable),
указывающее установлено состояние или очищено.  Если Enable - True,
то  биты  в  AState  устанавливаются в State.  Если Enable - False,
соответствующие биты State  очищаются.  Это  во  многом  похоже  на
работу с любым битовым полем.  Отличия появляются, когда Вы хотите,
чтобы видимый элемент  сделал  что-либо,  когда  Вы  изменяете  его
состояние.


#Действие на изменение состояние.

     Видимый элемент  часто  выполняет  определенные  действия  при
вызове State,  в  зависимости  от результирующего состояния флагов.
Например кнопка  просматривает  State  и  изменяет  свой  цвет   на
бирюзовый, когда становится активной.  Типичный пример SetState для
объекта, порожденного от TView.

     procedure TButton.SetState(AState: Word; Enable: Boolean);
     begin
       TView.SetState(AState, Enable);
       if AState and (sfSelected + sfActive) <> 0 then DrawView;
       if AState and sfFocused <> 0 then MakeDefault(Enable);
     end;

     Заметим, что Вы должны вызвать TView.SetState из нового метода
SetState. TView.SetState выполняет  установку  или  очистку  флагов
состояния. Затем Вы можете определить любые действия, основанные на
состоянии видимого элемента.  TButton проверяет,  находится ли он в
активном окне для того,  чтобы решить,  должен ли он рисовать себя.
Он так же проверяет,  является ли  он  активным  и  в  этом  случае
вызывает свой метод MakeDefault, который устанавливает или отменяет
активность в зависимости от параметра Enable.
     Если Вам необходимо выполнить изменения в видимом элементе или
программе когда   состояние   определенного    видимого    элемента
изменяется, Вы можете сделать это, перекрыв SetState этого видимого
элемента. Предположим,  что  Ваша  программа   включает   текстовый
редактор и   Вы   хотите   разрешить   или  запретить  все  команды
редактирования в полосе меню в зависимости от того, открыт редактор
или нет. SetState текстового редактора определен:

     procedure TEditor.SetState(AState: Word; Enable: Boolean);
     const
       EditorCommands = [cmSearch, cmReplace, cmSearchAgain,
         cmGotoLine, cmFindProc, cmFindError, cmSave, cmSaveAs];
     begin
       TView.SetState(AState, Enable);
       if AState and sfActive <> 0 then
         if Enable then EnableCommands(EditorCommands)
         else DisableCommands(EditorCommands);
     end;

     Примечание: Этот код используется видимым  элементом редактора
IDE Turbo Pascal, и его поведение должно быть Вам знакомо.

     Программист и   Turbo   Vision  часто  взаимодействуют,  когда
состояние изменяется.  Предположим,  что Вы хотите,  чтобы блоковый
курсор появился  в  Вашем  текстовом  редакторе когда включен режим
вставки.
     Во-первых, режим  вставки редактора связан с клавишей, скажем,
с клавишей Ins.  Когда текстовый редактор  активен  и  клавиша  Ins
нажата, текстовый  редактор  получает  событие  клавиши Ins.  Метод
HandleEvent текстового  редактора  откликается   на   событие   Ins
переключением внутреннего  состояния видимого элемента, говорящегоо
том, что режим вставки изменился и вызывая метод BlockCursor. Turbo
Vision делает  остальное.  BlockCursor  вызывает  SetState видимого
элемента для установки состояния sfCursorIns в True.


#Цвет видимого элемента.

     У всех  разное  мнение по поводу того,  какой цвет "лучше" для
экрана компьютера.  Поэтому Turbo  Vision  позволяет  Вам  изменять
цвета видимых   элементов   на   экране.  Для  этого  Turbo  Vision
предоставляет Вам палитры цветов.


#Палитры цветов.

     Когда видимый   элемент   в   Turbo  Vision  рисует  себя,  он
запрашивает прорисовку не определенным цветом,  а цветом,  заданным
позицией в  его  палитре  (палитры  для  всех  стандартных  видимых
элементов описаны в главе 13).  Например,  палитра TScroller  имеет
вид:

     CScroller = #6#7;

     Палитра цветов  в  действительности  хранится  в  строке,  что
позволяет определять ее в качестве  гибких  массивов  с  переменной
длиной. Так,  CScroller  - это двухсимвольная строка,  содержащая 2
элемента палитры. Палитра TScroller определена:

     (* Палитра          *)
     (* 1 = Нормальный   *)
     (* 2 = Подсвеченный *)

     Но удобнее рассмотреть ее в виде:

          Рис. 4.18. Палитра по умолчанию для TScroller.

                 1   2
               ┌───┬───┐
     CScroller │ 6 │ 7 │
               └───┴───┘
                 │   │
                 │   └───────── Подсвеченный текст
                 └───────────── Нормальный текст

     Это означает,  что известно как отображать по крайней  мере  2
типа текста  объекта скроллер:  нормальный и подсвеченный.  Цвет по
умолчанию определяется  элементами  палитры.   Когда   отображается
нормальный текст, метод Draw должен вызвать GetColor(1) означающий,
что он хочет выбрать  цвет,  указанный  первым  элементом  палитры.
Чтобы показать  подсвеченный  текст,  будет вызываться GetColor(2).
(GetColor - это метод TView).
     Если Вы хотите отображать цветами по умолчанию,  это все,  что
Вам необходимо  знать.  Палитра  устанавливается  так,  что   любая
комбинация объектов должна создавать хорошие цвета.


#Внутри палитры цветов.

     Элементы палитры - это индексы в палитру владельца,  а не сами
цвета. Если скроллер вставлен в окно, Вы получите нормальный текст,
вызывая скроллер с нормальным цветом текста  в  палитре  скроллера,
который содержит номер 6. Чтобы преобразовать это в цвет, Вы должны
найти 6 элемент в палитре владельца.  Рис. 4.19. показывает палитру
TWindow:

     Рис. 4.19. Отображение палитры скроллера в палитру окна.

   ┌───────────────────────────── Рамка пассивна
   │   ┌───────────────────────── Рамка активна
   │   │   ┌───────────────────── Кнопка рамки
   │   │   │   ┌───────────────── Страница скроллера
   │   │   │   │   ┌───────────── Элемент управления скроллера
   │   │   │   │   │   ┌───────── Нормальный текст скроллера
   │   │   │   │   │   │   ┌───── Выбранный текст скроллера
   │   │   │   │   │   │   │   ┌─ Зарезервировано
   │   │   │   │   │   │   │   │
   1   2   3   4   5   6   7   8
 ┌───┬───┬───┬───┬───┬───┬───┬───┐
 │ 8 │ 9 │ 10│ 11│ 12│ 13│ 14│ 15│ CBlueWindow
 └───┴───┴───┴───┴───┴─┬─┴───┴───┘
   ┌───────────────────┘
 ┌─┴─┬───┐
 │ 6 │ 7 │   CScroller
 └───┴───┘
   │   │
   │   └─────────────────────── Подсвеченный текст
   └─────────────────────────── Нормальный текст

     6 элемент в палитре TWindow равен 13,  это  индекс  в  палитре
владельца окна  (панели  экрана),  который преобразуется в индекс в
палитру его владельца - программы.  TDeskTop имеет палитру nil, что
означает, что он не изменяет ничего. Вы можете думать об этом как о
"прямой" палитре с первым элементом с номером 1, вторым - с номером
2 и т.д.
     Программа, которая имеет палитру,  содержит значения для  всех
элементов, которые Вы можете вставить в Turbo Vision. Ее 13 элемент
- это $1.  Программа - это последяя точка (она не имеет владельца),
поэтому отображение  останавливается здесь.  Сейчас Вы получили $1,
что соответствует цвету фона 1 и цвету символа  $Е  (или  14),  что
создает желтый символ на синем фоне.  И опять, не думайте об этом в
терминах желтый-на-синем,  а скорее скажите,  что Вы хотите,  чтобы
Ваш текст отображался нормальным цветом для текста окна.
     Не думайте о палитре как о цветах,  это тип характеристик  для
отображения.


#Метод GetColor.

     Отображение цвета  палитры  выполняется  виртуальной  функцией
GetColor из TView. GetColor поднимается по дереву видимых элементов
от рисуемогоо элемента к его владельцу, затем к владельцу владельца
и т.д.  пока не дойдет до объекта программа.  Для каждого объекта в
этой цепочке GetColor вызывает GetPalette этого  объекта. Результат
- цвет атрибута.
     Палитра видимого  элемента   содержит   смещения   в   палитре
владельца за исключением прикладной программы, чья палитра содержит
атрибуты цветов.


#Перекрытие цветов по умолчанию.

     Очевидный способ  изменить цвета - это изменить палитру.  Если
Вам не  нравится  цвет  нормального  текста  скроллера,  Вы  можете
захотеть изменить элемент 1 (нормальный текст) в палитре скроллера,
например с 6  на  5.  Нормальный  текст  скроллера  отображается  в
элемент окна для элемента управления полосы скроллера (по умолчанию
синий-на-бирюзовом). Запомните:  5 -  это  не  цвет!  Все,  что  Вы
сделали -  это  сказали скроллеру,  что его нормальный текст должен
выглядеть так же, как полосы скроллинга вокруг него!
     Что делать,   если  Вы  не  хотите  желтый-на-синем?  Измените
элемент палитры  для  нормального  текста  окна   в   TApplication.
Поскольку это   последняя   не  nil  палитра,  элементы  в  палитре
программы определяют  цвета,  которые  будут  появляться  во   всех
видимых элементах  окна,  т.е.  цвета  не  являются абсолютными,  а
определяются палитрами владельца.
     Это имеет смысл: вероятно Вы хотите, чтобы Ваши окна выглядели
одинаково. Вероятно Вы не  захотите  указывать  каждому  отдельному
окну какого  цвета  оно должно быть.  Если Вы захотите изменить его
позже (или разрешить пользователю настраивать цвета),  Вам придется
изменить элементы для каждого окна.
     Так же скроллер или другой интерьер не должен  беспокоиться  о
его цветах,  если он вставляется в какое-то окно, отличное от того,
в какое Вы хотели вставить его  первоначально.  Например,  если  Вы
поместили скроллер  в диалоговое окно вместо окна,  он не будет (по
умолчанию) того же цвета,  а вместо этого будет  цвета  нормального
текста в диалоговом окне.
     Чтобы изменить палитру  видимого  элемента,  перекройте  метод
GetPalette. Чтобы  создать  новый  тип  объекта скроллера,  который
рисует себя цветом рамки  окна  вместо  цвета  нормального  текста,
объявление и реализация объекта будут включать:

     type
       TMyScroller = object(TScroller)
         function GetPalette: PPalette; virtual;
       end;

     function TMyScroller.GetPalette: PPalette;
     const
       CMyScroller = #1#7;
       PMyScroller: string[Length(CMyScroller)] = CMyScroller;
     begin
       GetPalette := @PMyScroller;
     end;

     Заметим, что константа  палитры  -  это  строковая  константа,
поскольку Turbo  Vision  использует  тип  String  для представления
палитры. Это  позволяет  более  просто   манипулировать   палитрой,
поскольку все строковые функции могут использоваться с палитрами.

     Примечание: Типы TPalette и String полностью взаимозаменяемы.


#Добавление новых цветов.

     Вы можете добавить дополнительные цвета к типу  объекта  окна,
который позволит  использовать  различные  цвета при создании новых
видимых элементов.  Например допустим,  Вы решили  добавить  третий
цвет для  скроллера для другого типа подсветки как используется для
точек прерывания  в  редакторе  IDE.   Это   может   быть   сделано
наследованием нового   типа  объекта  из  существующего  TWindow  и
добавлением к палитре по умолчанию:

     type
       TMyWindow = object(Window)
         function GetPalette: PPalette; virtual;
       end;

     function TMyWindow.GetPalette: PPalette;
     const
       CMyWindow := CBlueWindow + #84;
       P: string[Length(CMyWindow)] = CMyWindow;
     begin
       GetPalette := @P;
     end;

     Примечание: Палитры   -   это   строки,   так  что  Вы  можете
использовать строковые операции, такие как "+".

     Сейчас TMyWindow имеет новый элемент палитры, который содержит
новый тип подсветки.  CWindow - это строковая константа, содержащая
палитру TWindow по умолчанию.  Вы должны изменить метод  GetPalette
для MyScroller чтобы использовать это:

     function TMyScroller.GetPalette: PPalette;
     const
       CMyScroller = #6#7#9;
       P: string[Length(CMyScroller)] = CMyScroller;
     begin
       GetPalette := @P;
     end;

     Элемент 3  палитры  скроллера  -  это  новый цвет подсветки (в
данном случае  белый  на  красном).  Если  Вы   используете   новую
GetPalette используя CMyScroller, который обращается к 9 элементу в
палитре владельца, убедитесь, что владелец действительно использует
палитру CMyWindow. Если Вы попытаетесь обратиться к 9 элементу в 8-
элементной палитре, результат будет непредсказуем.

@ГЛАВА 5. ПРОГРАММИРОВАНИЕ УПРАВЛЯЕМОЕ СОБЫТИЯМИ.

#Программирование управляемое событиями

     Цель Turbo Vision обеспечить Вас рабочей оболочкой  для  Ваших
прикладных программ,  так  чтобы  Вы  могли  сконцентрироваться  на
наращивании "мяса" Ваших программ.  Два главных  инструмента  Turbo
Vision -  это  поддержка  построения  окон  и управление событиями.
Глава 4  объясняет  видимые  элементы,  а   эта   глава   описывает
построение программ вокруг событий.


#Воплощение Turbo Vision в жизнь.

     Мы уже описали программы Turbo Vision, управляемые событиями и
кратко определили как Ваша программа должна реагировать на события.


#Чтение ввода пользователя.

     В традиционных  программах  на  Паскале   Вы   обычно   пишете
цикл, который  читает  ввод  пользователя с клавиатуры,  мышки и от
других устройств и Вы принимаете  решение  на  основе  этого  ввода
внутри цикла.   Вы   будете  вызывать  процедуры  или  функции  или
переходить на  этот  цикл  для  того  чтобы   снова   читать   ввод
пользователя:

     repeat
       B := ReadKey;
       case B of
         'i': InvertArray;
         'e': EditArrayParams;
         'g': GraphicDisplay;
         'q': Quit := true;
       end;
     until Quit;

     Программа управляемая   событиями   не   очень  отличается  от
обычной. В самом деле,  трудно вообразить интерактивную  программу,
которая работает  по другому.  Однако,  с точки зрения программиста
программа управляемая событиями выглядит иначе.
     В программах  на  Turbo  Vision  Вы  больше  не  читаете  ввод
пользователя поскольку Turbo  Vision  делает  это  вместо  Вас.  Он
собирает  ввод  в  записи Паскаля,  называемые событиями и передает
события соответствующим видимым элементам программы.  Это означает,
что   Вашему   коду   только   требуется   знать   как   обработать
соответствующий ввод.
     Например, если пользователь отмечает мышкой в неактивном окне,
Turbo Vision читает ввод мышки,  помещает его в  запись  события  и
посылает запись события в неактивное окно.
     Если Вы имеете опыт традиционного программирования  Вы  можете
подумать сейчас:  "Хорошо, я не должен читать ввод от пользователя.
Я должен изучить как читать запись события об отметке мышкой  и как
сказать  неактивному окну стать активным." В действительности Вы не
должны писать так много кода.
     Видимые элементы  сами  могут обрабатывать большую часть ввода
пользователя. Окно знает как открыться,  закрыться,  переместиться,
стать выбранным,  изменить  размер и многое другое.  Меню знает как
открыться, взаимодействовать с пользователем  и  закрыться.  Кнопки
знают как  нажиматься,  как  взаимодействовать  между  собой  и как
изменять цвет.  Полосы скроллинга как  функционировать.  Неактивное
окно может сделать себя активным без какой либо Вашей помощи.
     Что Вы должны делать как  программист?  Вам  нужно  определить
новые видимые элементы с новыми функциями,  которые должны знать об
определенных видах событий заданных Вами.  Вы  также  научите  Ваши
видимые элементы   откликаться   на   стандартные  команды  и  даже
генерировать собственные   команды   (сообщения)   другим   видимым
элементам. Этот  механизм  уже  есть:  все  что  Вы  делаете  - это
генерируете команды и говорите видимым элементам что  нужно сделать
когда они увидят их.
     Как именно выглядят события в  Вашей  программе  и  как  Turbo
Vision обрабатывает их?


#Природа событий.

     События лучше всего  представить  себе  как  небольшие  пакеты
информации, описывающие отдельные случаи (ситуации) на которые Ваша
программа должна  реагировать.  Каждое  нажатие   клавиши,   каждое
действие мышки  и любое условие,  генерируемое другими компонентами
программы, это отдельное событие.  События не могут быть разбиты на
более мелкие части;  так когда пользователь набирает слово - это не
одно событие, а серия отдельных событий от клавиш.
     В объектно-ориентированном   мире  Turbo  Vision  Вы  вероятно
думаете, что события это тоже объекты.  Это не так. Сами события не
производят действий;  они  только  содержат  информацию  для других
объектов и поэтому представлены записями.
     Ядром каждой  записи  типа  событие  является  поле  What типа
слово. Числовое  значение  поля  What  описывает  вид  события,   а
оставшаяся часть   записи   типа   событие   содержит   специальную
информацию об этом событии.  Скан код  клавиатуры  для  события  от
клавиш, информация  о  позиции  мышки  и  состоянии  ее  кнопок для
события от мышки и т.д.
     Поскольку различные виды событий передаются предназначаемым им
объектам различными  способами,  давайте  вначале  рассмотрим  виды
событий распознаваемые в Turbo Vision.


#Виды событий.

     Давайте посмотрим на возможные значения Event.What. Существуют
4 основных  базовых  класса событий:  события от мышки,  события от
клавиатуры, события сообщений  и  "пустые"  события.  Каждый  класс
имеет определенную   маску,   так   что  Ваш  объект  может  быстро
определить какой тип события случился, не заботясь о его конкретном
виде. Например,  вместо  того,  чтобы проверять на 4 различных вида
событий от мышки,  Вы можете просто проверить, есть ли флаг события
в маске. Вместо

     if Event.What and (evMouseDown or evMouseUp or evMouseMove or
       evMouseAuto) <> 0 then ...

     Вы можете использовать

     if Event.What and evMouse  <> 0 then ...

     Доступны следующие маски:  evNothing (для  "пустых"  событий),
evMouse, для   событий   от   мышки;  evKeyBoard,  для  событий  от
клавиатуры и evMessage для сообщений.
     Биты маски событий определены на рис.5.5.

                 Рис. 5.1. Биты поля TEvent.What.

     ┌───────── Event Flags ─────────┐
     msb                           lsb
      ┌─┬─┬─┬─┬─┬─┬─┬─────────────────── evMessage   = $FF00
      │ │ │ │ │ │ │ │       ┌─────────── evKeyboard  = $0010
      │ │ │ │ │ │ │ │       │ ┌─┬─┬─┬─── evMouse     = $000F
     ╔╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤═╤═╤═╤╧╤╧╤╧╤╧╤╧╗
     ╚═╧═╧═╧═╧═╧═╧╤╧╤╧═╧═╧═╧╤╧╤╧╤╧╤╧╤╝
                  │ │       │ │ │ │ └─── evMouseDown = $0001
                  │ │       │ │ │ └───── evMouseUp   = $0002
                  │ │       │ │ └─────── evMouseMove = $0004
                  │ │       │ └───────── evMouseAuto = $0008
                  │ │       └─────────── evKeyDown   = $0010
                  │ └─────────────────── evCommand   = $0100
                  └───────────────────── evBroadcast = $0200

#События от мышки.

     Существуют 4 вида событий от  мышки:  нажатие  или  отпускание
любой кнопки,  изменение позиции или "авто" событие. При нажатии на
кнопку мышки  генерируется  событие   evMouseDown.   Когда   кнопка
отпускается генерируется   событие   evMouseUp.  Перемещение  мышки
генерирует событие evMouseMove.  Если Вы  держите  кнопку  нажатой,
Turbo Vision периодически генерирует событие evMouseAvto, позволяяя
Вашей программе такие действия  как  повторяющийся  скроллинг.  Все
записи событий  от  мышки  включают позицию мышки,  так что объект,
обрабатывающий событие знает где находилась мышка в этот момент.


#События от клавиатуры.

     События от   клавиатуры  намного  проще.  Когда  Вы  нажимаете
клавишу, Turbo Vision генерирует событие evDown,  которое  содержит
информацию о нажатой клавише.


#События сообщений.

     События сообщений бывают 3 видов:  команды,  общие сообщения и
пользовательские  сообщения.  Они  отличаются  обработкой как будет
объяснено позднее.  Команды помечаются в поле What через evCommand,
общие сообщения  через  evBroadcast  и  пользовательские  сообщения
константой определенной пользователем.


#"Пустые" события.

     "Пустые" события  это в действительности мертвые события.  Оно
перестало быть событием,  поскольку полностью обработано. Если поле
What в записи события содержит значение evNothing, то эта запись не
содержит полезной информации, которая требует обработки.
     Когда объект  Turbo  Vision заканчивает обработку события,  он
вызывает  метод  ClearEvent,  который  устанавливает  поле  What  в
evNothing,  указывая  что  событие было обработано.  Объекты должны
просто игнорировать события evNothing, поскольку они уже обработаны
другим объектом.


#События и команды.

     Большинство событий в конечном итоге преобразуются  в команды,
например, отметка  мышкой  элемента  в  строке  статуса  генерирует
событие от мышки.  Когда оно поступает в объект  "строка  статуса",
этот объект    откликается   на   событие   от   мышки,   генерируя
событие-команду со значением поля  Command,  определяемым  командой
связанной с элементом строки статуса.  Нажатие мышкой на Alt-X Exit
генерирует команду cmQuit,  которую  программа  интерпретирует  как
инструкцию закрытия системы и завершения.


#Передача событий.

     Видимые элементы Turbo Vision  работают  по  принципу  "Говори
только  когда  к  тебе обратятся".  Это не похоже на активный поиск
ввода,  они скорее пассивно ожидают,  когда монитор событий  скажет
им, что произошло событие, на которое требуется отклик.
     Для того чтобы Ваша программа на Turbo Vision делала то что Вы
хотите,  Вы должны не только сказать видимым элементам, что делать,
когда случается определенное событие,  но  и  должны  понимать  как
события  передаются  в  Ваши видимые элементы.  Главное в получении
событий в нужном месте - это  правильная  маршрутиризация  событий.
Некоторые  события  передаются  всем  элементам  программы,  другие
направляются точно в определенные части программы.


#Откуда приходят события.

     Как сказано в главе 1,  главный цикл обработки в TApplication,
метод Run вызывает TGroup.Execute, которая основана на цикле:

     var E: TEvent;
     E.What := evNothing; (* указывает что нет событий *)
     repeat
       if E.What <> evNothing then EventError(E);
       GetEvent(E);       (* упаковывает запись события *)
       HandleEvent(E);    (* направляет событие в нужное место *)
     until EndState <> Continue;

     По существу GetEvent смотрит вокруг и проверяет,  не случилось
ли что  либо,  что должно быть событием.  Если случилось,  GetEvent
создает соответствующую   запись   события.    Затем    HandleEvent
направляет событие в соответствующие видимые элементы. Если событие
не обработано (и не очищено) за время пока оно не вернется  в  этот
цикл,  то вызывается EventError, чтобы указать на ненужное событие.
По умолчанию EventError ничего не делает.


#Куда идут события.

     События всегда   начинают  свой  путь  с  текущего  модального
видимого элемента.  Для нормальных  операций  это  обычно  означает
объект "Ваша  программа".  Когда Вы выполняете модальное диалоговое
окно, это диалоговое окно -  модальный  видимый  элемент.  В  любом
случае, модальный  видимый элемент начинает обработку события. Куда
событие пойдет дальше зависит от природы события.
     События передаются  одним  из трех способов,  в зависимости от
вида события. Возможны три вида передач: позиционировнные, активные
и общие. Важно понимать как передается каждый вид события.


#Позиционированные события.

     Позиционированные события  это   всегда   события   от   мышки
(evMouse).
     Модальный видимый элемент получает  позиционированное  событие
первым и начинает просматривать свои подэлементы в Z-порядке до тех
пор  пока  не  найдет  подэлемент  содержащий  позицию,  в  которой
возникло событие.  (Z-порядок объяснен в главе 4).  Затем модальный
видимый элемент передает событие этому видимому элементу. Поскольку
видимые  элементы  могут  перекрываться,  возможно  что  эта  точка
принадлежит  более  чем  одному  видимому  элементу.  Следование  в
Z-порядке гарантирует что это событие получит самый верхний видимый
элемент, включающий эту позицию.
     Этот процесс продолжается до тех пор пока не может быть найден
видимый элемент для передачи события,  либо  из-за  того,  что  это
терминальный видимый  элемент  (не  имеет  подэлементов),  либо  не
существует подэлементов включающих позицию этого  события (например
отмечено пустое  пространство  в  диалоговом  окне).  В этот момент
событие достигло  объекта,  где  возникло   это   позиционированное
событие и объект обрабатывает событие.


#Активные события.

     Активные события это нажатия клавиш  (evKeyDown)  или  команды
(evCommand) и  передаются  вниз  по  активной  цепочке.  (Детальное
описание активных видимых элементов и активной цепочки  приведено в
"Выбранные и активные видимые элементы" главы 4).
     Текущий модальный видимый элемент  получает  активное  событие
первым и передает его в выбранный подэлемент.  Если этот подэлемент
содержит выбранный подэлемент,  он передает  событие  ему.  Процесс
продолжается до  тех  пор  пока  не  будет  достигнут  терминальный
видимый элемент:  это активный видимый  элемент.  Активный  видимый
элемент получает и обрабатывает активное событие.
     Если активный видимый элемент не знает как обработать какое-то
из полученных  событий,  он  передает  событие  вверх  по  активной
цепочке своему владельцу.  Процесс  повторяется  до  тех  пор  пока
событие не  будет  обработано  или  снова  не  достигнет модального
видимого элемента.  Если модальный видимый  элемент  не  знает  как
обработать   вернувшееся   событие,  он  вызывает  EventError.  Эта
ситуация - ненужное событие.  (Неактивные  видимые  элементы  могут
обрабатывать активные события. См. раздел "Фаза".)
     События от клавиатуры иллюстрируют  принцип  активных  событий
совершенно ясно.  Например, в интегрированной среде Turbo Pascal Вы
можете открыть  несколько  файлов  в  окнах  редактора.  Когда   Вы
нажимаете клавишу,  Вы  знаете  какой  файл  получит  этот  символ.
Давайте посмотрим как Turbo Vision обеспечивает это.
     Нажатие клавиши    генерирует   событие   evKeyDown,   которое
поступает в   текущий   модальный   видимый   элемент   -    объект
TApplication. TApplication   посылает   событие  своему  выбранному
элементу - панели экрана (панель экрана - всегда  выбранный элемент
TApplication). Панель  экрана  посылает  событие  своему выбранному
видимому элементу  -  активному  окну  (с  двойной  рамкой).   Окно
редактора также  имеет  подэлементы - рамку,  интерьер скроллинга и
две полосы скроллинга.  Из них может быть выбран только интерьер (и
следовательно выбран  по умолчанию),  поэтому событие от клавиатуры
приходит в него. Интерьер - редактор не имеет подэлементов и должен
решать как обработать символ в событии evKeyDown.


#Общие события.

     Общие события это обычно общие сообщения  или пользовательские
сообщения.
     Общие события  не  направляются  как   позиционированные   или
активные события.  По  определению  обшие  события  не знают своего
назначения и  посылаются   всем   видимым   подэлементам   текущего
модального видимого элемента.
     Текущий модальный видимый элемент получает событие  и начинает
передавать его   подэлементам  в  Z-порядке.  Если  любой  из  этих
пдэлементов - группа,  он также передает событие своим подэлементам
и также  в  Z-порядке.  Процесс  продолжается  до  тех пор пока все
видимые элементы  принадлежащие  (прямо  или  косвенно)  модальному
видимому элементу не получат сообщения.
     Общие сообщения обычно используются для взаимодействия видимых
элементов. Например,   когда   Вы  отмечаете  полосу  скроллинга  в
просмотре файла, полоса скроллинга должна сказать видимому элементу
просмотра, что он должен показать другую часть себя. Это значит что
когда видимый элемент выдает общее сообщение "Я изменился!", другие
видимые элементы,   включая   текст,  будут  получать  сообщение  и
реагировать на  него.  Дополнительные  детали  смотри   в   разделе
"Межэлементное взаимодействие".
     Примечание: Общие  сообщения  могут  быть  направлены  объекту
функцией Message.


#События определенные пользователем.

     Как только Вы ознакомитесь с  Turbo  Vision  и  событиями,  Вы
захотите определить новую категорию событий, используя старшие биты
поля What записи события.  По  умолчанию  Turbo  Vision  направляет
такие события как общие события.  Но Вам может понадобиться сделать
общие события  активными  или  позиционированными  и  Turbo  Vision
предоставляет механизм, позволяющий сделать это.
     Turbo Vision  определяет  две  маски  Positional  и   Focused,
которые содержат  биты  соответствующие событиям в поле What записи
события, которые должны быть направлены как  позиционированные  или
активные соответственно.  По умолчанию Positional содержит все биты
evMouse, а Focused содержит evKeyBoard.  Если Вы определяете другой
бит в   новом   виде  события,  которое  Вы  хотите  направить  как
позиционированное или  активное,  Вы  просто  прибавляете   бит   к
соответствующей маске.  (Манипуляция  битами  в маске объясняется в
главе 10).


#Маскирование событий.

     Каждый видимый  элемент имеет битовое поле EventMask,  которое
используется для  определения,  какие  события  будет  обрабатывать
видимый   элемент.   Биты   EventMask   соответствуют   битам  поля
TEvent.What.  Если бит для данного вида события установлен, видимый
элемент  будет  принимать этот вид события для обработки.  Если бит
для данного вида события очищен, видимый элемент будет игнорировать
этот вид событий.


#Фаза.

     Возникают ситуации  когда  Вы  хотите  чтобы  видимый  элемент
отличный от  активного  обрабатывал  активные  события (особенно от
клавиш). Например,  при просмотре текста в скроллингуемом окне  Вам
может понадобиться  использовать клавиши для скроллинга текста,  но
поскольку текстовое окно это активный видимый элемент,  события  от
клавиш приходят  к нему,  а не к полосам скроллинга,  которые могут
скроллинговать видимый элемент.
     Однако Turbo Vision предоставляет механизм позволяющий видимым
элементам отличным от  активного  элемента  видеть  и  обрабатывать
активные события.  Хотя  передача  описанная  в  разделе  "Активные
события" абсолютно корректна,  существуют два исключения при точном
прохожденни активной цепочки.
     Когда модальный  видимый  элемент   получает   для   обработки
активное событие, передача выполняется в три "фазы":
     - Событие  посылается  всем  подэлементам  (В  Z-порядке),   у
которых установлен флаг ofPreProcess.
     - Если событие  не  очищено  ни  одним  из  них,  это  событие
посылается в активный видимый элемент.
     - Если событие все еще не очищено,  оно посылается в Z-порядке
всем подэлементам с установленным флагом ofPostProcess.
     Так в предыдущем примере,  если полосе  скроллинга  необходимо
видеть клавиши,    которые   предназначены   активному   текстовому
элементу, полоса  скроллинга   должна   быть   инициализирована   с
установленным флагом ofPreProcess.  Если Вы посмотрите на программу
TVDEMO09.PAS Вы  заметите  что  полосы   скроллинга   для   видимых
элементов интерьера  имеют установленными биты ofPostProcess.  Если
Вы модифицируете  код  так,  чтобы  эти  биты  не  устанавливались,
скроллинг от клавиатуры будет запрещен.
     Заметим также что в этом примере нет большой разницы,  что  Вы
установите -  ofPreProcess  или  ofPostProcess.  Поскольку активный
видимый элемент в этом случае  не  обрабатывает  это  событие  (сам
TScroller ничего  не делает с нажатиями клавиш),  полосы скроллинга
могут видеть эти события как до  так  и  после  того,  как  событие
передается в скроллер.
     Однако лучше  использовать  в  таких  случаях   ofPostProcess,
поскольку он   предоставляет  большую  гибкость.  Позже  Вы  можете
добавить в интерьер код,  который проверяет нажатие клавиш, но если
эти нажатия будут использованы полосой скроллинга,  до того как они
будут получены  активным  элементом  (ofPreProcess),  Ваш  интерьер
никогда не будет реагировать на них.

     Примечание: Хотя   Вам  может  требоваться  перехват  активных
событий до того как активный элемент получает  их,  хорошая  мысль,
оставить как можно больше доступных возможностей, поскольку Вы (или
кто-то еще) можете наследовать  нечто  новое  от  этого  объекта  в
будущем.


#Поле Phase.

     Каждая группа  имеет  поле  Phase,   которое   принимает   три
значения:  phFocused,  phPreProcess и phPostProcess.  Проверяя флаг
Phase владельца,  видимый   элемент   может   сказать,   будет   ли
обрабатываться  событие  активное  событие  до,  во время или после
передачи. Это иногда необходимо,  т.к.  некоторые видимые  элементы
ожидают различные  события  или  реагируют на одинаковые события по
разному, в зависимости от фазы.
     Рассмотрим случай простого диалогового окна,  которое содержит
строку ввода и клавишу с меткой "All right" с коротким набором "A".
С управляющими  элементами  обычного   диалогового   окна   Вы   в
действительности не имеете  дело  с  фазой.  Большинство  элементов
управления имеют  ofPostProcess установленным по умолчанию, поэтому
нажатия клавиш (активные события) будут передаваться  им,  позволяя
перехватывать   активность,  если  была  нажата  короткая  клавиша.
Нажатие "А" передает активность кнопке "All right".
     Теперь предположим  что активна строка ввода,  так что нажатия
клавиш обрабатываются и вставляются строкой ввода.  Нажатие клавиши
"А" вставляет  "А"  в  строку  ввода и кнопка никогда не увидит это
событие, поскольку активный видимый элемент обработал ее.  Если  вы
зададите предварительную  обработку  клавиши  "А"  для кнопки,  она
сможет перехватывать короткую клавишу до  того  как  ее  обработает
активный видимый элемент. К сожалению это не даст Вам набрать букву
"А" в строке ввода!
     Решение очень просто: сделайте проверку в кнопке для различных
коротких клавиш до и после того  как  активный  элемент  обработает
событие. По  умолчанию кнопка просматривает свою короткую клавишу в
форме Alt-буква до процесса и в форме  буквы  после  процесса.  Вот
почему Вы можете использовать короткий набор Alt-буква в диалоговом
окне, но можете обрабатывать обычные буквы  только  когда  активный
элемент управления не "ест" клавиши.
     Это просто сделать.  По умолчанию кнопки  имеют  установленные
ofPreProcess и ofPostProcess, так что видят активные события и до и
после активного видимого элемента,  но  внутри  метода  HandleEvent
кнопка проверяет  некоторые  клавиши  только  если активный элемент
управления уже видел событие:

     evKeyDown: (* это часть оператора case *)
       begin
         C := HotKey(Title^);
         if (Event.KeyCode = GetAltCode(C)) or
            (Owner^.Phase = phPostProcess) and (C <> #0) and
            (upcase(Event.CharCode) = C) or
         (State and sfFocused <> 0) and (Event.CharCode = ' ') then
         begin
           PressButton;
           ClearEvent(Event);
         end;
       end;


#Команды.

     Большинство позиционированных и активных событий транслируются
обрабатывающими их   объектами   в   команды.   Т.е.  объект  часто
откликается на  отметку  мышкой  или  клавишу  генерацией   события
команды.
     Например, отметив в строке статуса программы на  Turbo  Vision
Вы генерируете позиционное (от мышки) событие. Программа определяет
что отметка была  позиционирована  в  области  управляемой  строкой
статуса и передает событие в объект строки статуса StatusLine.
     StatusLine определяет какой из  элементов  управления  статуса
отмечен и  читает запись элемента статуса для этого элемента.  Этот
элемент обычно имеет связанную с ним команду и  StatusLine  создает
запись статуса  с  полем What,  установленным в evCommand и с полем
Command,  установленным в команду,  которая  была  связана  с  этим
элементом статуса. Затем она очищает событие от мышки, что означает
что  следующее  событие  обнаруженное  GetEvent  будет  только  что
сгенерированное событие команды.


#Определение команд.

     Turbo Vision имеет ряд предопределенных  команд  и  Вы  можете
определить еще  больше  своих.  Когда  Вы  создаете  новый  видимый
элемент, Вы также создаете команду, которая используется для вызова
этого видимого элемента. Команды могут быть названы произвольно, но
по соглашениям Turbo Vision идентификатор команды должен начинаться
с "cm".  Механизм  создания  команд  прост  -  Вы  только  создаете
константу:

     const
       cmConfuseTheCat = 100;

     Turbo Vision  резервирует  команды  от 0 до 99 и от 256 до 999
для собственного использования.  Ваша программа может  использовать
под команды номера от 100 до 255 и от 1000 до 65535.
     Причина того что Вы имеете два диапазона для команд  только  в
том что  команды  от  0  до 255 могут быть запрещены.  Turbo Vision
резервирует некоторые  команды,  которые  могут  быть  запрещены  и
некоторые команды   которые  не  могут  быть  запрещены  для  своих
стандартных команд и внутренней работы.  Вы имеете полный  контроль
над оставшимися командами.

            Таблица 5.1. Диапазоны команд Turbo Vision.

     ────────────────────────────────────────────────
     Диапазон     Зарезервировано   Может быть
                                    запрещено
     ────────────────────────────────────────────────
     0..99                Да            Да
     100..255             Нет           Да
     256..999             Да            Нет
     1000..65535          Нет           Нет
     ────────────────────────────────────────────────


#Связывание команд.

     Когда Вы  создаете  элемент  строки  статуса  или   меню,   Вы
связываете с ним команду. Когда пользователь выбирает этот элемент,
генерируется запись события с полем What установленным  в evCommand
и полем Command установленным в значение связанной команды. Команда
может быть  стандартной  командой   Turbo   Vision   или   командой
определенной Вами. В тот момент, когда Вы связываете Вашу команду с
элементом меню или строки статуса,  Вы также можете  связать  ее  с
горячей клавишей.  Т.о.  пользователь может вызвать команду,  нажав
клавишу короткого набора или мышкой.
     Примечание: Важно   запомнить   что   определение  команды  не
указывает какое  действие  должно  быть  выполнено,  когда  команда
появляется в  записи  события.  Вы  должны  сказать соответствующим
объектам, как откликаться на эту команду.


#Разрешение и запрещение команд.

     Иногда необходимо,  чтобы  некоторые  команды  были недоступны
пользователю определенное  время.  Например,  нет  открытых   окон,
бессмысленно разрешать    пользователю   генерировать   стандартную
команду закрытия окна cmClose.  Turbo Vision  предоставляет  способ
запретить и разрешить набор команд.
     Для разрешения или запрещения Вы  используете  глобальный  тип
TCommandSet, который  является множеством из чисел в диапазоне от 0
до 255.  (Вот почему можно запретить  только  команды  в  диапазоне
0..255). Следующий код запрещает группу из 5 оконных команд:

     var
       WindowCommands: TCommandSet;
     begin
       WindowCommands := [cmNext, cmPrev, cmZoom, cmResize,
                          cmClose];
       DisableCommands(WindowCommands);
     end;


#Обработка событий.

     После того,  как Вы определили команду  и  установили  элемент
управления, который  генерирует  ее - например,  элемент  меню  или
кнопка диалового окна - Вам нужно научить Ваш видимый  элемент, как
реагировать, когда возникает эта команда.
     Каждый видимый элемент наследует  метод  HandleEvent,  который
уже знает,  как  реагировать  на  большую часть ввода пользователя.
Если Вы хотите,  чтобы видимый элемент делал  что-то  специфическое
для Вашей программы, Вам необходимо перекрыть HandleEvent и научить
новый HandleEvent двум вещам - как откликаться на определенные Вами
команды и  как  откликаться на события от мышки и клавиатуры нужным
Вам образом.
     Метод HandleEvent  определяет поведение видимого элемента. Два
видимых элемента с идентичными методами HandleEvent будут одинаково
откликаться  на  события.  Когда  Вы  порождаете новый тип видимого
элемента,  Вы обычно хотите,  чтобы его поведение более  или  менее
соответствовало  его  предку  с  некоторыми  изменениями.  Наиболее
простой способ достичь этого - вызвать HandleEvent предка  в методе
HandleEvent нового объекта.
     Общий вид HandleEvent наследника:

     procedure NewDescendant.HandleEvent(var Event: TEvent);
     begin
       (*Код, изменяющий или ограничивающий унаследованное
        поведение*)
       Parent.HandleEvent(Event);
       (*Код, выполняющий дополнительные функции*)
     end;

     где Parent - тип предка.
     Другими словами,   если   Вы   хотите,   чтобы   новый  объект
обрабатывал события не так,  как это делал его  предок,  Вы  должны
перехватить определенные   события  до  передачи  события  в  метод
HandleEvent предка.  Если Вы хотите,  чтобы Ваш  новый  объект  вел
себя также,  как  его  предок,  но с дополнительными функциями,  Вы
должны добавить код после вызова процедуры HandleEvent предка.


#Запись события.

     До этого   момента  в  этой  главе  обсуждались  теоретические
аспекты события.  Мы говорили о том,  как  различные  виды  событий
(мышка, клавиатура,  сообщения и "пустые") определяются в поле What
события. Мы так же кратко обсудили использование поля  Command  для
событий-команд.
     Теперь самое  время  обсудить  как  выглядит  запись  события.
Модуль DRIVERS.TPU  в Turbo Vision определяет тип TEvent как запись
с вариантами:

     TEvent = record
       What: Word;
       case Word of
         evNothing: ();
         evMouse: (
           Buttons: Byte;
           Double: Boolean;
           Where: TPoint);
         evKeyDown: (
           case Integer of
             0: (KeyCode: Word);
             1: (CharCode: Char; ScanCode: Byte));
         evMessage: (
           Command: Word;
           case Word of
             0: (InfoPtr: Pointer);
             1: (InfoLong: Longint);
             2: (InfoWord: Word);
             3: (InfoInt: Integer);
             4: (InfoByte: Byte);
             5: (InfoChar: Char));
     end;

     Эта запись с вариантами просматривается по значению поля What.
Так, если TEvent.What - это evMouseDown, то TEvent содержит:

     Buttons: Byte;
     Double: Boolean;
     Where: TPoint;

     Если TEvent.What -  это  evKeyDown,  компилятор  позволит  Вам
обратиться к данным как

     KeyCode: Word;

     или как

     CharCode: Char;
     ScanCode: Byte;

     Последний вариант в записи события может хранить значение типа
Pointer, LongInt,   Word,   Integer,   Byte   или  Char.  Это  поле
используется в Turbo Vision различными способами.  Видимые элементы
могут сами  генерировать  события  и  посылать  их  другим  видимым
элементам. В  этом  случае  они  часто  используют  поле   InfoPtr.
Взаимодействие видимых  элементов  и поля InfoPtr описаны в разделе
"Взаимодействие видимых элементов".


#Очистка событий.

     Когда метод  Handle  видимого  элемента обработал событие,  он
заканчивает этот  процесс  вызовом  метода  ClearEvent.  ClearEvent
устанавливает поле  Event.What  равным  evNothing и Event.InfoPtr в
 @Self, что указывает на очищенное событие.  Если это событие  будет
передано  другому  объекту,  то  он  должен  игнорировать  "пустое"
событие.


#Ненужные события.

     Обычно каждое  событие  обрабатывается  каким-либо  из видимых
элементов Вашей программы.  Если ни один из  видимых  элементов  не
обработал событие,  модальный  видимый элемент вызывает EventError.
EventError вызывает EventError владельца видимого элемента и так до
тех пор, пока не будет вызван TApplication.EventError.
     TApplication.EventError по умолчанию  ничего  не  делает.  При
необходимости Вы можете перекрыть EventError для вызова диалогового
окна с ошибкой или подачи сигнала.  Поскольку конечный пользователь
Вашей программы  не  отвечает  за ошибки программы,  обрабатывающей
событие, такое диалоговое окно  вероятно  должно  быть  удалено  из
коммерческой версии программы.
     ClearEvent так же помогает видимым элементам взаимодействовать
друг с  другом.  Сейчас  запомните,  что  Вы не закончите обработку
события до тех пор, пока не вызовите ClearEvent.


#Модификация механизма событий.

     Сердцем текущего  модального  видимого  элемента является цикл
типа:

     var
       E: TEvent;
     begin
       E.What := evNothing;
       repeat
         if E.What <> evNothing then EventError(E);
         GetEvent(E);
         HandleEvent(E);
       until EndState <> Continue;
     end;


#Централизация сбора событий.

     Одно из наибольших  достижений  программирования  управляемого
событиями в  том,  что  Ваш  код  не  должен знать откуда поступают
события. Например,  объект окно должен только знать,  что когда  он
видит в  событии  команду  cmClose,  он  должен  закрыться.  Его не
интересует то ли эта команда поступила от отметки  его  закрывающей
кнопки, или  из  выбора  меню,  или от горячей клавиши,  или пришло
сообщение от другого объекта программы.  Он даже не беспокоиться  о
том, предназначалась ли эта команда ему. Он только должен знать как
обработать данное событие и обрабатывает его.
     Ключ к   этому   "черному  ящику"  событий  -  метод  GetEvent
программы. GetEvent - это  единственная  часть  программы,  которая
интересуется источником  событий.  Объекты  Вашей  программы просто
вызывают GetEvent и  получают  события  от  мышки,  клавиатуры  или
сгенерированные другими объектами.
     Если Вы хотите создать новые виды  событий  (например,  чтение
символов из   последовательного   порта)   Вы  просто  перекрываете
TApplication.GetEvent в Вашей программе.  Как Вы можете увидеть  из
TProgram.GetEvent в  APP.PAS  цикл  в  GetEvent  сканирует  мышку и
клавиатуру, а затем вызывает Idle.  Чтобы вставить  новый  источник
событий, Вы  можете  либо  перекрыть Idle для просмотра символов из
последовательного порта и генерации  событий,  основанных  на  этих
символах, либо    перекрыть    сам    GetEvent,    чтобы   добавить
GetComEvent(Event) в  цикл,  где  GetComEvent   возвращает   запись
события, если доступен символ от последовательного порта.


#Перекрытие GetEvent.

     GetEvent текущего  модального   видимого   элемента   вызывает
GetEvent владельца  и так далее проходя весь путь по дереву видимых
элементов до TApplication.GetEvent, который ищет следующее реальное
событие.
     Поскольку Turbo Vision всегда использует TApplication.GetEvent
для поиска  событий,  Вы  можете  модифицировать события всей Вашей
программы, перекрывая только один метод.  Например,  для реализации
клавиатурных макро  Вы  можете просматривать события,  возвращаемые
GetEvent, перехватывать определенные нажатия клавиш  и развертывать
их в макро.  С точки зрения остальной программы поток событий будет
приходить прямо от пользователя.

     procedure TMyApp.GetEvent(var Event: TEvent);
     begin
       TApplication.GetEvent(Event);
     end;


#Неиспользованное время.

     Другое преимущество центрального местонахождения TApplication.
GetEvent в том,  что он вызывает метод TApplication.Idle,  если нет
готовых событий.  TApplication.Idle - это пустой метод,  который Вы
можете перекрыть  для того,  чтобы выполнять параллельную обработку
одновременно с текущим видимым элементом.
     Например предположим, Вы определили видимый элемент, названный
THeapView, который  использует   метод   UpDate   для   отображения
доступной в  данный  момент  памяти  кучи.  (Пример  просмотра кучи
включен в  демонстрационные  программы  на   Ваших   дистрибутивных
дисках.) Если  Вы  перекрываете TApplication.Idle,  следующим кодом
пользователь сможет увидеть отображение доступной памяти в куче вне
зависимости от его нахождения в программе.

     procedure TMyApp.Idle;
     begin
       HeapViewer.Update;
     end;


#Взаимодействие видимых элементов.

     Программа Turbo  Vision  инкапсулирована в объекты и Вы пишите
код только внутри  объектов.  Что, если  объектам  требуется  обмен
информацией с  другими  объектами  Вашей программы?  В традиционной
программе Вы  вероятно  будете  копировать  информацию   из   одной
структуры данных в другую. В объектно-ориентированной программе это
может быть непросто,  поскольку объекты могут не знать,  где  найти
другие объекты.
     Взаимодействие видимых элементов  -  это  не  просто  передача
данных между  частями  обычной программы на Паскале.  (Хотя 2 части
обычной программы   на   Паскале   могут   никогда    не    достичь
функциональности двух  видимых  элементов  Turbo Vision).
     Если Вам необходимо взаимодействие  видимых  элементов, первый
вопрос -  это правильно ли Вы разделили задачи между двумя видимыми
элементами. Проблема   может    возникать    из-за    неправильного
проектирования программы.  Вероятно  2 видимых элемента должны быть
объединены в  один  видимый  элемент  или  часть  одного   видимого
элемента должна быть перемещена в другой видимый элемент.


#Посредники.

     Если программа спроектирована  правильно  и  видимые  элементы
требуют взаимодействия  между  собой,  один  из  способов - создать
промежуточный видимый элемент.
     Например, предположим,   что   Вы  имеете  объект  электронной
таблицы и объект текстового процессора и хотите  иметь  возможность
вставлять что-либо  из  электронной таблицы в текстовый процессор и
наоборот. В программе Turbo Vision Вы можете выполнить  это  прямым
взаимодействием видимых  элементов.  Но предположим,  что позже Вам
понадобится добавить к этой группе объектов,  скажем, базу данных и
вставлять в  и  из  базы  данных.  В  этом  случае  Вам потребуется
дублировать связь, установленную Вами между первыми двумя объектами
на все 3 объекта.
     Лучшее решение - это установить промежуточный видимый элемент.
В этом  случае,  скажем,  "карман".  Объект должен знать только как
копировать что-либо в  этот  карман  и  как  вставить  что-либо  из
кармана. Вне   зависимости  от  того,  сколько  новых  объектов  Вы
добавите в группу,  взаимодействие никогда не станет более сложным,
чем сейчас.


#Сообщения между видимыми элементами.

     Если Вы тщательно проанализировали Вашу ситуацию,  решили, что
программа спроектирована правильно и что Вам не требуется создавать
промежуточные элементы,    Вы    можете     реализовать     простое
взаимодействие между двумя видимыми элементами.
     До того,  как один видимый  элемент  сможет  взаимодействовать
с другим, Вы можете определить где находится другой видимый элемент
и вероятно даже убедиться,  что другой видимый элемент существует в
данное время.
     Вначале пример.  Модуль  Stddlg   содержит   диалоговое   окно
TFileDialog (этот  видимый  элемент  открывается  в интегрированной
среде, когда Вы хотите загрузить  новый  файл).  TFileDialog  имеет
TFileList, который показывает справочник на диске, а файл InputLine
отображает текущий   файл   для   загрузки.   Каждый   раз,   когда
пользователь  выбирает  другой  файл  в  FileList,  FileList должен
сказать FilеInputLine вывести новое имя файла.
     В этом  случае  FileList может быть уверен,  что FileInputLine
существует, поскольку оба инициализированы  внутри  одного  объекта
FileDialog. Как   FileList   сможет   сказать   FileInputLine,  что
пользователь выбрал новое имя?
     FileList создает   и  посылает  сообщение.  FileList.FocusItem
посылает сообщение, а FileInputLine.HandleEvent получает его:

    procedure TFileList.FocusItem(Item: Integer);
    var
      Event: TEvent;
    begin
      TSortedListBox.FocusItem(Item);   (* вначале вызывает
                                          наследуемый метод *)
      Message(TopView, evBroadcast, cmFileFocused, List^.At(Item));
      (* TopView указывает текущий модальный видимый элемент *)
    end;

    procedure TFileInputLine.HandleEvent(var Event:TEvent);
    var
       Name: NameStr;
    begin
      TInputLine.HandleEvent(Event);
      if (Event.What = evBroadcast) and
        (Event.Command = cmFileFocused) and
        (State and sfSelected = 0) then
      begin
        if PSearchRec(Event.InfoPtr)^.Attr and Directory <> 0 then
           Data^ := PSearchRec(Event.InfoPtr)^.Name + '\' +
              PFileDialog(Owner)^.WildCard
        else Data^ := PSearchRec(Event.InfoPtr)^.Name;
        DrawView;
      end;
    end;

     Message - это функция,  которая генерирует событие сообщения и
возвращает указатель на объект (если есть),  который обработал  это
событие.
     Заметим, что   TFileList.FocusItem   использует    расширенный
синтаксис Turbo   Pascal   (директива   компилятора   $X+),   чтобы
использовать функцию Message как  процедуру,  поскольку  результат,
возвращаемый Message, не нужен.


#Кто обрабатывает общие сообщения?

     Предположим, Вам требуется определить,  находится ли на панели
экрана открытое окно прежде,  чем выполнить некоторые действия. Как
это сделать?  Ваш код должен послать общее событие, на которое окна
знают как   ответить.   "Подпись",  оставленная  объектом,  который
обработал это событие, будет говорить Вам кто (если есть) обработал
его.


#Есть ли кто-нибудь?

     Конкретный пример.  В  IDE  Turbo  Pascal, если   пользователь
запрашивает открыть  окно  просмотра,  код,  который открывает окно
просмотра, должен проверить не открыто ли уже окно  просмотра. Если
нет, он открывает его; если есть, переносит наверх.
     Передача общего сообщения проста:

     AreYouThere := Message(DeskTop, evBroadcast, cmFindWindow,
                            nil);

     В методе  HandleEvent  окна  просмотра есть проверка на отклик
(очистка события) на команду cmFindWindow:

     case Event.Command of
       ...
       cmFindWindow: ClearEvent(Event);
       ...
     end;

     Вспомним, что ClearEvent не  только  устанавливает  поле  What
записи события в evNothing,  но так же устанавливает поле InfoPtr в
 @Self. Message читает эти поля и,  если  событие  было  обработано,
возвращает указатель на объект,  обработавший событие-сообщение.  В
данном случае это окно просмотра.  Так за строкой, которая посылала
сообщение, мы включим:

     if AreYouThere = nil then
       CreateWatchWindow
     else AreYouThere^.Select;

     Поскольку окно  просмотра  - это единственный объект,  который
знает как отвечать на общее сообщение cmFindWindow,  Ваш код  может
быть уверен, что когда он выполнится, будет одно и только одно окно
просмотра на вершине всех видимых элементов на панели экрана.


#Кто сверху?

     Используя технику,  описанную ранее, Вы так же можете например
определить, какое окно является верхним из  видимых  элементов  его
типа на панели экрана. Поскольку общее сообщение посылается каждому
подэлементу модального  видимого  элемента  в  Z-порядке   (порядок
обратный вставке),  самый  последний  вставленный видимый элемент -
это "верхний" видимый элемент на панели экрана.
     Рассмотрим ситуацию,  возникающую  в  IDE,  когда пользователь
имеет окно просмотра,  открытое на вершине панели экрана  во  время
пошагового выполнения  кода в окне редактора.  Окно просмотра может
быть активным окном (двойная рамка),  но курсор выполнения  в  окне
кода требует  сохранения  трассы  выполнимого кода.  Если на панели
экрана открыто несколько окон редактора, они могут не перекрываться
вообще, но  IDE  должен знать какое из окон редактора предназначено
для трассировки.
     Ответ: конечно   самое   верхнее   окно   редактора,   которое
определено как последнее вставленное.  Для того,  чтобы определить,
какое из  окон "верхнее",  IDE посылает общее сообщение,  отклик на
которое знают только окна редактора. Первое окно редактора, которое
получает общее   сообщение   и  будет  последним  вставленным;  оно
обработает событие,  очищая  его,   и   IDE   узнает   какое   окно
использовать для  трассировки кода,  читая результат,  возвращенный
Message.


#Вызов HandleEvent.

     Вы так  же можете создать или модифицировать событие,  а затем
вызвать HandleEvent напрямую. Вы можете сделать 3 типа вызовов:
     1. Вы  можете  иметь  видимый элемент,  вызывающий HandleEvent
равного подэлемента  прямо.  ("Равные"  видимые  элементы   -   это
подэлементы с  одним  владельцем).  Сообщение  не передается другим
видимым элементам.  Оно  идет  прямо  к  этому  HandleEvent,  затем
управление возвращается к Вам.
     2. Вы можете  вызвать  HandleEvent  владельца.  Событие  будет
затем распространяться вниз по цепочке видимых элементов.  (Если Вы
вызываете  HandleEvent  из  Вашего  собственного  HandleEvent,  Ваш
HandleEvent будет вызываться рекурсивно.) Управление передается Вам
после обработки события.
     3. Вы  можете  вызвать HandleEvent видимого элемента из другой
цепочки видимых элементов.  Событие будет передаваться вниз по этой
цепочке видимых   элементов.   Управление   передается   Вам  после
обработки события.


#Контекстная помощь.

     Turbo Vision имеет встроенный инструмент, который помогает Вам
реализовать контекстно-ориентированную помощь в Вашей программе. Вы
можете назначить  номер  контекстной  подсказки видимому элементу и
когда видимый элемент станет активным,  номер его подсказки  станет
текущим номером контекстной подсказки в программе.
     Чтобы создать глобальную контекстно-ориентированную подсказку,
Вы можете  реализовать  HelpView,  который знает номера контекстных
подсказок, определенных Вами.  Когда  вызывается  HelpView  (обычно
нажатием F1 или другой горячей клавиши),  он должен спросить своего
владельца о текущем контексте подсказки,  вызвав метод  GetHelpCtx.
Затем HelpView  может  читать  и  отображать  соответствующий текст
подсказки. Пример HelpView включен  в  дистрибутивные  диски  Turbo
Pascal.
     Контекстно-ориентированная помощь -  это,  вероятно,  одна  из
последних  возможностей,  которую  Вы  будете реализовывать в Вашей
программе, поэтому  объекты   Turbo   Vision   инициализируются   с
контекстом hcNoContext по умолчанию,  что означает предопределенный
контекст, который не изменяет текущего контекста. При необходимости
Вы можете  разработать номера подсказок,  затем вставить правильный
номер в соответствующий видимый элемент,  вызвав  SetHelpCtx  сразу
после создания видимого элемента.
     Контекстная подсказка так же используется строкой  статуса для
определения, какие  видимые  элементы отображаются.  Вспомним,  что
когда Вы  создаете  строку  статуса,  Вы  вызываете   NewStatusDef,
который определяет  набор  элементов  статуса для данного диапазона
значений контекстной помощи. Когда новый видимый элемент становится
активным, контекст  помощи этого элемента определяет,  какая строка
статуса будет отображаться.

@ГЛАВА 6. НАПИСАНИЕ НАДЕЖНЫХ ПРОГРАММ.

#Написание надежных программ

     Обработка ошибок в интерактивном  пользовательском  интерфейсе
намного сложнее, чем в утилитах командной строки. В неинтерактивной
программе совешенно приемлемо,  что  ошибки  программы  приводят  к
выводу сообщения  об  ошибке  и  завершению  программы.  Однако,  в
интерактивных программах необходимо  восстановить  состояние  после
ошибки и  оставить  пользователя в приемлемом состоянии.  Ошибки не
должны приводит к разрушению информации пользователя  и  не  должны
завершать программу  вне  зависимости  от  их  природы.  Программа,
удовлетворяющая этим критериям, считается "надежной".
     Turbo Vision    помогает   писать   надежные   программы.   Он
поддерживает стиль программирования, который позволяет более просто
обнаружить ошибку  и  восстановить  состояние,  особенно коварную и
хитрую ошибку  Out  of  memory.   Это   обеспечивается   поддержкой
концепции атомарных операций.


#Все или ничего.

     Атомарная операция -  это  операция,  которая  не  может  быть
разбита на  более  мелкие  операции.  Или  в данном контексте,  это
операция, которая либо полностью ошибочна,  либо полностью успешна.
Создание атомарных  операций  особенно  полезно  при  распределении
памяти.
     Обычно программа  распределяет  память  небольшими  кусочками.
Например при создании диалогового окна Вы распределяете  память под
диалоговое окно,  а затем под каждый элемент управления.  Каждое из
этих распределений  потенциально  может  быть  неудачным  и  каждая
возможная ошибка   требует   проверки,   можете  ли  Вы  продолжать
распределение или должны  остановиться.  Если  любое  распределение
ошибочно, Вам    необходимо   освободить   память,   которая   была
распределена успешно.  В идеале Вы  должны  делать  проверку  после
каждого распределения. Введите пул надежности.


#Пул надежности.

     Turbo Vision устанавливает фиксированное количество памяти (по
умолчанию 4К)  в  конце  кучи,  называемое  пулом надежности.  Если
распределение памяти в  куче  достигает  пула  надежности,  функция
Turbo Vision   LowMemory   возвращает   True.   Это  означает,  что
последующие распределения ненадежны и могут привести к ошибке.
     Чтобы использование пула надежности давало эффект,  пул должен
быть больше,  чем  максимальное  атомарное  распределение.  Другими
словами, он должен быть достаточно большим, чтобы все распределения
между проверками LowMemory были успешными;  4К должны удовлетворять
большинство программ.   (Размер   пула  надежности  устанавливается
переменной LowMemSize).
     Использование традиционного  подхода  при распределении памяти
создает диалоговое окно:

     OK := True;
     R.Assign(20,3,60,10);
     D := New(Dialog, Init(R, 'My dialog'));
     if D <> nil then
     begin
       with D^ do
       begin
         R.Assign(2,2,32,3);
         Control := New(PStaticText, Init(R,
           'Do you really wish to do this?'));
         if Control <> nil then Insert(Control)
         else OK := False;
         R.Assign(5,5,14,7);
         Control := New(PButton, Init(R, '~Y~es', cmYes));
         if Control <> nil then Insert(Control)
         else OK := False;
         R.Assign(16,6,25,7);
         Control := New(PButton, Init(R, '~N~o', cmNo));
         if Control <> nil then Insert(Control)
         else OK := False;
         R.Assign(27,5,36,7);
         Control := New(PButton, Init(R, '~C~ancel', cmCancel));
         if Control <> nil then Insert(Control)
         else OK := False;
       end;
       if not OK then Dispose(D, Done);
     end;

     Заметим, что переменная OK используется для указания ошибочных
распределений. Если  произошла  ошибка,  все диалоговое окно должно
быть удалено.  Вспомним,  что  удаление  диалогового  окна  так  же
удаляет все его подэлементы.  С другой стороны,  с пулом надежности
весь этот блок кода может интерпретироваться как атомарная операция
и код изменяется:

     R.Assign(20,3,60,10);
     D := New(Dialog, Init(R, 'My dialog'));
     with D^ do
     begin
       R.Assign(2,2,32,3);
       Insert(New(PStaticText, Init(R,
         'Do you really wish to do this?')));
       R.Assign(5,5,14,7);
       Insert(New(PButton, Init(R, '~Y~es', cmYes)));
       R.Assign(16,6,25,7);
       Insert(New(PButton, Init(R, '~N~o', cmNo)));
       R.Assign(27,5,36,7);
       Insert(New(PButton, Init(R, '~C~ancel', cmCancel)));
     end;
     if LowMemory then
     begin
       Dispose(D, Done);
       OutOfMemory;
       DoIt := False;
     end;
     else
       DoIt := DeskTop^.ExecView(D) = cmYes;

     Поскольку пул надежности достаточно  велик  для  распределения
всего диалогового  окна,  которое требует менее 4К,  этот код может
предполагать, что  все  распределения  успешны.  После  того,   как
диалоговое окно  полностью  распределится,  проверяется  переменная
LowMemory, и если она True,  то все диалоговое  окно  уничтожается;
иначе используется.


#Метод ValidView.

     Поскольку LowMemory проверяется достаточно часто, TApplication
имеет метод  ValidView,  который  может  вызываться  для выполнения
необходимой проверки.  Используя ValidView, проверка if в последних
8 строках может быть заменена на 2 строки:

     DoIt := (ValidView(D) <> nil) and
       (DeskTop^.ExecView(D) = cmYes;

     ValidView возвращает  либо  указатель  на  переданный  видимый
элемент, либо  nil,  если  видимый элемент неверен.  Если LowMemory
возвращает True,  ValidView освобождает видимый элемент и  вызывает
OutOfMemory.


#Другие ошибки.

     Конечно не все ошибки  связаны  с  памятью.  Например  видимый
элемент может читать дисковый файл, а файл может быть не найден или
разрушен. Этот  тип  ошибки  должен  быть  указан  пользователю.  К
счастью ValidView  может  использовать встроенную обработку ошибок,
не связанных с памятью, вызывая метод Valid видимого элемента.
     TView.Valid возвращает   True   по   умолчанию.   TGroup.Valid
возвращает True только если все подэлементы,  принадлежащие группе,
возвращают True  из  их  функций  Valid.  Другими  словами,  группа
правильна, если все подэлементы этой  группы  правильны.  Когда  Вы
создаете видимый   элемент,  который  может  встретить  ошибку,  не
связанную с памятью,  Вам  необходимо  перекрыть  Valid  для  этого
видимого элемента так,  чтобы он возвращал True только при успешном
создании.
     Valid может  использоваться для указания,  что видимый элемент
не должен  использоваться  по  какой-то  причине;  например,   если
видимый элемент  не может найти файл.  Заметим,  что то,  ЧТО Valid
проверяет и КАК он проверяет зависит от Вас.  Типичный метод  Valid
имеет вид:

     function TMyView.Valid(Command: Word): Boolean;
     begin
       Valid := True;
       if Command = cmValid then
       begin
         if ErrorEncountered then
         begin
           ReportError;
           Valid := False;
         end;
       end;
     end;

     Когда создается  видимый  элемент,  метод  Valid  должен  быть
вызван с  параметром  Command,  равным  cmValid  для проверок любых
ошибок, не связанных с памятью,  возникших  при  создании  видимого
элемента. ValidView(X)  вызывает Х.Valid(cmValid) автоматически,  а
также проверяет пул  надежности,  так  что  вызов  ValidView  перед
использованием любого нового видимого элемента - это хорошая идея.
     Valid так же вызывается при завершении модального  состояния с
параметром Command в команде, завершающей модальное состояние. (См.
главу 4.) Это дает Вам возможность перехватывать такие условия, как
несохраненный текст в окне редактора до завершения Вашей программы.
     ErrorEnсountered может  быть   и   обычно   бывает   булевской
переменной экземпляра  объектного  типа,  который  указан  в вызове
Init.


#Сообщения об ошибках.

      До того,  как  метод  Valid  вернет  False,  он должен выдать
пользователю информацию об ошибке,  поскольку  видимый  элемент  не
появится на  экране.  Это  делал  ReportError в предыдущем примере.
Обычно он вызывает диалоговое окно с сообщением.  Каждый  отдельный
видимый элемент  отвечает  за  выдачу  сообщения  о  любых ошибках,
поскольку программа не знает  как  проверять  каждую  из  возможных
ситуаций.
     Это важное достижение в  технике  программирования,  поскольку
позволяет Вашей программе работать,  как если бы все было правильно
вместо того,  чтобы всегда смотреть что  может  быть  неправильным.
Групповые объекты,  включая  программу,  не  беспокоятся о проверке
ошибок за исключением  проверки,  если  какой-либо  из  их  видимых
элементов был  неверен.  В этом случае группа просто удаляет себя и
свои  подэлементы  и   указывает   своему   владельцу,   что   была
неправильной. Группа   может   предполагать,  что  ее  неправильный
подэлемент уже сообщил пользователю о проблеме.
     Использование Valid  позволяет  создавать  окна  и  диалоговые
окна, рассматривая их как атомарные  операции.  Каждый  подэлемент,
который создает  окно,  может  быть  создан без проверки на ошибку;
если констрактор неверен,  он просто установит Valid в False.  Если
любой подэлемент  окна  неверен,  все  окно  возвращает  False  при
проверке. ValidView будет освобождать окно и возвращать  nil.  Все,
что требуется сделать - это проверить результат ValidView.


#Основные потребители.

     Функция Valid   так   же    может    обрабатывать    "основных
потребителей",  т.е.  видимые элементы, которые распределяют память
больше,  чем размер пула надежности,  как например при чтении всего
файла  в  память.  Основные  потребители должны проверять LowMemory
сами вместо того,  чтобы ожидать когда они закончат все создание, а
после этого  позволят  ValidView сделать это за них.  Если основной
потребитель доходит до нехватки памяти в процессе  своего создания,
он устанавливает  свой  флаг,  который  указывает,  что встретилась
ошибка (как например флаг ErrorEncountered в предыдущем  примере) и
больше не пытается распределить память. Этот флаг будет проверяться
в Valid и видимый элемент будет вызывать Application^.OutOfMemory и
возвращать False из вызова Valid.
     Очевидно, что   делать   предположение    о    работе    Ваших
констракторов -  это не лучший вариант,  но это единственный способ
управлять создание видимых элементов, которые превышают размер пула
надежности.
     Программа FILEVIEW.PAS   демонстрирует   использование    этой
техники для реализации надежного просмотра файла.

@ГЛАВА 7. КОЛЛЕКЦИИ.

#Коллекции

     Программисты на Паскале традиционно тратят  много  времени  на
создание кода,  который  поддерживает  структуры данных,  такие как
связанные списки и динамические массивы.  В дейсвительности один  и
тот же  код  структуры данных переписывается и отлаживается снова и
снова.
     Традициооный Паскаль  обеспечивает  только встроенные записи и
массивы. Остальные структуры Вы должны разрабатывать сами.
     Например, если  Вы  собираетесь хранить данные в массиве,  Вам
необходимо написать код для создания массива, импортирования данных
в массив,  выборки данных из массива для обработки и, вероятно, для
вывода данных  на  устройство  В/В.  Позже,   когда   в   программе
потребуется новый тип элементов массива, Вы начнете все сначала.
     Было бы хорошо,  если бы тип массива поступал вместе с  кодом,
который будет обрабатывать большинство операций,  который Вы обычно
производите с массивом,  или если бы этот тип  массива  можно  было
расширить не изменяя оригинальный код.
     В этом назначение типа TCollection в Turbo Vision. Это объект,
который хранит  набор  указателей и предоставляет встроенные методы
для манипуляции ими.


#Объекты коллекции.

     Поскольку коллекция  -  это  объект  и,  следовательно,  имеет
методы, встроенные в него,  она имеет 2 дополнительные  возможности
по сравнению   с   массивами   Паскаля   -  динамический  размер  и
полиморфизм.


#Динамический размер.

     Размер стандартных  массивов Turbo Pascal фиксируется во время
компиляции и  это  удобно,  если  Вы  точно  знаете  размер  Вашего
массива, но  во  время  работы  Вашей  программы  он  иногда  может
заполняться не  полностью.  Изменение   размера   массива   требует
изменения кода и перекомпиляции.
     Для коллекции Вы устанавливаете первоначальный размер,  но  он
может динамически   увеличиваться   во   время   выполнения,  чтобы
соответствовать данным, хранящимся в нем. Это делает Вашу программу
более гибкой в ее компилированном виде.


#Полиморфизм.

     Второе свойство массивов, которое может стать ограничением для
Вашей программы  в  том,  что  каждый  элемент  массива должен быть
одного типа и этот тип определяется во время компиляции.
     Коллекции обходят  это  ограничение,  используя нетипированные
указатели. Это не  только  быстро  и  эффективно,  но  и  позволяет
коллекции содержать  объекты  (и даже не объекты) различных типов и
размеров. Так же как поток,  коллекция не должна  ничего  знать  об
обрабатываемых объектах. Она только хранит их и выдает по запросу.


#Проверка типов и коллекции.

     Коллекция обходит строгую проверку типа традиционного Паскаля.
Это означает, что Вы можете поместить в коллекцию что-либо и, когда
Вы выбираете эти данные обратно, компилятор не может проверить Ваши
предположения об этих данных.  Вы можете поместить в коллекцию один
объект и прочитать его обратно как  другой  и  коллекция  не  имеет
возможности предупредить Вас об этом.
     Как программист  на  Turbo  Pascal,   Вы   можете   испытывать
определенный дискомфорт  в  этой ситуации.  Проверка типов Паскаля,
кроме всего прочего,  сохраняет многие часы отлавливания  некоторых
неуловимых ошибок.  Слушайте внимательно: Вы можете не беспокоиться
о трудностях нахождения таких ошибок,  поскольку компилятор  найдет
их за   Вас!   Однако,  если  Ваша  программа  зависает,  тщательно
проверьте типы объектов, сохраняемых и извлекаемых из коллеций.


#Коллекции не объектов.

     Вы можете  так  же добавить в коллекцию данные,  не являющиеся
объектами, но это приведет к другой серьезной  проблеме.  Коллекции
ожидают получить нетипированные указатели на что-либо. Но некоторые
методы TCollection   предназначены    для    обработки    коллекций
экземпляров, порожденных  от  TObject.  Они  включают в себя методы
доступа к потоку PutItem и GetItem,  а так же стандартную процедуру
FreeItem.
     Это означает,  что Вы можете сохранить PString в коллекции, но
если Вы  попытаетесь  передать  эту коллекцию в поток,  Вы получите
неудовлетворительные результаты,  если  не  перекроете  стандартные
методы GetItem и PutItem. Аналогично, когда Вы пытаетесь освободить
коллекцию, она освобождает каждый элемент, используя FreeItem. Если
Вы хотите  использовать  в коллекции элементы не типа TObject,  Вам
необходимо переопределить смысл "элемента"  в  GetItem,  PutItem  и
FreeItem. В TStringCollection, например, делается именно это.
     Если Вы работаете с осторожностью,  Вы  найдете  коллекции  (и
объекты, порожденные    от    коллекций)    быстрыми,   гибкими   и
настраиваемыми структурами данных.


#Создание коллекции.

     Создать коллекцию  так  же просто,  как определить тип данных,
который Вы хотите хранить. Предположим, что Вы консультант и хотите
хранить и  использовать  табельный  номер,  имя  и  номер  телефона
каждого из Ваших клиентов.  Для начала  определите  объект  клиента
(TClient), который будет храниться в коллекции:

     (*Не забудьте определить указатель на каждый новый тип объекта*)
     type
       PClient = ^TClient;
       TClient = object(TObject)
         Account, Name, Phone: PString;
         constructor Init(NewAccount, NewName, NewPhone: String);
         destructor Done; virtual;
       end;

     Затем Вы реализуете методы Init и  Done  для  распределения  и
освобождения данных   клиента.   Заметим,  что  поля  объекта  типа
PString, так что  память  распределяется  только  под  используемую
часть строки. Функции NewStr и DisposeStr обрабатывают динамические
строки очень эффективно.

     constructor TClient.Init(NewAccount, NewName, NewPhone:
                              String);
     begin
       Account := NewStr(NewAccount);
       Name := NewStr(NewName);
       Phone := NewStr(NewPhone);
     end;

     destructor TClient.Done;
     begin
       Dispose(Account);
       Dispose(Name);
       Dispose(Phone);
     end;

     TClient.Done вызывается  автоматически для каждого клиента при
удалении всей коллекции. Сейчас Вы создадите коллекцию для хранения
Ваших клиентов  и  вставите  записи  клиентов  в нее.  Тело главной
программы:

     (* TVGUID17.PAS *)
     var
       ClientList: PCollection;

     begin
       ClientList := New(PCollection, Init(50, 10));
       with ClientList^ do
       begin
         Insert(New(PClient, Init('90-167', 'Smith, Zelda',
                '(800) 555-1212')));
         Insert(New(PClient, Init('90-160', 'Johnson, Agatha',
                '(302) 139-8913')));
         Insert(New(PClient, Init('90-177', 'Smitty, John',
                '(406) 987-4321')));
         Insert(New(PClient, Init('90-160', 'Anders Smitty',
                '(406) 111-2222')));
       end;
       PrintAll(ClientList);
       SearchPhone(ClientList, '(406)');
       Dispose(ClientList, Done);
     end.

     Заметьте как  легко   создать   коллекцию.   Первый   оператор
распределяет  новую TCollection с именем ClientList,  который имеет
начальный размер 50 клиентов.  Если в ClientList вставлено более 50
клиентов, ее размер увеличивается с шагом 10 клиентов.  2 последних
оператора создают новый объект клиента и вставляют его в коллекцию.
Dispose освобождает всю коллекцию.
     Вы нигде не говорили коллекции,  какого вида данные она  будет
хранить - ей только передан указатель.


#Итерационные методы.

     Вставка и удаление являются не  единственными  операциями  над
коллекциями. Часто Вы пишете циклы for для прохода по всем объектам
коллекции для   отображения   данных   или   выполнения   некоторых
вычислений. Так  же  часто  необходимо  найти  первый или последний
элемент в коллекции,  удовлетворяющий  определенному  условию.  Для
этих целей   коллекция   имеет   3  итерационных  метода:  ForEach,
FirstThat и  LastThat.  Каждый  из  них  использует  указатель   на
процедуру или функцию как единственный параметр.


#Итератор ForEach.

     ForEach берет указатель на процедуру.  Эта процедура  имеет  1
параметр -  указатель на элемент,  хранящийся в коллекции.  ForEach
вызывает эту процедуру 1  раз  для  каждого  элемента  коллекции  в
порядке, в  котором  элементы  появляются  в  коллекции.  Процедура
PrintAll в TVGUID17 приводит пример итератора ForEach.

     procedure PrintAll(C: PCollection);

       procedure PrintClient(P : PClient); far;
       begin
         with P^ do
           Writeln(Account^, '':20-Length(Account^),
                   Name^, '':20-Length(Name^),
                   Phone^, ''20-Length(Phone^));
       end;

     begin
       Writeln;
       Writeln;
       C^.ForEach(@PrintClient); (* вызывает PrintClient для каждого
                                   элемента из С*)
     end;

     Для каждого  элемента коллекции,  передаваемого как параметр в
PrintAll, вызывается вложенная процедура  PrintClient.  PrintClient
просто печатает  информацию  объекта  о  клиенте  в форматированном
виде.
     Вам необходимо   осторожно   выбирать  процедуры,  которые  Вы
вызываете с итераторами.  В этом примере  PrintClient  должна  быть
процедурой -  она не может быть методом объекта - и она должна быть
локальной (вложенной в тот же блок) в программе,  которая  вызывает
ее. Она  так  же должна быть объявлена как дальняя процедура либо с
помощью директивы far,  либо с помощью директивы  компилятора  $F+.
Наконец, процедура должна использовать один параметр - указатель на
элемент коллекции.


#Итераторы LastThat и FirstThat.

     В дополнении  к  возможности  применять  процедуру  к  каждому
элементу коллекции  часто  необходимо  найти  определенный  элемент
коллекции на  основании  заданного  критерия.  Это делают итераторы
FirstThat и LastThat. Они просматривают коллекцию в противоположных
направлениях до  тех пор,  пока не найдут элемент,  соответствующий
критерию булевской функции, переданной как аргумент.
     FirstThat и  LastThat  возвращают  указатель  на  первый  (или
последний) элемент,   который   соответствует   условиям    поиска.
Рассмотрим предыдущий пример списка клиентов и вообразим, что Вы не
можете вспомнить номер клиента  или  как  точно  пишется  его  имя.
Однако  Вы  помните,  что  это  был первый клиент из штата Montana.
Поэтому Вы будете искать первое вхождение  клиента  с  кодом  штата
406. Процедура, выполняющая этот поиск:

     procedure SearchPhone(C: PClientCollection;
                           PhoneToFind: String);

       function PhoneMatch(Client: PClient): Boolean; far;
       begin
         PhoneMatch := Pos(PhoneToFind, Client^.Phone^) <> 0;
       end;

     var
       FoundClient: PClient;
     begin
       FoundClient := C^.FirstThat(@PhoneMatch);
       if FoundClient = nil then
         Writeln('No client met the search requirement')
       else
         with FoundClient^ do
           Writeln('Found client: ', Account^, ' ', Name^, ' ',
                   Phone^);
     end;

     Опять заметим,  что  PhoneMatch вложенная и использует дальнюю
модель вызова.  Эта  функция  возвращает  True  только  если  номер
телефона клиента  и  шаблон поиска совпадают.  Если в коллекции нет
объекта, соответствующего критерию поиска,  возвращается  указатель
nil.
     Запомните: ForEach    вызывает     процедуру,     определенную
пользователем, а  FirstThat  и LastThat вызывают булевскую функцию,
определенную пользователем. Во всех случаях им передается указатель
на объект в коллекции.


#Отсортированные коллекции.(II)

     Иногда Вам  необходимо  иметь  Ваши  данные   в   определенном
порядке. Turbo   Vision  обеспечивает  специальный  тип  коллекции,
который позволяет  Вам  упорядочить  Ваши  данные  любым  способом:
TSortedCollection.
     TSortedCollection порожден  от  TCollection  и   автоматически
сортирует получаемые  объекты.  Он  так  же автоматически проверяет
коллекцию, когда   добавляется   новый    элемент    и    отвергает
дублированные элементы.
     TSortedCollection - это абстрактный  тип.  Чтобы  использовать
его, Вы должны вначале решить,  какой тип данных Вы будете помещать
в коллекцию  и  определить  2   метода,   соответствующие   способу
сортировки. Чтобы   сделать  это,  Вам  нужно  породить  новый  тип
коллекции от  TSortedCollection.  В  нашем   случае   назовем   его
TClientCollection.
     Ваш TClientCollection уже знает  как  делать  всю  работу  над
коллекцией. Он  может  вставить  новые  записи  клиентов  и удалить
существующие, поскольку   наследует   все   основы   поведения   от
TCollection. Вам необходимо только научить TClientCollection, какое
поле использовать  как  ключ  сортировки  и  как  сравнивать   двух
клиентов и  определять,  какой  из  них  находится  перед  другим в
коллекции. Вы делаете это,  перекрывая методы  KeyOf  и  Compare  и
реализуя их как показано здесь:

     PClientCollection = ^TClientCollection;
     TClientCollection = object(TSortedCollection)
       function KeyOf(Item: Pointer): Pointer; virtual;
       function Compare(Key1, Key2: Pointer): Integer; virtual;
     end;

     function TClientCollection.KeyOf(Item: Pointer): Pointer;
     begin
       KeyOf := PClient(Item)^.Name;
     end;

     function TClientCollection.Compare(Key1, Key2: Pointer):
                                        Integer;
     begin
     (*необходимо использовать приведение типа для ключей, поскольку
      они - нетипированные указатели *)
       if PString(Key1)^ = PString(Key2)^ then
         Compare := 0
       else if PString(Key1)^ < PString(Key2)^ then
         Compare := -1
       else
         Compare := 1;
     end;

     KeyOf определяет,  какое  поля  или поля должны использоваться
как ключ сортировки.  В нашем  случае  -  это  поле  Name  клиента.
Compare берет  2  ключа сортировки и определяет какой из них должен
стоять первым. Compare возвращает -1, 0 или 1 взависимости от того,
является ли  Key1  меньше,  равным  или  больше  Key2.  Этот пример
использует алфавитную сортировку строк ключей.
     Заметим, что    поскольку    ключи,   возвращаемые   KeyOf   и
передаваемые Compare -  нетипированные  указатели,  Вам  необходимо
выполнить приведение типа в PString до ссылки на них.
     Это все,  что  Вы   должны   определить!   Сейчас,   если   Вы
переопределите ClientList  как PClientCollection вместо PCollection
(изменив объявление  var  и  вызов  New),  Вы  распечатаете   Ваших
клиентов в алфавитном порядке.


     (* TVGUID18.PAS *)
     var
       ClientList: PClientCollection;
     ...
     begin
       ClientList := New(PClientCollection, Init(50, 10));
       ...
     end;

     Заметьте как   просто   сделать  распечатку  списка  клиентов,
отсортированного по номерам,  а не по имени.  Вам необходимо просто
изменить метод KeyOf на возврат поля ACount вместо поля Name.


#Коллекции строк.

     Многим программам необходимо хранить  отсортированные  строки.
Для этого   Turbo   Vision   предоставляет   специальную  коллекцию
TStringCollection. Заметим,  что элементы  TStringCollection  -  не
объекты, это указатели на строки Turbo Pascal.  Поскольку коллекция
строк наследуется от  TSortedCollection,  дублированные  строки  не
сохраняются.
     Использовать коллекции   строк   просто.    Просто    объявите
переменную указателя  на коллекцию строк.  Распределение коллекции,
задание начального размера и приращение  при  расширении  коллекции
определены:

     (* TVGUIDE19.PAS *)
     var
       WordList: PCollection;
       WordRead: String;
       ...
     begin
       WordList := New(PStringCollection, Init(10, 5));
       ...


     WordList первоначально хранит 10 строк,  а затем увеличивается
с приращением 5.  Все,  что Вы делаете - это  вставляете  строки  в
коллекцию. В  этом  примере  слова  читаются  из текстового файла и
вставляются в коллекцию:

     repeat
       ...
       if WordRead <> '' then
         WordList^.Insert(NewStr(WordRead));
         ...
     until WordRead = '';
     ...
     Dispose(WordList, Done);

     Заметим, что  функция  NewStr  используется для создания копии
слова, которое было прочитано,  и адрес копии строки  передается  в
коллекцию. Когда  используется  коллекция,  Вы  всегда передаете ей
управление над собираемыми данными. Она будет тщательно освобождать
данные, когда Вы закончите работу. Это будет соответствовать вызову
Dispose; он  освобождает  каждый   элемент   коллекции,   а   затем
освобождает саму коллекцию WordList.


#Опять итераторы.

     Метод ForEach проходит по всей  коллекции  и  передает  каждый
элемент в  предоставленную  Вами  процедуру.  Продолжая  предыдущий
пример, процедура  PrintWord  получает  указатель  на  отображаемую
строку. Заметьте,   что   PrintWord   вложенная   (или   локальная)
процедура. Print использует  метод  ForEach  для  передачи  каждого
элемента коллекции в процедуру PrintWord.

     procedure Print(C: PCollection);

     procedure PrintWord(P : PString); far;
     begin
       Writeln(P^);
     end;

     begin (* Print *)
       Writeln;
       Writeln;
       C^.ForEach(@PrintWord);
     end;


     Вызов PrintWord   выглядит  привычно.  Это  просто  процедура,
которая берет  указатель  на  строку  и  передает  его  значение  в
Writeln. Заметим директиву far в объявлении PrintWord. PrintWord не
может быть  методом  -  она  должна  быть  процедурой.   (Процедура
CallDraw в  TVGUID20.PAS  показывает  как  вызвать  метод  в вызове
итератора). Она так же должна быть вложенной процедурой.  Вы можете
использовать более одной процедуры,  такой как PrintWord, но каждая
должна быть вложена в Print и должна быть дальней процедурой.


#Поиск элемента.

     Отсортированные коллекции  (и  следовательно  коллекции строк)
имеют метод Search,  который возвращает индекс элемента с  заданным
ключем.  Как  Вам найти элемент в неотсортированной коллекции?  Или
как найти элемент,  когда критерий поиска не включает ключ? Конечно
необходимо использовать FirstThat и LastThat. Вы просто определяете
булевскую функцию с нужным критерием поиска и вызываете FirstThat.


#Полиморфные коллекции.

     Вы видите,  что  коллекции  могут  хранить  любой  тип  данных
динамически и что они содержат методы,  помогающие  Вам  эффективно
обращаться к   данным  коллекции.  В  действительности  TCollection
определяете 23 метода.  Когда  Вы  используете  коллекции  в  Ваших
программах, Вы удивитесь скорости их работы. Они спроектированы для
обеспечения гибкости и реализованы на удивление быстрыми.
     Сейчас Вы  увидите  реальную  мощь  коллекций:  элементы могут
обрабатываться полиморфно.  Это  означает,  что  Вы  можете  делать
больше, чем  просто  сохранять  тип объекта в коллекции;  Вы можете
хранить множество  различных  типов  объектов  из  любого  места  в
иерархии объектов.
     В примерах,  которые мы рассматривали до сих пор, все элементы
коллекции были  одного  типа.  Но  коллекции  могут  хранить  любые
объекты, порожденные от TObject и Вы можете свободно  смешивать эти
объекты. Обычно   Вам   необходимо  иметь  объекты  с  определенным
сходством.
     Как пример рассмотрим программу,  которая помещает 3 различных
графических объекта   в   коллекцию.   Затем    итератор    ForEach
используется для   прохода   по  коллекции  и  отображения  каждого
объекта.
     Этот пример  использует  модуль Graph и драйверы BGI,  поэтому
выо время компиляции GRAPH.TPU должен быть  в  текущем  справочнике
или в  справочниках  модулей  (Options/Directories/Unit Directory).
При выполнении  программы  перейдите   в   справочник,   содержащий
драйверы .BGI  или модифицируйте вызов InitGraph,  чтобы указать их
расположение (например C:\TP\BGI).
     Вначале определим объект абстрактного предка.

     (* TVGUID20.PAS *)
     type
       PGraphObject = ^TGraphObject;
       TGraphObject = object(TObject)
         X,Y: Integer;
         constructor Init;
         procedure Draw; virtual;
       end;

     Вы видите из этого объявления,  что каждый графический  объект
может инициализироваться   (Init)  и  отображаться  на  графическом
экране (Draw).  Теперь определим точку, окружность и прямоугольник,
наследуя их от общего предка:

     PGraphPoint = ^TGraphPoint;
     TGraphPoint = object(TGraphObject)
       constructor Init;
       procedure Draw; virtual;
     end;

     PGraphCircle = ^TGraphCircle;
     TGraphCircle = object(TGraphObject)
       Radius: Integer;
       constructor Init;
       procedure Draw; virtual;
     end;

     PGraphRect = ^TGraphRect;
     TGraphRect = object(TGraphObject)
       Width, Height: Integer;
       constructor Init;
       procedure Draw; virtual;
     end;

     Эти 3 объекта наследуют поля X и Y от PGraphObject,  но  имеют
различные размеры.  PGraphCircle  добавляет  Radius,  а  PGraphRect
добавляет Width и Height. Следующий код создает коллекцию:

     ...
     List := New(PCollection, Init(10, 5));

     for I := 1 to 20 do
     begin
       case I mod 3 of
         0: P := New(PGraphPoint, Init);
         1: P := New(PGraphCircle, Init);
         2: P := New(PGraphRect, Init);
       end;
       List^.Insert(P);
     end;
     ...

     Как Вы видите,  цикл for вставляет 20 графических  объектов  в
коллекцию List.  Все,  что Вы знаете,  это то,  что каждый объект в
List - какого-то из типов от  TGraphObject.  После  того,  как  они
вставлены в коллекцию, неважно какой из элементов окружность, точка
и прямоугольник.  Благодаря полиморфизму Вам не нужно знать сколько
данных  содержит  каждый  объект  и какой код (Draw) ему требуется.
Просто пройдем  по  коллекции,  используя  метод итератора и каждый
объект отобразит себя сам:

     procedure DrawAll(C: PCollection);

     procedure CallDraw(P : PGraphObject); far;
     begin
       P^.Draw;
     end;

     begin (* DrawAll *)
       C^.ForEach(@CallDraw);
     end;

     var
       GraphicsList: PCollection;
     begin
       ...
       DrawAll(GraphicsList);
       ...
     end.

     Возможность коллекции хранить  различные,  но  взаимосвязанные
объекты   опирается   на   один   из   мощных  краеугольных  камней
объектно-ориентированного программирования.  В следующей  главе  Вы
увидите  как  принцип  полиморфизма  с равным успехом применяется к
потокам.


#Коллекции и управление памятью.

     TCollection может   динамически   расти   от   первоначального
размера, установленного в  Init  до  максимального  размера  16,380
элементов. Максимальный  размер  коллекции  хранится  в  переменной
MaxCollectionSize Turbo  Vision.   Каждый   элемент,   который   Вы
добавляете в  коллекцию,  требует только 4 байта памяти,  поскольку
элемент хранится как указатель.  Библиотека  динамических  структур
данных не   будет   полной,   если   ее   не  обеспечить  средством
обнаружения ошибок.  Если для инициализиции коллекции  недостаточно
памяти,  возвращается указатель nil. Если при добавлении элемента в
TCollection недостаточно памяти, вызывается метод TCollection.Error
и   генерируется  ошибка  времени  выполнения  в  куче.  Вы  можете
перекрыть TCollection.Error,  чтобы самому  выдавать  сообщение  об
ошибке или реализовать механизм восстановления.
     Вы должны обратить особое внимание на обработку  ошибок  кучи,
поскольку пользователь  имеет  в  программе  Turbo  Vision  гораздо
больше возможностей,  чем в традиционной программе на Паскале. Если
пользователь управляет  добавлением  объектов в коллекцию (например
открывая новые окна на  панели  экрана),  не  всегда  будет  просто
предупредить ошибку  кучи.  Вам  может понадобиться предпринять ряд
шагов для  защиты  пользователя   от   фатальной   ошибки   времени
выполнения либо  используя собственные проверки памяти при работе с
коллекцией, либо обработчик ошибок времени выполнения.

@ГЛАВА 8. ПОТОКИ.

#Потоки

     Техника объектно-ориентированного  программирования  и   Turbo
Vision дают  Вам  мощный способ инкапсуляции данных и кода и мощные
способы построения взаимосвязанных структур объекта. Но что если Вы
хотите просто сохранить объекты на диске?
     До последнего времени данные хранились в записях и  запись  на
диск была  проста,  но  данные  внутри  Turbo  Vision в большинстве
случаев находятся внутри  объектов.  Конечно,  Вы  можете  отделить
данные от  объекта  и записать их на диск.  Но поскольку совместное
хранение данных и кода  дает  большие  преимущества,  разделить  их
снова было бы шагом назад.
     Не могут ли ООП и Turbo Vision  как-то  решить  эту  проблему?
Имеено для этого разработаны потоки.
     Поток Turbo Vision - это  коллекция  объектов  с  определенным
способом хранения:  обычно в файле, EMS, последовательном порту или
некотором другом устройстве.  Потоки  обрабатывают  В/В  на  уровне
объекта, а  не  на уровне данных.  Когда Вы расширяете объект Turbo
Vision, Вам необходимо  обеспечить  обработку  всех  полей  данных,
которые Вы определяете.


#Вопрос - В/В объектов.

     Как программист на Паскале Вы знаете,  что  до  того,  как  Вы
сможете выполнять  В/В,  Вы  должны  сказать  компилятору какой тип
данных Вы будете  читать  или  писать  в  файл.  Файл  должен  быть
типированным и тип должен быть определен во время компиляции.
     Turbo Pascal реализует  очень  полезное  исключение  из  этого
правила: доступ   к   нетипированному   файлу  через  BlockWrite  и
BlockRead. Но  обход  проверки  типов  создает   для   программиста
определенные сложности,  хотя позволяет ему выполнять очень быстрый
двоичный В/В.
     Вторая проблема  в  том,  что  Вы не можете использовать файлы
прямо с объектами.  Turbo Pascal не позволяет Вам создать файл типа
объекта. И  поскольку  объекты  могут содержать виртуальные методы,
адрес которых  определяется   во   время   выполнения,   сохранение
информации VMT вне программы бессмысленно;  чтение такой информации
в программу еще более бессмысленно.
     Вы можете обойти эту проблему. Вы можете скопировать данные из
Ваших объектов и сохранить эту информацию в файле,  а затем  заново
построить объекты  из  этих данных.  Но это не элегантное решение и
усложняет создание объектов.


#Ответ - потоки.

     Turbo Vision  позволяет  Вам  обойти  обе трудности,  а так же
предоставляет некоторые    дополнительные    возможности.    Потоки
предоставляют простой,   чрезвычайно   элегантный  способ  хранения
данных объекта вне программы.


#Потоки являются полиморфными.

     Поток Turbo  Vision  дает  Вам  преимущество  и типированных и
нетипированных файлов:  проверка типов еще выполняется,  но то, что
Вы хотите  послать  в  поток,  не  обязано  определяться  во  время
компиляции. Причина этого в том,  что потоки знают как они работают
с объектами и,  если только объект порожден от TObject, поток может
обрабатывать его.  В самом деле,  различные  объекты  Turbo  Vision
можно легко записать в один поток, как группу идентичных объектов.


#Управление объектами в потоке.

     Все, что Вы должны сделать - это определить для  потока, какие
объекты он должен обрабатывать, чтобы он знал как совместить данные
с VMT.  Затем Вы можете поместить объекты в  поток  и  получить  их
обратно без малейших усилий.
     Но как можно читать и писать  в  один  поток  такие  различные
объекты как  TDeskTop и TDiаlog и во время компиляции не знать даже
какие объекты  будут  обрабатываться?  Это  сильно  отличается   от
В/В традиционного   Паскаля.   В   действительности   поток   может
обрабатывать даже новые типы объектов,  которые еще не были созданы
в момент компиляции потока.
     Это решается с помощью регистрации. Каждому типу объекта Turbo
Vision (и новым типам объектов,  которые Вы порождаете из иерархии)
назначается уникальный   регистрационный    номер.    Этот    номер
записывается в поток перед данными объекта. Затем, когда Вы читаете
объект из потока,  Turbo Vision берет регистрационный  номер  и  на
основании его   знает   сколько   данных   прочитать  и  какую  VMT
подсоединить к Вашим данным.


#Сущность использования потоков.

     На фундаментальном  уровне  Вы  можете  думать о потоках как о
файлах Паскаля.  В  своей  основе  файл  Паскаля   -   это   просто
последовательное устройство В/В,  Вы просто пишите в него и читаете
из него.  В свою очередь поток - это  полиморфное  последовательное
устройство В/В,  что  означает,  что  он  ведет  себя  так же,  как
последовательный файл,  но Вы можете так же читать и писать объекты
различного типа.
     Потоки можно так же рассматривать (как и  файлы  Паскаля)  как
устройство В/В  с прямым доступом,  где Вы устанавливаете позицию в
файле, читаете  или  пишите  с  этой  точки,  возвращаете   позицию
указателя файла  и  т.д.  Эти операции так же доступны с потоками и
описаны в разделе "Прямой доступ к потокам".
     Существует 2  аспекта использования потока,  которые Вы должны
хорошо себе представлять и к счастью они оба очень просты. Первый -
это установка потока, второй - чтение и запись объектов в поток.


#Установка потока.

     Для использования потока  Вы  должны  просто  инициализировать
его. Точный    синтаксис   констрактора   Init   будет   изменяться
в зависимости от  типа  используемого  потока.  Например,  если  Вы
открываете поток DOS,  Вам требуется передать имя файла DOS и режим
доступа (чтение, запись, чтение/запись) к файлу, содержащему поток.
     Например, чтобы  инициализировать буферизованный поток DOS для
загрузки объекта панель экрана в программу, Вам требуется только:

     var
       SaveFile: TBufStream;
     begin
       SaveFile.Init('SAMPLE.DSK', stOpen, 1024);
       ...

     После того,  как Вы  инициализировали  поток,  Вы  можете  его
использовать.
     TStream - это абстрактный  механизм  потока  и  Вы  не  можете
создать экземпляр  от  него,  но  все  объекты потоков порождены от
TStream. Они  включают  TDosStream,  обеспечивающий  дисковый  В/В,
TBufStream, обеспечивающий  буферизованный  В/В  с  диска (полезен,
если Вы читаете или  пишите  большое  количество  небольших  кусков
данных)  и  TEmsStream,  который  пересылает  объекты  в EMS память
(особенно полезен для реализации быстрых ресурсов).
     Turbo Vision   так   же  реализует  индексированные  потоки  с
указателем на место  в  потоке.  Изменяя  положение  указателя,  Вы
можете осуществлять прямой доступ к потоку.


#Чтение и запись потока.

     Базовый объект потоков TStream реализует  3  основных  метода:
Get, Put и Error.  Get и Put примерно соответствуют процедурам Read
и Write.  Процедура Error вызывается  при  возникновении  ошибки  в
потоке.


#Вывод в поток.

     Вначале рассмотрим процедуру Put. Общий синтаксис метода Put:

     SomeStream.Put(PSomeObject);

     где SomeStream - это любой объект,  порожденный от  TStream  и
инициализированный, а  PSomeObject - это указатель на любой объект,
порожденный от TObject и зарегистрированный  с  этим  потоком.  Это
все, что  Вы должны сделать.  Поток может узнать из VMT PSomeObject
тип объекта  (предполагая,  что   тип   был   зарегистрирован)   и,
следовательно, знать,  какой  номер  ID записывать и сколько данных
записать после него.
     Однако для  Вас,  как для программиста на Turbo Vision,  будет
особенно важно то,  что когда  Вы  записываете  в  поток  группу  с
подэлементами, подэлементы   будут   автоматически  записываться  в
поток. Поэтому сохранение сложного объекта будет вовсе  не сложным,
поскольку выполняется   автоматически!   Вы  можете  сохранить  все
состояние Вашей программы просто записав  панель  экрана  в  поток.
Когда Вы  запустите Вашу программу снова и загрузите панель экрана,
программа будет в том же состоянии, что и в точке сохранения панели
экрана.


#Ввод из потока.

     Считать объекты из потока  так  же  просто.  Вы  делаете  это,
используя функцию Get:

     PSomeObject := SomeStream.Get;

     где как  и  раньше SomeStream - инициализированный поток Turbo
Vision, а РSomeObject  -  указатель  на  любой  тип  объекта  Turbo
Vision. Get  просто  возвращает  указатель на то,  что он считал из
потока. Сколько данных он считал и какой тип VMT он  назначил  этим
данным определяется   не   типом   PSomeObject,  а  типом  объекта,
найденного в  потоке.  Поэтому,  если  объект  в  текущей   позиции
SomeStream не того же типа,  что PSomeObject, Вы получите случайную
информацию.
     Как и  Put,  Get  восстанавливает сложные объекты.  Так,  если
объект, считанный Вами из потока,  - это видимый элемент, владеющий
подэлементами, подэлементы будут так же загружены.


#В случае ошибки.

     Наконец, процедура  Error  определяет  что  произойдет,  когда
возникнет ошибка. По умолчанию TStream.Error просто устанавливает 2
поля (Status и ErrorInfo) в потоке. Если Вы хотите выполнить другие
действия, например  сгенерировать  ошибку  времени  выполнения  или
вывести ошибку  в  диалоговое  окно,   Вам   необходимо   перекрыть
процедуру Error.


#Удаление потока.

     Когда Вы заканчиваете использование потока,  Вы вызываете  его
метод Done точно так же, как Вы вызывали Close для дискового файла.
Как и для любого объекта Turbo Vision, Вы делаете это

     Dispose(SomeStream, Done);

     который удаляет объект потока.


#Использование объектов с потоком.

     Все стандартные  объекты Turbo Vision готовы к использованию с
потоками и все потоки Turbo Vision знают эти  стандартные  объекты.
Когда Вы  порождает  новый  тип  объекта  от одного из стандартных,
очень просто  подготовить  его  для  использования  с   потоком   и
сообщить потоку о его существовании.


#Методы Load и Store.

     Действительное чтение и запись объектов в поток обрабатывается
методами Load  и  Store.  Хотя  каждый  объект должен содержать эти
методы для того,  чтобы его можно было использовать с потоками,  Вы
никогда не вызываете их прямо.  (Они вызываются из Get и Put). Все,
что Вам требуется сделать - это убедиться, что Ваш объект знает как
послать себя в поток, когда ему говорят сделать это.
     Благодаря ООП эта работа очень проста, поскольку большая часть
механизма наследуется из объекта предка. Все, что Ваш объект должен
сделать -  это  загрузить  или  сохранить  ту  часть,  которую   Вы
добавили; за остальное отвечает вызов метода предка.
     Например Вы породили новый тип видимого элемента  от  TWindow,
назвав его  именем  известного  сюрреалиста Рене Магритте,  который
нарисовал много известных картин с окнами:

     type
       TМagritte = object(TWindow)
       Painted: Boolean;
       constructor Load(var S: TStream);
       procedure Draw;
       procedure Store(var S: TStream);
     end;

     В часть данных было добавлено только одно  поле  Boolean.  Для
того, чтобы   загрузить   объект,  Вы  просто  читаете  стандартный
TWindow, а затем читаете дополнительный байт,  соответствующий полю
Boolean. То  же  самое  применимо  к сохранению объекта:  Вы просто
записываете TWindow,  а потом записываете еще один  байт.  Типичные
методы Load и Store для порожденных объектов имеют вид:

     constructor TМargitte.Load(var S: Stream);
     begin
       TWindow.Load(S);
       S.Read(Painted, SizeOf(Boolean))
     end;

     procedure TМargitte.Store(var S: Stream);
     begin
       TWindow.Store(S);
       S.Write(Painted, SizeOf(Boolean))
     end;

     Предупреждение: Вы   полностью   ответственны   за   то,   что
сохраняется столько же данных,  сколько и загружается и что  данные
загружаются в том же порядке,  в каком они сохранялись.  Компилятор
не выдает ошибок. Это может приводить к огромным проблемам, если Вы
неаккуратны. Если   Вы  изменяете  поля  объектов,  убедитесь,  что
скорректированы и Load и Store.


#Регистрация потока.

     В дополнение  к  определению  методов  Load и Store для нового
объекта, Вы  должны  так  же  зарегистрировать  новый  тип  объекта
в потоке.   Регистрация  -  это  простой  двухшаговый  процесс,  Вы
определяете запись регистрации потока и передаете ее  в  глобальную
процедуру RegisterType.
     Чтобы определить запись регистрации  потока,  просто  следуйте
формату. Запись  регистрации  потока  -  это  запись  Паскаля  типа
TStreamRec, определенная:

     PStreamRec = ^TStreamRec;
     TStreamRec = record
       ObjType: Word;
       VmtLink: Word;
       Load: Pointer;
       Store: Pointer;
       Next: Word;
     end;

     Примечание: Все     стандартные     объекты    Turbo    Vision
зарегистрированы и Вам не нужно делать этого.

     По соглашениям Turbo Vision  все  записи  регистрации  потоков
имеют имена  соответствующих  объектных типов с заменой начальной Т
на R.  Так запись регистрации для  TDeskTop  -  RDeskTop  и  запись
регистрации для TMagritte - RMagritte.  Абстрактные типы, такие как
TObject и TView не имеют регистрационных записей, поскольку никогда
не создаются экземпляры этого типа.


#Номера ID объектов.

     Поле ObjType -  это  единственная  часть  записи,  которую  Вы
должны знать.  Каждый новый тип, определенный Вами, будет требовать
своего собственного   уникального   номера   типа.   Turbo   Vision
резервирует регистрационные  номера  от  0  до  99  для стандартных
объектов. Вы можете использовать регистрационные номера от  100  до
65,535.

     Примечание: Вы ответственны за создание и поддержку библиотеки
номеров ID для всех новых объектов,  которые используются в потоках
В/В и должны сделать ID доступными для пользователей Ваших модулей.
Как и  константы  команд,  номера,  назначаемые  Вами  могут   быть
абсолютно произвольными, главное, чтобы они были уникальными.


#Автоматические поля.

     Поле VmtLink - это связь с таблицей виртуальных  методов (VMT)
объекта. Вы просто назначаете его как смещение типа Вашего объекта:

     RSomeObject.VmtLink := Ofs(TypeOf(TSomeObject)^);

     Поля Load  и Store содержат адреса методов Load и Store Вашего
объекта.

     RSomeObject.Load := @TSomeObject.Load;
     RSomeObject.Store := @TSomeObject.Store;

     Последнее поле  Next назначается в процедуре RegisterType и не
требует Вашего вмешательства.  Оно  предназначено  для  внутреннего
использования в связанном списке регистрационных записей потока.


#Регистрация.

     После того,  как Вы  создали  запись  регистрации  потока,  Вы
вызываете RegisterType,  передавая  ему  Вашу  запись.  Так,  чтобы
зарегистрировать объект TMagritte для использования с  потоками, Вы
пишите:

     const
       RMagritte: TStreamRec = (
         ObjType: 100;
         VmtLink: Ofs(TypeOf(TMagritte)^);
         Load: @TMagritte.Load;
         Store: @TMagritte.Store
       );
     RegisterType(RMagritte);

     Теперь Вы можете выводить экземпляры  нового  типа  объекта  в
любой поток Turbo Vision и читать эти экземпляры из потоков.


#Механизм потоков.

     Сейчас, когда мы просмотрели  использование  потоков,  давайте
посмотрим что  делает  Turbo  Vision  с Вашими объектами,  когда Вы
вводите или выводите их.


#Работа Put.

     Когда Вы  посылаете  объект  в поток методом Put,  поток берет
указатель VMT со смещением 0  от  объекта  и  просматривает  список
типов, зарегистрированных  с  потоками  на  соответствие.  Когда он
находит соответствие,  поток  выбирает  регистрационный  номер   ID
объекта и записывает его в поток.  Поток затем вызывает метод Store
объекта для записи объекта.  Метод Store использует процедуру Write
потока, которая записывает правильное число байт в поток.
     Ваш объект ничего не знает о потоке.  Это может быть  дисковый
файл, EMS  память или другой тип потока - Ваш объект просто говорит
"Запиши меня в поток" и поток выполняет остальное.


#Работа Get.

     Когда Вы   читаете  объект  из  потока  методом  Get,  вначале
вводится номер ID и сканируется список зарегистрированных  типов на
соответствие. Когда   соответствие   найдено,   запись  регистрации
предоставляет потоку положение метода Load  и  VMT  объекта.  Затем
вызывается метод Load для чтения соответствующего количества данных
из потока.
     И снова,  Вы  просто  говорите потоку взять следующий объект и
вернуть указатель на его положение.  Ваш объект  не  заботится,  из
какого потока он был получен. Поток обеспечивает чтение правильного
количества данных, используя метод Load объекта.
     Это показывает как важно зарегистрировать тип до попытки В/В в
поток.


#Обработка nil указателей на объект.

     Вы можете  записать  nil  объект  в  поток.  Однако,  когда Вы
делаете это,  в поток записывается слово со значением 0. При чтении
ID = 0,  поток возвращает nil указатель, поэтому 0 зарезервирован и
не может использоваться как ID номер объекта.


#Коллекции в потоках - полный пример.

     В главе   7  "Коллекции"  Вы  видели  как  можно  сохранять  в
коллекциях различные,  но  связанные  объекты.  К  потокам  так  же
применимы полиморфные  свойства  и  они  могут  использоваться  для
сохранения целой коллекции на диске  для  восстановления  в  другое
время или  даже  другой программы.  Посмотрим еще раз TVGUID20.PAS.
Что нужно сделать, чтобы эта программа вывела коллекцию в поток?
     Ответ удивительно прост.  Во-первых, начнем с базового объекта
TGraphObject и "научим" его как сохранять его  данные  (X  и  Y)  в
потоке. Это  делает метод Store.  Затем определим новый метод Store
для каждого наследника TGraphObject,  который добавляет новые  поля
(TGraphCircle добавляет   Radius;   TGraphRect  добавляет  Width  и
Height).
     Затем создадим   регистрационную   запись   для  каждого  типа
объекта, который будет сохраняться и зарегистрируем каждый  из этих
типов. Это   все.  Все  остальное  как  при  обычном  вводе/выводе:
объявите переменную потока;  создайте новый  поток;  поместите  всю
коллекцию в поток одним оператором; закройте поток.


#Добавление методов Store.

     Здесь приведены методы  Store.  Заметим,  что  PGraphPoint  не
требует его,  поскольку  не  добавляет  полей  при  наследовании от
PGraphObject.

     type
       PGraphObject = ^TGraphObject;
       TGraphObject = object(TObject);
       ...
       procedure Store(var S: TStream); virtual;
     end;

     PGraphCircle = ^TGraphCircle;
     TGraphCircle = object(TGraphObject)
       Raduis: Integer;
       ...
       procedure Store(var S: TStream); virtual;
     end;

     PGraphRect = ^TGraphRect;
     TGraphRect = object(TGraphObject)
       Width, Height: Integer;
       ...
       procedure Store(var S: TStream); virtual;
     end;

     Реализация Store  совершенно  проста.  Каждый  объект вызывает
наследуемый метод Store,  который сохраняет все наследуемые данные.
Затем метод  Write потока записывает дополнительные данные.

     (* TGraphObject не вызывает TObject.Store, поскольку TObjeсt не
имеет данных для сохранения *)
     procedure TGraphObject.Store(var S: TStream);
     begin
       S.Write(X, SizeOf(X));
       S.Write(Y, SizeOf(Y));
     end;

     procedure TGraphCircle.Store(var S: TStream);
     begin
       TGraphObject.Store(S);
       S.Write(Radius, SizeOf(Radius));
     end;

     procedure TGraphRect.Store(var S: TStream);
     begin
       TGraphObject.Store(S);
       S.Write(Width, SizeOf(Width));
       S.Write(Height, SizeOf(Height));
     end;

     Заметим, что метод Write из TStream выполняет двоичную запись.
Его первый   параметр   может   быть  переменной  любого  типа,  но
TStream.Write не знает размера  этой  переменной.  Второй  параметр
предоставляет эту  информацию  и Вы должны использовать стандартную
функцию SizeOf. Таким образом, если Вы решите изменить координатную
систему, используя  числа  с  плавающей точкой,  Вам не потребуется
корректировать методы Store.


#Записи регистрации.

     Определение константы   записи   регистрации  для  каждого  из
наследуемых типов,  выполняется  последним  шагом.  Хорошая   мысль
следовать соглашению  Turbo  Vision  по  именованию:  используя R в
качестве первой буквы.

     Примечание: Вспомним,  что каждая запись регистрации  получает
уникальный номер  идентификатора  объекта  (Objtype).  Turbo Vision
резервирует от  0  до  99  для  стандартных  объектов.  Рекомендуем
сохранить ID  номера  всех  объектов  в  одном  месте для избежания
дублирования.

     const
       RGraphPoint: TStreamRec = (
         ObjType: 150;
         VmtLink: Ofs(TypeOf(TGraphPoint)^);
         Load: nil;
         Store: @TGraphPoint.Store;

       RGraphCircle: TStreamRec = (
         ObjType: 151;
         VmtLink: Ofs(TypeOf(TGraphCircle)^);
         Load: nil;
         Store: @TGraphCircle.Store;

       RGraphRect: TStreamRec = (
         ObjType: 152;
         VmtLink: Ofs(TypeOf(TGraphRect)^);
         Load: nil;
         Store: @TGraphRect.Store;

     Вам не  требуется  регистрационная  запись  для  TGraphObject,
поскольку это абстрактный тип и никогда не имеет экземпляров  и  не
помещается в  коллекцию  или  поток.  Каждый  указатель Load записи
регистрации устанавливается в nil, поскольку этот пример был создан
только для сохранения данных в поток. Методы Load будут определены,
а регистрационные  записи  скорректированы  в   следующем   примере
(TVGUID22.PAS).


#Регистрация.(I)

     Вы не должны забывать регистрировать каждую из этих записей до
выполнения ввода/вывода  в  поток.  Простейший способ сделать это -
поместить их в одну процедуру и вызвать ее в начале Вашей программы
(или в методе Init Вашей программы).

     procedure StreamRegistration;
     begin
       RegisterType(RCollection);
       RegisterType(RGraphPoint);
       RegisterType(RGraphCircle);
       RegisterType(RGraphRect);
     end;

     Заметим, что  Вы  зарегистрировали  TCollection (используя его
запись  RCollection  -  теперь  Вы  видите  почему  соглашения   об
именовании упрощает   программирование),   хотя  Вы  не  определяли
TCollection. Это правило просто:  Вы отвечаете за регистрацию  всех
типов объектов, которые выводятся в поток.


#Запись в поток.

     Все, что осталось сделать - это обычная последовательность В/В
в файл: создать поток; поместить данные (коллекцию) в него; закрыть
поток. Вы  не  используете  итератор  ForEach  для  записи  каждого
элемента коллекции  в  поток.  Вы  просто говорите потоку поместить
коллекцию в поток:

     (* TVGUID21.PAS *)
     var
       GraphicsList: PCollection;
       GraphicsStream: TBufStream;
     begin
       StreamRegistration;
       ...
       GraphicsStream.Init('GRAPHICS.STM', stCreate, 1024);
       GraphicsStream.Put(GraphicsList);
       GraphicsStream.Done;
       ...
     end.

     Будет создаваться  дисковый   файл,   который   содержит   всю
информацию, необходимую для чтения коллекции в память.  Когда поток
открывается и коллекция считывается (см. TVGUID22.PAS), все скрытые
связи между  коллекцией  и ее элементами и объектами и их таблицами
виртуальных методов будут восстановлены. Эта техника используется в
IDE Turbo  Pascal для сохранения его файла панели экрана. Следующий
пример показывает Вам как сделать это. Но вначале Вы должны изучить
объекты, выводимые  в  поток,  которые  содержат  связи  с  другими
объектами.


#Кто сохраняет?

     Важное предупреждение о потоках:  пользователь объекта  -  это
тот  объект,  который  должен  записывать этот объект в поток.  Это
предупреждение подобно тому с которым Вы вероятно  сталкивались при
использовании традиционного Паскаля:  владелец указателя - это тот,
кто должен освободить этот указатель.
     В сложной  реальной  программе  многочисленные  объекты  часто
будут содержать указатель на какую-то структуру. Когда придет время
для В/В  в поток,  Вы должны решить кто владелец структуры;  только
этот владелец должен посылать  эту  структуру  в  поток.  Иначе  Вы
получите в  потоке несколько копий одной структуры.  Затем когда Вы
будете читать поток будет создано несколько экземпляров структуры и
каждый отдельный объект теперь будет указывать на собственную копию
структуры вместо единственной первоначальной структуры.


#Экземпляры видимых подэлементов.

     Вам будет  удобно  сохранять указатели на подэлементы группы в
локальных экземплярах переменных.  Например,  диалоговое окно часто
хранит указатели  на  объекты  элементов  управления в мнемонически
названных полях для упрощения доступа (такие поля как  OKButton или
FileInputLine). Когда  этот  видимый  элемент  вставляется в дерево
видимых элементов,  владелец   содержит   2   указателя   на   этот
подэлемент, один в поле, а другой в списке подэлементов. Если Вы не
разрешаете это,  чтение объекта из потока приведет  к  дублированию
экземпляров.
     Решение -   в   предоставлении   методов    GetSubViewPtr    и
PutSubViewPtr  в TGroup.  Когда сохраняется поле,  которое является
подэлементом,  вместо  того  чтобы  записать  указатель,  как   это
делается с другими переменными, Вы вызываете PutSubViewPtr, который
сохраняет ссылку  на  позицию  подэлемента  в  списке  подэлементов
группы.  Таким образом когда Вы загружаете группу с помощью Load из
потока,  Вы можете вызвать GetSubViewPtr,  который гарантирует, что
это поле и список подэлементов указывают на один объект.
     Приведем короткий   пример   использования   GetSubViewPtr   и
PutSubViewPtr в простом окне:

     type
       TButtonWindow = object(TWindow)
         Button: PButton;
         constructor Load(var S: TStream);
         procedure Store(var S: TStream);
       end;

     constructor Load(var S: TStream);
     begin
       TWindow.Load(S);
       GetSubViewPtr(S, Button);
     end;

     procedure Store(var S: TStream);
     begin
       TWindow.Store(S);
       PutSubViewPtr(S, Button);
     end;

     Давайте посмотрим  чем  этолт  метод   Store   отличается   от
нормального Store.  После  сохранения  окна  Вы  просто  сохраняете
ссылку на поле Button вместо сохранения  самого  поля.  Сам  объект
кнопки сохраняется   как   подэлемент   окна,   когда   Вы  вызвали
TWindow.Store. Все  что  Вы  делаете  дополнительно   к   помещению
информации в  поток  это  говорите,  что  Button  указывает на этот
подэлемент. Метод Load делает то же  в  обратном  порядке,  вначале
загружая окно и подэлемент кнопки, а затем восстанавливая указатель
на этот подэлемент в Button.


#Равные экземпляры видимого элемента.

     Аналогичная ситуация  возникает,  когда  видимый элемент имеет
поле, указывающее на равный ему видимый  элемент.  Видимый  элемент
называется равным  другому  видимому  элементу,  если  оба  видимых
элемента принадлежат  одной  группе.  Хороший  пример  -  скроллер.
Поскольку скроллер  знает  о  двух  полосах скроллинга,  являющихся
элементами окна,  которому принадлежит скроллер, он имеет два поля,
которые указывают на эти видимые элементы.
     Как и с видимыми подэлементами,  у Вас могут быть проблемы при
чтении и  записи ссылок на равные видимые элементы в поток. Решение
также просто.  Методы PutPeerViewPtr и GetPeerViewPtr предназначены
для доступа   к   позиции   другого   видимого  элемента  в  списке
подобъектов владельца.
     Нужно заботится  только  о  загрузке  ссылок на равные видимые
элементы, который еще не загружены (т.е.  они стоят позже в  списке
подэлементов и   следовательно   позже   в  потоке).  Turbo  Vision
обрабатывает это автоматически,  сохраняя трассу всех таких  ссылок
вперед и разрешая их, когда все подэлементы группы будут загружены.
Вам необходимо помнить,  что ссылки на равные видимые  элементы  не
действительны до  тех  пор,  пока  не  будет  завершен  весь  Load.
Вследствие этого Вы не должны помещать в метод  Load  код,  который
использует подэлементы,  зависящие  от  равных подэлементов,  иначе
результаты будут непредсказуемы.


#Сохранение и загрузка панели экрана.

     Если Вы сохраняете панель экрана в потоке, панель экрана будет
сохранять все свое содержимое: всю среду панели экрана, включая все
текущие видимые элементы.
     Если Вы хотите разрешить пользователю сохранять панель экрана,
Вам необходимо убедиться,  что все возможные видимые элементы имеют
соответствующие видимые элементы Store  и  Load,  что  все  видимые
элементы зарегистрированы,  поскольку  пользователь может сохранить
панель экрана в любой момент.
     Чтобы сделать это Вы можете использовать подобный код:

     procedure TMyApp.RestoreDeskTop;
     var
       SaveFile: TBufStream;
       Temp: PDeskTop;
     begin
       SaveFile.Init('T.DSK', stOpen, 1024);
       Temp := PDeskTop(SaveFile.Get);
       SaveFile.Done;
       if Temp <> nil then
       begin
         Dispose(DeskTop, Done);
         DeskTop := Temp;
         Append(DeskTop);
         DeskTop^.DrawView;
       end;
       if SaveFile.Status <> 0 then ErrorReadingFile;
     end;

     Вы можете  сделать следующий шаг и сохранять и восстанавливать
всю программу.  Объект   TApplication   может   сам   сохранять   и
восстанавливать себя.


#Копирование потоков.

     TStream имеет метод CopyFrom(S, Count), который копирует Count
байт из  потока  S.  CopyFrom  может использоваться для копирования
всего содержимого  потока  в  другой  поток.  Если   Вы   постоянно
обращаетесь к  дисковым  потокам,  Вы  можете  скопировать их в EMS
поток для более быстрого доступа:

     NewStream := New(TEmsStream, Init(OldStream^.GetSize));
     OldStream^.Seek(0);
     NewStream^.CopyFrom(OldStream, OldStream^.GetSize);


#Прямой доступ к потокам.

     До сих   пор   мы  использовали  потоки  как  последовательные
устройства: Вы выводили объекты  в  конец  потока  и  считывали  их
обратно в   том   же   порядке.   Turbo  Vision  предоставляет  Вам
дополнительные возможности. Он позволяет Вам интерпретировать поток
как виртуальное устройство с прямым доступом.  В дополнение к Get и
Put, которые  соответствуют  Read  и  Write   для   файла,   потоки
предоставляют возможности   аналогичные   файловым  Seek,  FilePos,
FileSize и Truncate.
     - Процедура  Seek  передвигает  указатель  текущего  потока на
заданную позицию (в  байтах  лот  начала  потока)  как  стандартная
процедура Seek Turbo Pascal.
     - Функция  GetPos  обратна  процедуре  Seek.  Она   возвращает
LongInt с текущей позицией в потоке.
     - Функция GetSize возвращает размер потока в байтах.
     - Процедура  Truncate удаляет все данные после текущей позиции
потока, делая текущую позицию последней в потоке.
     Чтобы можно  было использовать эти программы,  прямой доступ к
потоку требует создания вне потока индекса,  содержащего  начальные
позиции каждого объекта в потоке.  Коллекция идеальна для этой цели
и в действительности используется в Turbo Vision с файлами ресурсов
(ресурсы обсуждаются в главе 9). Если Вы хотите использовать прямой
доступ к потоку, Вы можете использовать файл ресурса.


#Не-объекты в потоке.

     Вы можете   писать   в   поток  данные,  которые  не  являются
объектами, но  Вы  должны  использовать  при  этом  другой  подход.
Стандартные методы  Get  и  Put  требуют,  чтобы  Вы  сохраняли или
загружали объект,  порожденный от TObject.  Если Вы хотите  создать
поток не-объектов, перейдите прямо на низкоуровневые процедуры Read
и Write,  каждая из которых читает или пишет заданное число байт  в
поток. Этот  же  механизм  используется  в  Get  и Put для чтения и
записи данных  объектов;   Вы   просто   обходите   механизм   VMT,
используемый в Get и Put.


#Проектирование Ваших потоков.

     Этот раздел суммирует методы и  возможности  обработки  ошибок
потоков Turbo Vision так, чтобы Вы знали что Вы можете использовать
при создании новых типов потоков.
     TStream -   это   абстрактный   объект,  который  должен  быть
расширен, чтобы  создать  используемый  тип   потока.   Большинство
методов TStream  абстрактные  и  должны  быть  реализованы  в Ваших
наследниках, а другие зависят от  методов  TStream.  Только  методы
Error, Get и Put полностью реализованы в TStream.  GetPos, GetSize,
Read, Seek,  SetPos,  Truncate и Write должны быть перекрыты.  Если
тип порожденного  объекта имеет буфер,  так же должен быть перекрыт
метод Flush.


#Обработка ошибок потока.

     TStream имеет  метод  Error(Code,  Info),  который вызывается,
когда поток обнаруживает ошибку.  Error просто  устанавливает  поле
Status в   одну  из  констант,  приведенную  в  разделе  "Константы
stXXXX" главы 14.
     Поле ErrorInfo  за  исключением  ситуации,  когда Status равен
stGetError или stPutError,  неопределено. Если Status - stGetError,
поле ErrorInfo  содержит  номер  ID  незарегистрированного  типа  в
потоке. Если Status - stPutError,  поле ErrorInfo содержит смещение
VMT для  типа,  который  Вы пытаетесь поместить в поток.  Вы можете
перекрыть TStream.Error  для  создания  любой   обработки   ошибок,
включая ошибки времени выполнения.

@ГЛАВА 9. РЕСУРСЫ.

#Ресурсы

     Файл ресурса  -  это  объект  Turbo  Vision,   который   будет
сохранять объекты,  а  затем  выдавать их по имени.  Ваша программа
может получать затем эти объекты  из  ресурса  вместо  того,  чтобы
инициализировать их.  Таким  образом  Ваша  программа  вместо того,
чтобы инициализировать используемые объекты,  может использовать их
из ресурса, который создан отдельной программой.
     Этот механизм достаточно прост:  файл  ресурсов  работает  как
поток с   прямым   доступом,  обращаясь  к  объектам  по  ключам  -
уникальным строкам, идентифицирующим ресурсы.
     В отличие  от  других  частей Turbo Vision Вам,  вероятно,  не
потребуется изменять механизма  ресурсов.  Ресурсы, предоставляемые
Turbo Vision, гибки и надежны. Вам необходимо просто изучить их.


#Для чего используются ресурсы?

     Использование файла ресурса дает ряд преимуществ.
     Использование ресурсов    позволяет   Вам   настраивать   Вашу
программу не изменяя код.  Например,  текст диалоговых окон,  метки
элементов меню,  цвета  видимых  элементов  могут  быть получены из
ресурса.
     Вы можете  уменьшить код,  поместив Init всех Ваших объектов в
отдельную программу.  Инициализация часто бывает достаточно сложной
и содержит вычисления и другие операции,  которые Вы можете вынести
из Вашего кода.  Вам остается только использовать Load для  каждого
объекта в  Вашей  программе,  но загрузка всегда значительно проще,
чем Init.  Вы можете уменьшить  Ваш  код  от  8  до  10  процентов,
используя ресурс.
     Использование ресурса так же упрощает поддержку  версий  Вашей
программы, настраиваемой   на   различные   языки.  Ваша  программа
загружает объекты по имени,  а язык,  на  котором  они  отображают,
заключен в них.
     Если Вы хотите  предоставить  версии  программы  с  различными
возможностями, Вы можете, например, разработать 2 набора меню, один
из которых предоставляет доступ  ко  всем  возможностям,  а  другой
предоставляет доступ  только  к  ограниченному набору функций.  Для
этого Вам не требуется переписывать весь код и Вам не нужно бояться
случайно удалить нужную часть кода. Вы можете настраивать программу
на полную функциональность предоставлением  только  нового  ресурса
вместо замены всей программы.
     Короче, ресурс   изолирует   представление   объектов    Вашей
программы и упрощает ее изменение.


#Что в ресурсе?

     До того,  как рассматривать детали ресурсов,  Вы должны хорошо
освоить потоки  и  коллекции,  поскольку  механизм  ресурса  широко
использует их.  Вы можете использовать  ресурсы  не  зная  как  они
работают, но  если  Вы  собираетесь изменить их,  Вам требуется это
знать.
     TResourсeFile содержит   отсортированную   коллекцию  строк  и
поток. Строки  в  коллекции  -  это  ключи  к  объектам  в  потоке.
TResourceFile имеет  метод  Init,  который берет поток и метод Get,
который берет строку и возвращает объект.


#Создание ресурса.

     Создание файла  ресурса выполняется в 4 этапа.  Вам необходимо
открыть поток,  инициализировать  файл  ресурса  с  этим   потоком,
сохранить один или более объектов с их ключами и закрыть ресурс.
     Следующий код создает простой файл ресурса  MY.REZ, содержащий
один ресурс: строку статуса с ключем 'Waldo':

     program BuildResourse;

     uses Drivers, Objects, Views, App, Menus;

     type
       PHaltStream = ^THaltStream;
       THaltStream = object(TBufStream)
         procedure Error(Code, Info: Integer);virtual;
       end;

     var
       MyRez: TResourceFile;
       MyStrm: PHaltStream;

     procedure THaltStream.Error(Code, Info: Integer);
     begin
       Writeln('Stream error: ', Code, ' (', Info, ')');
       Halt(1);
     end;

     procedure CreateStatusLine;
     var
       StatusLine: PStatusLine;
     begin
       StatusLine := New(PStatusLine, Init( 0,$FFFF,
         NewStatusItem('~Alt-X~ Exit', AltX, cmQuit,
         NewStatusItem('~F3~ Open', F3Key, cmNewDlg,
         NewStatusItem('~F5~ Zoom', F5Key, cmZoom,
         NewStatusItem('~Alt-F3~ Close', AltF3, cmClose,
         nil))))
       ));
       MyRez.Put(StatusLine, 'Waldo');
       Dispose(StatusLine, Done);
     end;

     begin
       MyStrm := New(PHaltStream, Init('MY.REZ', stCreate, 1024));
       MyRez.Init(MyStrm);
       CreateStatusLine;
       MyRez.Done;
     end.


#Чтение ресурса.

     Получить ресурс из файла ресурса так же просто,  как  получить
объект из  потока:  Вы просто вызываете функцию Get файла ресурса с
ключем требуемого ресурса. Get возвращает указатель на PObject.
     Ресурс строки статуса,  созданные в предыдущем примере,  может
быть получен:

     program MyApp;

     uses Objects, Drivers, Views, Menus, Dialogs, App;

     var
       MyRez: TResourceFile;

     type
       PMyApp = ^TMyApp;
       TMyApp = object(TApplication)
         constructor Init;
         procedure InitStatusLine; virtual;
       end;

     constructor TMyApp.Init;
     var
       S: PStream;
       FileName: PathStr;
       Event: TEvent;
     const
       MyRezFileName: PathStr = 'MY.REZ';
     begin
       MyRez.Init(New(PBufStream, Init(MyRezFileName, stOpen,
                      1024)));
       if MyRez.Stream^.Status <> 0 then Halt(1);
       TApplication.Init;
     end;

     procedure TMyApp.InitStatusLine;
     begin
       StatusLine := PStatusLine(MyRez.Get('Waldo'));
     end;

     Когда Вы читаете ресурс объекта, Вы должны знать о возможности
получения nil указателя.  Если индекс имени неверен (т.е.  если нет
ресурса с таким ключем) Get возвращает nil.  Однако после того, как
код ресурса будет отлажен, в дальнейшем не должно быть проблем.
     Вы можете  считывать  объект  ресурса  повторно.  Вряд  ли Вам
понадобиться делать это со строкой  статуса  в  нашем  примере,  но
например диалоговое окно может быть считано пользователем много раз
во время  выполнения  программы.  Ресурс  просто  постоянно  выдает
объект при запросе.
     Это потенциально  может  приводить  к  проблемам  с  медленным
дисковым В/В   даже   если  файл  ресурса  буферизован.  Вы  можете
увеличить буферизацию или скопировать поток в EMS поток,  если  EMS
инсталлирована.


#Список строк.

     В дополнение к стандартному механизму  ресурса,  Turbo  Vision
предоставляет пару   специализированных   объектов  для  управления
списками строк.  Список строк -  это  специальный  ресурс,  который
позволяет Вашей   программе  обращаться  к  строковым  ресурсам  по
номерам (обычно   представленными   целыми   константами)    вместо
строковых ключей.  Это позволяет программе сохранять строки в файле
ресурса для упрощения настройки.
     Например, IDE  Turbo Pascal использует объект списка строк для
всех сообщений об ошибках. Это означает, что программа может просто
вызвать сообщение   об  ошибке  по  номеру  и  различные  версии  в
различных странах будут выбирать различные строки из их ресурсов.
     Объект списка  строк  спроектирован  не очень гибко,  но очень
быстр и удобен при правильном использовании.
     Объект TStringList  используется для доступа к строкам.  Чтобы
создать список строк, необходимо использовать объект TStrListMaker.
Записи регистрации  для  этих  объектов имеют одинаковый номер типа
объекта.
     Объект списка   строк   не  имеет  метода  Init.  Используется
единственный констрактор  -  метод  Load,  поскольку  списки  строк
существуют только  в файлах ресурса.  Аналогично,  поскольку список
строк - это ресурс только для чтения,  он имеет функцию Get,  но не
имеет процедуры Put.


#Создание списков строк.

     Тип объекта TStrListMaker  используется  для  создания  списка
строк в файле ресурса для последующего использования с TStringList.
В противоположность  этому  списку  строк,  который  можно   только
читать, создаваемый  список строк возможно только записывать.  Все,
что Вы  можете   делать   при   создании   списка   строк   -   это
инициализировать  список  строк,  последовательно записывать в него
строки и сохранить результирующий список в потоке.

@ГЛАВА 10. СОВЕТЫ.

#Советы

     Эта глава содержит несколько дополнительных предложений о том,
как использовать   Turbo   Vision   более   эффективно.   Поскольку
объектно-ориентированное программирование    и    программирование,
управляемое  событиями  -  это  новая  концепция  даже  для опытных
программистов,  мы  попробуем  предоставить  некоторые  советы   по
использованию новых парадигм.


#Отладка программ на Turbo Vision.

     Если Вы  попытаетесь  трассировать  какой-нибудь  из  примеров
этого руководства,   Вы,  вероятно,  заметите,  что  Вы  не  можете
зайти очень далеко. Поскольку программы на Turbo Vision управляются
событиями, большая  часть  программного  времени тратится на цикл в
TGroup.Execute ожидая  когда  произойдет  какое-либо   событие.   В
результате трассировка этой точки имеет мало смысла.

     Примечание: Ключем к отладке программ на Turbo Vision являются
точки прерывания и только точки прерывания.

     Давайте посмотрим как лучше разместить точки прерывания, чтобы
обнаружить проблемы в программе на Turbo Vision.


#Это здесь не получить.

     Одна из проблем при отладке Вашей программы  может заключаться
в том,  что  какая-то  часть  Вашего  кода  не  будет  выполняться.
Например, Вы можете отметить элемент  строки  статуса  или  выбрать
опцию меню, которая должна вызвать окно, но этого не происходит.
     Обычно Вы пошагово проходите программу до  тех  пор,  пока  не
дойдете до  этой  команды,  а  затем смотрите что происходит вместо
того что должно происходить. Но если Вы попробуете сделать это, это
Вам не  поможет.  Когда  Вы  сделаете  следующий шаг,  Вы вернетесь
обратно в то место, где Вы были.
     Лучший подход  в этой ситуации - установить точку прерывания в
метод HandleEvent,  который  должен  вызывать  код  не   получающий
управления. Установите точку прерывания в начале метода HandleEvent
и когда программа остановится  в  нем,  проверьте  запись  события,
чтобы убедиться,  что это именно то событие, которое Вы ожидали. Вы
так же  можете  выполнить  трассировку  с  этой  точки,   поскольку
HandleEvent и  код,  откликающийся на Ваши команды,  - это тот код,
который Вы написали,  и следовательно Вы можете его оттрассировать.


#Проверьте маску.

     Запомните, что существуют причины, по которым Ваш объект может
никогда не увидеть событие,  которое Вы хотите ему передать. Первая
и простейшая  ошибка  -  это  неустановленный  тип  события в маске
событий Вашего объекта.  Если Вы не сказали своему объекту, что ему
разрешено  обработать  определенный вид события,  он даже не увидит
этих событий!


#Украденные события.

     Вторая возможность,  которую  необходимо рассмотреть - это то,
что другой объект мог "украсть" событие.  Т.е. событие обработано и
очищено не тем объектом, которому Вы намеревались передать событие.
     Это может происходить по нескольким  причинам.  Первая  -  это
дублирование объявлений  команд:  если две команды назначены одному
константному значению,  они могут  обрабатываться  взаимозаменяемо.
Вот почему  необходимо  отследивать,  каким  константам назначаются
какие значения,  особенно в ситуации, когда Вы повторно используете
код модулей.
     Вторая возможная причина в дублировании меток команд, особенно
при повторном использовании кода.  Так,  если Вы назначаете команду
cmJump и существует метод HandleEvent в  каком-то  другом  объекте,
который уже  откликается  на  команду cmJump и о котором Вы забыли,
это может  привести  к   конфликтам.   Всегда   просматривайте   не
используют ли    другие    объекты    события,    которые   кажутся
"потерянными".


#Вина Ваших предков.

     Наконец убедитесь,  что  событие  не  было обработано в вызове
предка объекта.  Часто метод HandleEvent порожденного типа вызывает
обработчик событий  его  предка  для обработки большинства событий,
который может неожиданно обработать одно  из  событий.  Попытайтесь
перехватить событие до вызова HandleEvent предка.


#Делается не то, что ожидалось.

     Предположим, Ваше окно отображается, но выводит грязь или что-
то отличное  от  того,  что  Вы ожидали.  Это указывает на то,  что
событие  обработано  правильно,  но  код,  который  откликается  на
событие  некорректен  или  перекрыт.  В  этом  случае  лучше  всего
установить точку прерывания в  программе,  которая  вызывается  при
этом событии.  После  прерывания  выполнения Вы можете трассировать
Ваш код.


#Зависания.

     Ошибки, приводящие к зависаниям,  наиболее трудно отслеживать,
но они  могут  быть  найдены.  Для  начала  Вы  можете  попробовать
комбинацию точек  прерывания,  предложенную  ранее  для локализации
места, в  котором  происходит  зависание.  Затем   посмотрите,   не
освобождаются ли   указатели  дважды.  Это  может  произойти  когда
видимый  элемент  освобождается  своим  владельцем,  а   затем   Вы
пытаетесь освободить его напрямую. Например:

     (* Этот код приводит к зависанию системы *)
     var
       Bruce, Pizza: PGroup;
       R: TRect;
     begin
       R.Assign(5, 5, 10, 20);
       Pizza := New(PGroup, Init(R));
       R.Assign(10, 10, 20, 20);
       Bruce := New(PGroup, Init(R));
       Bruce^.Insert(Pizza);
       Dispose(Bruce, Done);
       Dispose(Pizza, Done);
     end;

     Освобождение группы   Bruce  так  же  освобождает  подэлементы
Pizza. Если  Вы  попытаетесь  освободить  Pizza,   Ваша   программа
зависнет.
     К зависанию может так же  приводить  чтение  данных  потока  в
ошибочный тип  объекта  и  некорректное  приведение  типа данных из
коллекций.


#Встраивание программ в Turbo Vision.

     Если Вы хотите встроить существующую программу в Turbo Vision,
Вы можете попытаться встроить интерфейс Turbo  Vision  в  программу
или поместить  слой  Turbo  Vision над Вашей программой.  Это будет
неудачная попытка.  Программы Turbo Vision управляются событиями  и
большинство существующих  программ  будет  не  просто  (если вообще
возможно) преобразовать к этой парадигме.


#Удаление "мусора" из старого кода.

     Есть простой    путь.   Сейчас   Вы   знаете,   что   сущность
программирования отдельной    программы     на     Turbo     Vision
сконцентрирована в  методах  Init,  Draw  и  HandleEvent программы.
Наилучший подход к встраиванию существующей программы - это вначале
написать интерфейс  Turbo Vision,  который заменит существующий,  а
затем выбрать необходимый  код  из  старой  программы.  Большинство
этого кода попадет в методы Init,  Draw и HandleEvent новых видимых
элементов.
     Вам потребуется  определенное время,  чтобы осмыслить сущность
Вашей программы так,  чтобы Вы могли  отделить  код  интерфейса  от
кода, выполняющего работу Вашей программы. Это может быть непросто,
поскольку Вы привыкли представлять программу по-другому.
     Работа по  переносу  будет включать определенное переписывание
для того,  чтобы научить новые объекты представлять самих  себя,  а
так же   приведет   к   отбрасыванию  большого  количества  старого
интерфейсного кода.  Это не должно приводить к новым ошибкам  и  Вы
будете делать это с удовольствием.
     Если Вы переносите программу,  Вы будете  удивлены,  обнаружив
как много   кода   предназначено  для  управления  пользовательским
интерфейсом. Когда Вы  позволите  Turbo  Vision  работать  за  Вас,
большая часть   работы  пользовательского  интерфейса,  которую  Вы
делали раньше, просто исчезнет.
     Мы обнаружили  это,  когда  переносили  интегрированную  среду
Turbo Pascal в Turbo Vision.  Мы освободили компилятор,  редактор и
отладчик от  старого  пользовательского интерфейса и перенесли их в
пользовательский интерфейс, написанный на Turbo Vision.


#Переосмысление проекта.

     В традиционном  программировании мы думали о программе с точки
зрения кода.  Теперь мы можем попытаться организовать программу так
же, как   интегрированная   среда   Turbo  Pascal  окружает  объект
редактора. Большую часть времени в интегрированной среде Вы тратите
на редактирование. Редактор будет редактировать, а в промежутках от
вызывает компилятор.
     Но требуется    изменить    перспективу,    чтобы    правильно
использовать мощь ООП.  Имеет смысл в случае интегрированной  среды
сделать саму  программу  объектом.  Когда необходимо редактировать,
программа вызывает  редактор.   Когда   необходимо   компилировать,
программа вызывает  компилятор, инициализируя  его  и  говоря какие
файлы компилировать.
     Если компилятор  встретил  ошибку как пользователь вернется на
точку ошибки в  исходном  коде?  Программа  вызывает  компилятор  и
получает результат  от  него.  Если компилятор возвращает ошибочный
результат, он так же возвращает имя файла и номер строки. Программа
смотрит, открыт ли редактор для этого файла, и если нет - открывает
его. Он передает информацию  об  ошибке,  включая  номер  строки  в
редактор и конструирует строку сообщения об ошибке для редактора.


#Использование побитовых полей.

     Видимые элементы Turbo  Vision  используют  поля  с  побитовым
отображением. Т.е.  они  используют  отдельные биты байта или слова
для указания различных свойств.  Отдельные биты  обычно  называются
флагами, поскольку  они  устанавливаются  (1)  или  очищаются  (0),
указывая, является ли данное свойство активным.
     Например, каждый  видимый  элемент  имеет  поле  Options  типа
слово. Каждый отдельный бит слова имеет различное значение  в Turbo
Vision.


#Значения флагов.

     В диаграмме,  описывающей биты поля Options (рис.4.14 главы 4)
msb указывает старший бит, а lsb указывает младший бит.
     Так например 4-ый бит называется ofFramed.  Если бит  ofFramed
установлен в  1,  это  означает,  что видимый элемент имеет видимую
рамку. Если бит равен 0, видимый элемент не имеет рамки.
     Обычно Вас   не   интересуют   значения  флагов,  если  Вы  не
собираетесь определить  свои  и  даже  в  этом  случае  Вас   будет
интересовать только  то,  чтобы  Ваши определения были уникальными.
Например, 6 старших бит в  слове  Options  не  определены  в  Turbo
Vision.  Вы  можете  определить  любой  из  них  с  необходимым Вам
смыслом.


#Битовые маски.

     Маска -  это  просто  удобный  способ  обработки группы флагов
вместе. Например, Turbo Vision определяет маски для различных видов
событий. Маска  evMouse просто содержит все 4 бита, устанавливаемые
для различных  видов  событий  от  мышки.  Поэтому  если   видимому
элементу необходимо  проверить событие от мышки,  он может сравнить
тип события с маской вместо того,  чтобы проверять каждый из  видов
событий от мышки.


#Побитовые операции.

     Turbo Pascal   предоставляет   ряд   полезных   операций   для
манипуляции битами.   Вместо   детального   объяснения   каждой  из
операций, этот раздел просто говорит что Вы должны  сделать,  чтобы
выполнить работу.


#Установить бит.

     Чтобы установить бит используйте оператор or.  Например, чтобы
установить бит  ofPostProcess  в  поле  Options для кнопки MyButton
используйте:

     MyButton.Options := MyButton.Options or ofPostProcess;

     Вы можете использовать сложение для  установки  битов,  только
если Вы  абсолютно  уверены  что  делаете.  Например,  если  вместо
предыдущего кода Вы используете

     MyButton.Options := MyButton.Options + ofPostProcess;

     Ваша операция  будет  работать  если   и   только   если   бит
ofPostProcess  не  был  установлен.  Если  бит  уже был установлен,
двоичное сложение приведен к переносу в следующий бит (ofBuffered),
устанавливая или очищая в зависимости от его значения.
     Другими словами:   прибавление   битов   может   привести    к
неожиданным эффектам. Вместо этого используйте операцию or.
     Заметим, что  Вы  можете  установить  несколько  бит  в  одной
операции. Следующий код будет устанавливать 2 различных флага:

     MyScroller.GrowMode := MyScroller.GrowMode or
                            (gfGrowHiX + gfGrowHiY);


#Очистить бит.

     Очистить бит  так  же  просто,  как  и  установить.  Вы просто
используете другую  операцию.   Лучший   способ   сделать   это   -
использовать комбинацию   двух   побитовых   операций  and  и  not.
Например, чтобы очистить  бит  dmLimitLoX  в  поле  DragMode  метки
АLabel используйте

     ALabel.DragMode := ALabel.DragMode and not dmLimitLoX;

     Как и  при  установке Вы можете очистить несколько бит в одной
операции.


#Проверить биты.

     Часто необходимо  проверить,  установлен ли определенный флаг.
При этом используется  операция  and.  Например,  для  того,  чтобы
проверить, может  ли  окно  AWindow  быть  размещенным черепицей на
панели экрана, проверьте флаг ofTileable:

     if AWindow.Options and ofTileable = ofTileable then ...


#Использование масок.

     Так же, как при проверке отдельных бит, Вы можете использовать
and для  проверки,  установлен  ли  один  или  более  битов  маски.
Например, для  того,  чтобы посмотреть,  содержит ли запись события
событие от мышки, Вы можете проверить:

      if Event.What and evMouse <> 0 then ...


#Итоги.

     Следующий список содержит все побитовые операции:

     Установить бит:
     field := field or flag;

     Очистить бит:
     field := field and not flag;

     Проверить, установлен ли флаг:
     if field and  flag = flag then ...

     Проверить, установлен ли флаг в маске:
     if flag and mask <> 0 then ...


